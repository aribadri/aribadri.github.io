import {
  GLTFLoader_exports,
  init_GLTFLoader
} from "./chunk-GTMK6LXJ.js";
import {
  require_three
} from "./chunk-4T4KLTDS.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  AmbientLight,
  AnimationClip,
  Bone,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  Curve,
  DataTextureLoader,
  DirectionalLight,
  DoubleSide,
  EquirectangularReflectionMapping,
  Euler,
  EventDispatcher,
  FileLoader,
  Float32BufferAttribute,
  FrontSide,
  Group,
  Line,
  LineBasicMaterial,
  LineSegments,
  LinearMipmapLinearFilter,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  NumberKeyframeTrack,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RepeatWrapping,
  Scene,
  Skeleton,
  SkinnedMesh,
  Spherical,
  SpotLight,
  TOUCH,
  Texture,
  TextureLoader,
  Uint16BufferAttribute,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  init_three_module,
  sRGBEncoding
} from "./chunk-EOQWBWMA.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/three/examples/jsm/controls/OrbitControls.js
var OrbitControls_exports = {};
__export(OrbitControls_exports, {
  OrbitControls: () => OrbitControls
});
var _changeEvent, _startEvent, _endEvent, OrbitControls;
var init_OrbitControls = __esm({
  "node_modules/three/examples/jsm/controls/OrbitControls.js"() {
    init_three_module();
    _changeEvent = { type: "change" };
    _startEvent = { type: "start" };
    _endEvent = { type: "end" };
    OrbitControls = class extends EventDispatcher {
      constructor(object, domElement) {
        super();
        this.object = object;
        this.domElement = domElement;
        this.domElement.style.touchAction = "none";
        this.enabled = true;
        this.target = new Vector3();
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.minZoom = 0;
        this.maxZoom = Infinity;
        this.minPolarAngle = 0;
        this.maxPolarAngle = Math.PI;
        this.minAzimuthAngle = -Infinity;
        this.maxAzimuthAngle = Infinity;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1;
        this.enableRotate = true;
        this.rotateSpeed = 1;
        this.enablePan = true;
        this.panSpeed = 1;
        this.screenSpacePanning = true;
        this.keyPanSpeed = 7;
        this.autoRotate = false;
        this.autoRotateSpeed = 2;
        this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
        this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
        this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        this._domElementKeyEvents = null;
        this.getPolarAngle = function() {
          return spherical.phi;
        };
        this.getAzimuthalAngle = function() {
          return spherical.theta;
        };
        this.getDistance = function() {
          return this.object.position.distanceTo(this.target);
        };
        this.listenToKeyEvents = function(domElement2) {
          domElement2.addEventListener("keydown", onKeyDown);
          this._domElementKeyEvents = domElement2;
        };
        this.stopListenToKeyEvents = function() {
          this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
          this._domElementKeyEvents = null;
        };
        this.saveState = function() {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };
        this.reset = function() {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;
          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(_changeEvent);
          scope.update();
          state = STATE.NONE;
        };
        this.update = function() {
          const offset = new Vector3();
          const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
          const quatInverse = quat.clone().invert();
          const lastPosition = new Vector3();
          const lastQuaternion = new Quaternion();
          const twoPI = 2 * Math.PI;
          return function update() {
            const position = scope.object.position;
            offset.copy(position).sub(scope.target);
            offset.applyQuaternion(quat);
            spherical.setFromVector3(offset);
            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }
            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }
            let min = scope.minAzimuthAngle;
            let max2 = scope.maxAzimuthAngle;
            if (isFinite(min) && isFinite(max2)) {
              if (min < -Math.PI)
                min += twoPI;
              else if (min > Math.PI)
                min -= twoPI;
              if (max2 < -Math.PI)
                max2 += twoPI;
              else if (max2 > Math.PI)
                max2 -= twoPI;
              if (min <= max2) {
                spherical.theta = Math.max(min, Math.min(max2, spherical.theta));
              } else {
                spherical.theta = spherical.theta > (min + max2) / 2 ? Math.max(min, spherical.theta) : Math.min(max2, spherical.theta);
              }
            }
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
            spherical.makeSafe();
            spherical.radius *= scale;
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }
            offset.setFromSpherical(spherical);
            offset.applyQuaternion(quatInverse);
            position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;
              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);
              panOffset.set(0, 0, 0);
            }
            scale = 1;
            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
              scope.dispatchEvent(_changeEvent);
              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;
              return true;
            }
            return false;
          };
        }();
        this.dispose = function() {
          scope.domElement.removeEventListener("contextmenu", onContextMenu);
          scope.domElement.removeEventListener("pointerdown", onPointerDown);
          scope.domElement.removeEventListener("pointercancel", onPointerUp);
          scope.domElement.removeEventListener("wheel", onMouseWheel);
          scope.domElement.removeEventListener("pointermove", onPointerMove);
          scope.domElement.removeEventListener("pointerup", onPointerUp);
          if (scope._domElementKeyEvents !== null) {
            scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
            scope._domElementKeyEvents = null;
          }
        };
        const scope = this;
        const STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6
        };
        let state = STATE.NONE;
        const EPS = 1e-6;
        const spherical = new Spherical();
        const sphericalDelta = new Spherical();
        let scale = 1;
        const panOffset = new Vector3();
        let zoomChanged = false;
        const rotateStart = new Vector2();
        const rotateEnd = new Vector2();
        const rotateDelta = new Vector2();
        const panStart = new Vector2();
        const panEnd = new Vector2();
        const panDelta = new Vector2();
        const dollyStart = new Vector2();
        const dollyEnd = new Vector2();
        const dollyDelta = new Vector2();
        const pointers = [];
        const pointerPositions = {};
        function getAutoRotationAngle() {
          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }
        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }
        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }
        const panLeft = function() {
          const v = new Vector3();
          return function panLeft2(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.multiplyScalar(-distance);
            panOffset.add(v);
          };
        }();
        const panUp = function() {
          const v = new Vector3();
          return function panUp2(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v.setFromMatrixColumn(objectMatrix, 0);
              v.crossVectors(scope.object.up, v);
            }
            v.multiplyScalar(distance);
            panOffset.add(v);
          };
        }();
        const pan = function() {
          const offset = new Vector3();
          return function pan2(deltaX, deltaY) {
            const element = scope.domElement;
            if (scope.object.isPerspectiveCamera) {
              const position = scope.object.position;
              offset.copy(position).sub(scope.target);
              let targetDistance = offset.length();
              targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
              panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
              panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else if (scope.object.isOrthographicCamera) {
              panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
              panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
            } else {
              console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
              scope.enablePan = false;
            }
          };
        }();
        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
            scope.enableZoom = false;
          }
        }
        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
            scope.enableZoom = false;
          }
        }
        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }
        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          const element = scope.domElement;
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
          scope.update();
        }
        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);
          dollyDelta.subVectors(dollyEnd, dollyStart);
          if (dollyDelta.y > 0) {
            dollyOut(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyIn(getZoomScale());
          }
          dollyStart.copy(dollyEnd);
          scope.update();
        }
        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
          scope.update();
        }
        function handleMouseWheel(event) {
          if (event.deltaY < 0) {
            dollyIn(getZoomScale());
          } else if (event.deltaY > 0) {
            dollyOut(getZoomScale());
          }
          scope.update();
        }
        function handleKeyDown(event) {
          let needsUpdate = false;
          switch (event.code) {
            case scope.keys.UP:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
              } else {
                pan(0, scope.keyPanSpeed);
              }
              needsUpdate = true;
              break;
            case scope.keys.BOTTOM:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
              } else {
                pan(0, -scope.keyPanSpeed);
              }
              needsUpdate = true;
              break;
            case scope.keys.LEFT:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
              } else {
                pan(scope.keyPanSpeed, 0);
              }
              needsUpdate = true;
              break;
            case scope.keys.RIGHT:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
              } else {
                pan(-scope.keyPanSpeed, 0);
              }
              needsUpdate = true;
              break;
          }
          if (needsUpdate) {
            event.preventDefault();
            scope.update();
          }
        }
        function handleTouchStartRotate() {
          if (pointers.length === 1) {
            rotateStart.set(pointers[0].pageX, pointers[0].pageY);
          } else {
            const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
            const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
            rotateStart.set(x, y);
          }
        }
        function handleTouchStartPan() {
          if (pointers.length === 1) {
            panStart.set(pointers[0].pageX, pointers[0].pageY);
          } else {
            const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
            const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
            panStart.set(x, y);
          }
        }
        function handleTouchStartDolly() {
          const dx = pointers[0].pageX - pointers[1].pageX;
          const dy = pointers[0].pageY - pointers[1].pageY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          dollyStart.set(0, distance);
        }
        function handleTouchStartDollyPan() {
          if (scope.enableZoom)
            handleTouchStartDolly();
          if (scope.enablePan)
            handleTouchStartPan();
        }
        function handleTouchStartDollyRotate() {
          if (scope.enableZoom)
            handleTouchStartDolly();
          if (scope.enableRotate)
            handleTouchStartRotate();
        }
        function handleTouchMoveRotate(event) {
          if (pointers.length == 1) {
            rotateEnd.set(event.pageX, event.pageY);
          } else {
            const position = getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            rotateEnd.set(x, y);
          }
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          const element = scope.domElement;
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
        }
        function handleTouchMovePan(event) {
          if (pointers.length === 1) {
            panEnd.set(event.pageX, event.pageY);
          } else {
            const position = getSecondPointerPosition(event);
            const x = 0.5 * (event.pageX + position.x);
            const y = 0.5 * (event.pageY + position.y);
            panEnd.set(x, y);
          }
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
        }
        function handleTouchMoveDolly(event) {
          const position = getSecondPointerPosition(event);
          const dx = event.pageX - position.x;
          const dy = event.pageY - position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          dollyEnd.set(0, distance);
          dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
          dollyOut(dollyDelta.y);
          dollyStart.copy(dollyEnd);
        }
        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom)
            handleTouchMoveDolly(event);
          if (scope.enablePan)
            handleTouchMovePan(event);
        }
        function handleTouchMoveDollyRotate(event) {
          if (scope.enableZoom)
            handleTouchMoveDolly(event);
          if (scope.enableRotate)
            handleTouchMoveRotate(event);
        }
        function onPointerDown(event) {
          if (scope.enabled === false)
            return;
          if (pointers.length === 0) {
            scope.domElement.setPointerCapture(event.pointerId);
            scope.domElement.addEventListener("pointermove", onPointerMove);
            scope.domElement.addEventListener("pointerup", onPointerUp);
          }
          addPointer(event);
          if (event.pointerType === "touch") {
            onTouchStart(event);
          } else {
            onMouseDown(event);
          }
        }
        function onPointerMove(event) {
          if (scope.enabled === false)
            return;
          if (event.pointerType === "touch") {
            onTouchMove(event);
          } else {
            onMouseMove(event);
          }
        }
        function onPointerUp(event) {
          removePointer(event);
          if (pointers.length === 0) {
            scope.domElement.releasePointerCapture(event.pointerId);
            scope.domElement.removeEventListener("pointermove", onPointerMove);
            scope.domElement.removeEventListener("pointerup", onPointerUp);
          }
          scope.dispatchEvent(_endEvent);
          state = STATE.NONE;
        }
        function onMouseDown(event) {
          let mouseAction;
          switch (event.button) {
            case 0:
              mouseAction = scope.mouseButtons.LEFT;
              break;
            case 1:
              mouseAction = scope.mouseButtons.MIDDLE;
              break;
            case 2:
              mouseAction = scope.mouseButtons.RIGHT;
              break;
            default:
              mouseAction = -1;
          }
          switch (mouseAction) {
            case MOUSE.DOLLY:
              if (scope.enableZoom === false)
                return;
              handleMouseDownDolly(event);
              state = STATE.DOLLY;
              break;
            case MOUSE.ROTATE:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enablePan === false)
                  return;
                handleMouseDownPan(event);
                state = STATE.PAN;
              } else {
                if (scope.enableRotate === false)
                  return;
                handleMouseDownRotate(event);
                state = STATE.ROTATE;
              }
              break;
            case MOUSE.PAN:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enableRotate === false)
                  return;
                handleMouseDownRotate(event);
                state = STATE.ROTATE;
              } else {
                if (scope.enablePan === false)
                  return;
                handleMouseDownPan(event);
                state = STATE.PAN;
              }
              break;
            default:
              state = STATE.NONE;
          }
          if (state !== STATE.NONE) {
            scope.dispatchEvent(_startEvent);
          }
        }
        function onMouseMove(event) {
          switch (state) {
            case STATE.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleMouseMoveRotate(event);
              break;
            case STATE.DOLLY:
              if (scope.enableZoom === false)
                return;
              handleMouseMoveDolly(event);
              break;
            case STATE.PAN:
              if (scope.enablePan === false)
                return;
              handleMouseMovePan(event);
              break;
          }
        }
        function onMouseWheel(event) {
          if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
            return;
          event.preventDefault();
          scope.dispatchEvent(_startEvent);
          handleMouseWheel(event);
          scope.dispatchEvent(_endEvent);
        }
        function onKeyDown(event) {
          if (scope.enabled === false || scope.enablePan === false)
            return;
          handleKeyDown(event);
        }
        function onTouchStart(event) {
          trackPointer(event);
          switch (pointers.length) {
            case 1:
              switch (scope.touches.ONE) {
                case TOUCH.ROTATE:
                  if (scope.enableRotate === false)
                    return;
                  handleTouchStartRotate();
                  state = STATE.TOUCH_ROTATE;
                  break;
                case TOUCH.PAN:
                  if (scope.enablePan === false)
                    return;
                  handleTouchStartPan();
                  state = STATE.TOUCH_PAN;
                  break;
                default:
                  state = STATE.NONE;
              }
              break;
            case 2:
              switch (scope.touches.TWO) {
                case TOUCH.DOLLY_PAN:
                  if (scope.enableZoom === false && scope.enablePan === false)
                    return;
                  handleTouchStartDollyPan();
                  state = STATE.TOUCH_DOLLY_PAN;
                  break;
                case TOUCH.DOLLY_ROTATE:
                  if (scope.enableZoom === false && scope.enableRotate === false)
                    return;
                  handleTouchStartDollyRotate();
                  state = STATE.TOUCH_DOLLY_ROTATE;
                  break;
                default:
                  state = STATE.NONE;
              }
              break;
            default:
              state = STATE.NONE;
          }
          if (state !== STATE.NONE) {
            scope.dispatchEvent(_startEvent);
          }
        }
        function onTouchMove(event) {
          trackPointer(event);
          switch (state) {
            case STATE.TOUCH_ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchMoveRotate(event);
              scope.update();
              break;
            case STATE.TOUCH_PAN:
              if (scope.enablePan === false)
                return;
              handleTouchMovePan(event);
              scope.update();
              break;
            case STATE.TOUCH_DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchMoveDollyPan(event);
              scope.update();
              break;
            case STATE.TOUCH_DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchMoveDollyRotate(event);
              scope.update();
              break;
            default:
              state = STATE.NONE;
          }
        }
        function onContextMenu(event) {
          if (scope.enabled === false)
            return;
          event.preventDefault();
        }
        function addPointer(event) {
          pointers.push(event);
        }
        function removePointer(event) {
          delete pointerPositions[event.pointerId];
          for (let i = 0; i < pointers.length; i++) {
            if (pointers[i].pointerId == event.pointerId) {
              pointers.splice(i, 1);
              return;
            }
          }
        }
        function trackPointer(event) {
          let position = pointerPositions[event.pointerId];
          if (position === void 0) {
            position = new Vector2();
            pointerPositions[event.pointerId] = position;
          }
          position.set(event.pageX, event.pageY);
        }
        function getSecondPointerPosition(event) {
          const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
          return pointerPositions[pointer.pointerId];
        }
        scope.domElement.addEventListener("contextmenu", onContextMenu);
        scope.domElement.addEventListener("pointerdown", onPointerDown);
        scope.domElement.addEventListener("pointercancel", onPointerUp);
        scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
        this.update();
      }
    };
  }
});

// node_modules/three/examples/jsm/loaders/OBJLoader.js
var OBJLoader_exports = {};
__export(OBJLoader_exports, {
  OBJLoader: () => OBJLoader
});
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addVertexPoint: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addVertexLine: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addNormal: function(a, b, c) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addFaceNormal: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a);
      _vB.fromArray(src, b);
      _vC.fromArray(src, c);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a, b, c) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a] !== void 0)
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      if (src[b] !== void 0)
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
      if (src[c] !== void 0)
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addUV: function(a, b, c) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    },
    addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a, vLen);
      let ib = this.parseVertexIndex(b, vLen);
      let ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
var _object_pattern, _material_library_pattern, _material_use_pattern, _map_use_pattern, _face_vertex_data_separator_pattern, _vA, _vB, _vC, _ab, _cb, _color, OBJLoader;
var init_OBJLoader = __esm({
  "node_modules/three/examples/jsm/loaders/OBJLoader.js"() {
    init_three_module();
    _object_pattern = /^[og]\s*(.+)?/;
    _material_library_pattern = /^mtllib /;
    _material_use_pattern = /^usemtl /;
    _map_use_pattern = /^usemap /;
    _face_vertex_data_separator_pattern = /\s+/;
    _vA = new Vector3();
    _vB = new Vector3();
    _vC = new Vector3();
    _ab = new Vector3();
    _cb = new Vector3();
    _color = new Color();
    OBJLoader = class extends Loader {
      constructor(manager) {
        super(manager);
        this.materials = null;
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(text));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      setMaterials(materials) {
        this.materials = materials;
        return this;
      }
      parse(text) {
        const state = new ParserState();
        if (text.indexOf("\r\n") !== -1) {
          text = text.replace(/\r\n/g, "\n");
        }
        if (text.indexOf("\\\n") !== -1) {
          text = text.replace(/\\\n/g, "");
        }
        const lines = text.split("\n");
        let result = [];
        for (let i = 0, l = lines.length; i < l; i++) {
          const line = lines[i].trimStart();
          if (line.length === 0)
            continue;
          const lineFirstChar = line.charAt(0);
          if (lineFirstChar === "#")
            continue;
          if (lineFirstChar === "v") {
            const data = line.split(_face_vertex_data_separator_pattern);
            switch (data[0]) {
              case "v":
                state.vertices.push(
                  parseFloat(data[1]),
                  parseFloat(data[2]),
                  parseFloat(data[3])
                );
                if (data.length >= 7) {
                  _color.setRGB(
                    parseFloat(data[4]),
                    parseFloat(data[5]),
                    parseFloat(data[6])
                  ).convertSRGBToLinear();
                  state.colors.push(_color.r, _color.g, _color.b);
                } else {
                  state.colors.push(void 0, void 0, void 0);
                }
                break;
              case "vn":
                state.normals.push(
                  parseFloat(data[1]),
                  parseFloat(data[2]),
                  parseFloat(data[3])
                );
                break;
              case "vt":
                state.uvs.push(
                  parseFloat(data[1]),
                  parseFloat(data[2])
                );
                break;
            }
          } else if (lineFirstChar === "f") {
            const lineData = line.slice(1).trim();
            const vertexData = lineData.split(_face_vertex_data_separator_pattern);
            const faceVertices = [];
            for (let j = 0, jl = vertexData.length; j < jl; j++) {
              const vertex = vertexData[j];
              if (vertex.length > 0) {
                const vertexParts = vertex.split("/");
                faceVertices.push(vertexParts);
              }
            }
            const v1 = faceVertices[0];
            for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
              const v2 = faceVertices[j];
              const v3 = faceVertices[j + 1];
              state.addFace(
                v1[0],
                v2[0],
                v3[0],
                v1[1],
                v2[1],
                v3[1],
                v1[2],
                v2[2],
                v3[2]
              );
            }
          } else if (lineFirstChar === "l") {
            const lineParts = line.substring(1).trim().split(" ");
            let lineVertices = [];
            const lineUVs = [];
            if (line.indexOf("/") === -1) {
              lineVertices = lineParts;
            } else {
              for (let li = 0, llen = lineParts.length; li < llen; li++) {
                const parts = lineParts[li].split("/");
                if (parts[0] !== "")
                  lineVertices.push(parts[0]);
                if (parts[1] !== "")
                  lineUVs.push(parts[1]);
              }
            }
            state.addLineGeometry(lineVertices, lineUVs);
          } else if (lineFirstChar === "p") {
            const lineData = line.slice(1).trim();
            const pointData = lineData.split(" ");
            state.addPointGeometry(pointData);
          } else if ((result = _object_pattern.exec(line)) !== null) {
            const name = (" " + result[0].slice(1).trim()).slice(1);
            state.startObject(name);
          } else if (_material_use_pattern.test(line)) {
            state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
          } else if (_material_library_pattern.test(line)) {
            state.materialLibraries.push(line.substring(7).trim());
          } else if (_map_use_pattern.test(line)) {
            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          } else if (lineFirstChar === "s") {
            result = line.split(" ");
            if (result.length > 1) {
              const value = result[1].trim().toLowerCase();
              state.object.smooth = value !== "0" && value !== "off";
            } else {
              state.object.smooth = true;
            }
            const material = state.object.currentMaterial();
            if (material)
              material.smooth = state.object.smooth;
          } else {
            if (line === "\0")
              continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
          }
        }
        state.finalize();
        const container = new Group();
        container.materialLibraries = [].concat(state.materialLibraries);
        const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
        if (hasPrimitives === true) {
          for (let i = 0, l = state.objects.length; i < l; i++) {
            const object = state.objects[i];
            const geometry = object.geometry;
            const materials = object.materials;
            const isLine = geometry.type === "Line";
            const isPoints = geometry.type === "Points";
            let hasVertexColors = false;
            if (geometry.vertices.length === 0)
              continue;
            const buffergeometry = new BufferGeometry();
            buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry.vertices, 3));
            if (geometry.normals.length > 0) {
              buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry.normals, 3));
            }
            if (geometry.colors.length > 0) {
              hasVertexColors = true;
              buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry.colors, 3));
            }
            if (geometry.hasUVIndices === true) {
              buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry.uvs, 2));
            }
            const createdMaterials = [];
            for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
              const sourceMaterial = materials[mi];
              const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
              let material = state.materials[materialHash];
              if (this.materials !== null) {
                material = this.materials.create(sourceMaterial.name);
                if (isLine && material && !(material instanceof LineBasicMaterial)) {
                  const materialLine = new LineBasicMaterial();
                  Material.prototype.copy.call(materialLine, material);
                  materialLine.color.copy(material.color);
                  material = materialLine;
                } else if (isPoints && material && !(material instanceof PointsMaterial)) {
                  const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
                  Material.prototype.copy.call(materialPoints, material);
                  materialPoints.color.copy(material.color);
                  materialPoints.map = material.map;
                  material = materialPoints;
                }
              }
              if (material === void 0) {
                if (isLine) {
                  material = new LineBasicMaterial();
                } else if (isPoints) {
                  material = new PointsMaterial({ size: 1, sizeAttenuation: false });
                } else {
                  material = new MeshPhongMaterial();
                }
                material.name = sourceMaterial.name;
                material.flatShading = sourceMaterial.smooth ? false : true;
                material.vertexColors = hasVertexColors;
                state.materials[materialHash] = material;
              }
              createdMaterials.push(material);
            }
            let mesh;
            if (createdMaterials.length > 1) {
              for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
                const sourceMaterial = materials[mi];
                buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
              }
              if (isLine) {
                mesh = new LineSegments(buffergeometry, createdMaterials);
              } else if (isPoints) {
                mesh = new Points(buffergeometry, createdMaterials);
              } else {
                mesh = new Mesh(buffergeometry, createdMaterials);
              }
            } else {
              if (isLine) {
                mesh = new LineSegments(buffergeometry, createdMaterials[0]);
              } else if (isPoints) {
                mesh = new Points(buffergeometry, createdMaterials[0]);
              } else {
                mesh = new Mesh(buffergeometry, createdMaterials[0]);
              }
            }
            mesh.name = object.name;
            container.add(mesh);
          }
        } else {
          if (state.vertices.length > 0) {
            const material = new PointsMaterial({ size: 1, sizeAttenuation: false });
            const buffergeometry = new BufferGeometry();
            buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
            if (state.colors.length > 0 && state.colors[0] !== void 0) {
              buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
              material.vertexColors = true;
            }
            const points = new Points(buffergeometry, material);
            container.add(points);
          }
        }
        return container;
      }
    };
  }
});

// node_modules/three/examples/jsm/loaders/TGALoader.js
var TGALoader;
var init_TGALoader = __esm({
  "node_modules/three/examples/jsm/loaders/TGALoader.js"() {
    init_three_module();
    TGALoader = class extends DataTextureLoader {
      constructor(manager) {
        super(manager);
      }
      parse(buffer) {
        function tgaCheckHeader(header2) {
          switch (header2.image_type) {
            case TGA_TYPE_INDEXED:
            case TGA_TYPE_RLE_INDEXED:
              if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {
                console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
              }
              break;
            case TGA_TYPE_RGB:
            case TGA_TYPE_GREY:
            case TGA_TYPE_RLE_RGB:
            case TGA_TYPE_RLE_GREY:
              if (header2.colormap_type) {
                console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
              }
              break;
            case TGA_TYPE_NO_DATA:
              console.error("THREE.TGALoader: No data.");
            default:
              console.error('THREE.TGALoader: Invalid type "%s".', header2.image_type);
          }
          if (header2.width <= 0 || header2.height <= 0) {
            console.error("THREE.TGALoader: Invalid image size.");
          }
          if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {
            console.error('THREE.TGALoader: Invalid pixel size "%s".', header2.pixel_size);
          }
        }
        function tgaParse(use_rle2, use_pal2, header2, offset2, data) {
          let pixel_data, palettes;
          const pixel_size = header2.pixel_size >> 3;
          const pixel_total = header2.width * header2.height * pixel_size;
          if (use_pal2) {
            palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));
          }
          if (use_rle2) {
            pixel_data = new Uint8Array(pixel_total);
            let c, count, i;
            let shift = 0;
            const pixels = new Uint8Array(pixel_size);
            while (shift < pixel_total) {
              c = data[offset2++];
              count = (c & 127) + 1;
              if (c & 128) {
                for (i = 0; i < pixel_size; ++i) {
                  pixels[i] = data[offset2++];
                }
                for (i = 0; i < count; ++i) {
                  pixel_data.set(pixels, shift + i * pixel_size);
                }
                shift += pixel_size * count;
              } else {
                count *= pixel_size;
                for (i = 0; i < count; ++i) {
                  pixel_data[shift + i] = data[offset2++];
                }
                shift += count;
              }
            }
          } else {
            pixel_data = data.subarray(
              offset2,
              offset2 += use_pal2 ? header2.width * header2.height : pixel_total
            );
          }
          return {
            pixel_data,
            palettes
          };
        }
        function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
          const colormap = palettes;
          let color, i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
              color = image[i];
              imageData2[(x + width * y) * 4 + 3] = 255;
              imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
              imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
              imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
            }
          }
          return imageData2;
        }
        function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          let color, i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
              color = image[i + 0] + (image[i + 1] << 8);
              imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;
              imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;
              imageData2[(x + width * y) * 4 + 2] = (color & 31) << 3;
              imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;
            }
          }
          return imageData2;
        }
        function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          let i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 3) {
              imageData2[(x + width * y) * 4 + 3] = 255;
              imageData2[(x + width * y) * 4 + 2] = image[i + 0];
              imageData2[(x + width * y) * 4 + 1] = image[i + 1];
              imageData2[(x + width * y) * 4 + 0] = image[i + 2];
            }
          }
          return imageData2;
        }
        function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          let i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 4) {
              imageData2[(x + width * y) * 4 + 2] = image[i + 0];
              imageData2[(x + width * y) * 4 + 1] = image[i + 1];
              imageData2[(x + width * y) * 4 + 0] = image[i + 2];
              imageData2[(x + width * y) * 4 + 3] = image[i + 3];
            }
          }
          return imageData2;
        }
        function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          let color, i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
              color = image[i];
              imageData2[(x + width * y) * 4 + 0] = color;
              imageData2[(x + width * y) * 4 + 1] = color;
              imageData2[(x + width * y) * 4 + 2] = color;
              imageData2[(x + width * y) * 4 + 3] = 255;
            }
          }
          return imageData2;
        }
        function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          let i = 0, x, y;
          const width = header.width;
          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
              imageData2[(x + width * y) * 4 + 0] = image[i + 0];
              imageData2[(x + width * y) * 4 + 1] = image[i + 0];
              imageData2[(x + width * y) * 4 + 2] = image[i + 0];
              imageData2[(x + width * y) * 4 + 3] = image[i + 1];
            }
          }
          return imageData2;
        }
        function getTgaRGBA(data, width, height, image, palette) {
          let x_start, y_start, x_step, y_step, x_end, y_end;
          switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
            default:
            case TGA_ORIGIN_UL:
              x_start = 0;
              x_step = 1;
              x_end = width;
              y_start = 0;
              y_step = 1;
              y_end = height;
              break;
            case TGA_ORIGIN_BL:
              x_start = 0;
              x_step = 1;
              x_end = width;
              y_start = height - 1;
              y_step = -1;
              y_end = -1;
              break;
            case TGA_ORIGIN_UR:
              x_start = width - 1;
              x_step = -1;
              x_end = -1;
              y_start = 0;
              y_step = 1;
              y_end = height;
              break;
            case TGA_ORIGIN_BR:
              x_start = width - 1;
              x_step = -1;
              x_end = -1;
              y_start = height - 1;
              y_step = -1;
              y_end = -1;
              break;
          }
          if (use_grey) {
            switch (header.pixel_size) {
              case 8:
                tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;
              case 16:
                tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;
              default:
                console.error("THREE.TGALoader: Format not supported.");
                break;
            }
          } else {
            switch (header.pixel_size) {
              case 8:
                tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
                break;
              case 16:
                tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;
              case 24:
                tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;
              case 32:
                tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;
              default:
                console.error("THREE.TGALoader: Format not supported.");
                break;
            }
          }
          return data;
        }
        const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 48, TGA_ORIGIN_SHIFT = 4, TGA_ORIGIN_BL = 0, TGA_ORIGIN_BR = 1, TGA_ORIGIN_UL = 2, TGA_ORIGIN_UR = 3;
        if (buffer.length < 19)
          console.error("THREE.TGALoader: Not enough data to contain header.");
        let offset = 0;
        const content = new Uint8Array(buffer), header = {
          id_length: content[offset++],
          colormap_type: content[offset++],
          image_type: content[offset++],
          colormap_index: content[offset++] | content[offset++] << 8,
          colormap_length: content[offset++] | content[offset++] << 8,
          colormap_size: content[offset++],
          origin: [
            content[offset++] | content[offset++] << 8,
            content[offset++] | content[offset++] << 8
          ],
          width: content[offset++] | content[offset++] << 8,
          height: content[offset++] | content[offset++] << 8,
          pixel_size: content[offset++],
          flags: content[offset++]
        };
        tgaCheckHeader(header);
        if (header.id_length + offset > buffer.length) {
          console.error("THREE.TGALoader: No data.");
        }
        offset += header.id_length;
        let use_rle = false, use_pal = false, use_grey = false;
        switch (header.image_type) {
          case TGA_TYPE_RLE_INDEXED:
            use_rle = true;
            use_pal = true;
            break;
          case TGA_TYPE_INDEXED:
            use_pal = true;
            break;
          case TGA_TYPE_RLE_RGB:
            use_rle = true;
            break;
          case TGA_TYPE_RGB:
            break;
          case TGA_TYPE_RLE_GREY:
            use_rle = true;
            use_grey = true;
            break;
          case TGA_TYPE_GREY:
            use_grey = true;
            break;
        }
        const imageData = new Uint8Array(header.width * header.height * 4);
        const result = tgaParse(use_rle, use_pal, header, offset, content);
        getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);
        return {
          data: imageData,
          width: header.width,
          height: header.height,
          flipY: true,
          generateMipmaps: true,
          minFilter: LinearMipmapLinearFilter
        };
      }
    };
  }
});

// node_modules/three/examples/jsm/loaders/ColladaLoader.js
var ColladaLoader_exports = {};
__export(ColladaLoader_exports, {
  ColladaLoader: () => ColladaLoader
});
var ColladaLoader;
var init_ColladaLoader = __esm({
  "node_modules/three/examples/jsm/loaders/ColladaLoader.js"() {
    init_three_module();
    init_TGALoader();
    ColladaLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(text, path));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(text, path) {
        function getElementsByTagName(xml2, name) {
          const array = [];
          const childNodes = xml2.childNodes;
          for (let i = 0, l = childNodes.length; i < l; i++) {
            const child = childNodes[i];
            if (child.nodeName === name) {
              array.push(child);
            }
          }
          return array;
        }
        function parseStrings(text2) {
          if (text2.length === 0)
            return [];
          const parts = text2.trim().split(/\s+/);
          const array = new Array(parts.length);
          for (let i = 0, l = parts.length; i < l; i++) {
            array[i] = parts[i];
          }
          return array;
        }
        function parseFloats(text2) {
          if (text2.length === 0)
            return [];
          const parts = text2.trim().split(/\s+/);
          const array = new Array(parts.length);
          for (let i = 0, l = parts.length; i < l; i++) {
            array[i] = parseFloat(parts[i]);
          }
          return array;
        }
        function parseInts(text2) {
          if (text2.length === 0)
            return [];
          const parts = text2.trim().split(/\s+/);
          const array = new Array(parts.length);
          for (let i = 0, l = parts.length; i < l; i++) {
            array[i] = parseInt(parts[i]);
          }
          return array;
        }
        function parseId(text2) {
          return text2.substring(1);
        }
        function generateId() {
          return "three_default_" + count++;
        }
        function isEmpty(object) {
          return Object.keys(object).length === 0;
        }
        function parseAsset(xml2) {
          return {
            unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
            upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
          };
        }
        function parseAssetUnit(xml2) {
          if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
            return parseFloat(xml2.getAttribute("meter"));
          } else {
            return 1;
          }
        }
        function parseAssetUpAxis(xml2) {
          return xml2 !== void 0 ? xml2.textContent : "Y_UP";
        }
        function parseLibrary(xml2, libraryName, nodeName, parser) {
          const library2 = getElementsByTagName(xml2, libraryName)[0];
          if (library2 !== void 0) {
            const elements = getElementsByTagName(library2, nodeName);
            for (let i = 0; i < elements.length; i++) {
              parser(elements[i]);
            }
          }
        }
        function buildLibrary(data, builder) {
          for (const name in data) {
            const object = data[name];
            object.build = builder(data[name]);
          }
        }
        function getBuild(data, builder) {
          if (data.build !== void 0)
            return data.build;
          data.build = builder(data);
          return data.build;
        }
        function parseAnimation(xml2) {
          const data = {
            sources: {},
            samplers: {},
            channels: {}
          };
          let hasChildren = false;
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            let id;
            switch (child.nodeName) {
              case "source":
                id = child.getAttribute("id");
                data.sources[id] = parseSource(child);
                break;
              case "sampler":
                id = child.getAttribute("id");
                data.samplers[id] = parseAnimationSampler(child);
                break;
              case "channel":
                id = child.getAttribute("target");
                data.channels[id] = parseAnimationChannel(child);
                break;
              case "animation":
                parseAnimation(child);
                hasChildren = true;
                break;
              default:
                console.log(child);
            }
          }
          if (hasChildren === false) {
            library.animations[xml2.getAttribute("id") || MathUtils.generateUUID()] = data;
          }
        }
        function parseAnimationSampler(xml2) {
          const data = {
            inputs: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "input":
                const id = parseId(child.getAttribute("source"));
                const semantic = child.getAttribute("semantic");
                data.inputs[semantic] = id;
                break;
            }
          }
          return data;
        }
        function parseAnimationChannel(xml2) {
          const data = {};
          const target = xml2.getAttribute("target");
          let parts = target.split("/");
          const id = parts.shift();
          let sid = parts.shift();
          const arraySyntax = sid.indexOf("(") !== -1;
          const memberSyntax = sid.indexOf(".") !== -1;
          if (memberSyntax) {
            parts = sid.split(".");
            sid = parts.shift();
            data.member = parts.shift();
          } else if (arraySyntax) {
            const indices = sid.split("(");
            sid = indices.shift();
            for (let i = 0; i < indices.length; i++) {
              indices[i] = parseInt(indices[i].replace(/\)/, ""));
            }
            data.indices = indices;
          }
          data.id = id;
          data.sid = sid;
          data.arraySyntax = arraySyntax;
          data.memberSyntax = memberSyntax;
          data.sampler = parseId(xml2.getAttribute("source"));
          return data;
        }
        function buildAnimation(data) {
          const tracks = [];
          const channels = data.channels;
          const samplers = data.samplers;
          const sources = data.sources;
          for (const target in channels) {
            if (channels.hasOwnProperty(target)) {
              const channel = channels[target];
              const sampler = samplers[channel.sampler];
              const inputId = sampler.inputs.INPUT;
              const outputId = sampler.inputs.OUTPUT;
              const inputSource = sources[inputId];
              const outputSource = sources[outputId];
              const animation = buildAnimationChannel(channel, inputSource, outputSource);
              createKeyframeTracks(animation, tracks);
            }
          }
          return tracks;
        }
        function getAnimation(id) {
          return getBuild(library.animations[id], buildAnimation);
        }
        function buildAnimationChannel(channel, inputSource, outputSource) {
          const node = library.nodes[channel.id];
          const object3D = getNode(node.id);
          const transform = node.transforms[channel.sid];
          const defaultMatrix = node.matrix.clone().transpose();
          let time, stride;
          let i, il, j, jl;
          const data = {};
          switch (transform) {
            case "matrix":
              for (i = 0, il = inputSource.array.length; i < il; i++) {
                time = inputSource.array[i];
                stride = i * outputSource.stride;
                if (data[time] === void 0)
                  data[time] = {};
                if (channel.arraySyntax === true) {
                  const value = outputSource.array[stride];
                  const index = channel.indices[0] + 4 * channel.indices[1];
                  data[time][index] = value;
                } else {
                  for (j = 0, jl = outputSource.stride; j < jl; j++) {
                    data[time][j] = outputSource.array[stride + j];
                  }
                }
              }
              break;
            case "translate":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
            case "rotate":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
            case "scale":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
          }
          const keyframes = prepareAnimationData(data, defaultMatrix);
          const animation = {
            name: object3D.uuid,
            keyframes
          };
          return animation;
        }
        function prepareAnimationData(data, defaultMatrix) {
          const keyframes = [];
          for (const time in data) {
            keyframes.push({ time: parseFloat(time), value: data[time] });
          }
          keyframes.sort(ascending);
          for (let i = 0; i < 16; i++) {
            transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
          }
          return keyframes;
          function ascending(a, b) {
            return a.time - b.time;
          }
        }
        const position = new Vector3();
        const scale = new Vector3();
        const quaternion = new Quaternion();
        function createKeyframeTracks(animation, tracks) {
          const keyframes = animation.keyframes;
          const name = animation.name;
          const times = [];
          const positionData = [];
          const quaternionData = [];
          const scaleData = [];
          for (let i = 0, l = keyframes.length; i < l; i++) {
            const keyframe = keyframes[i];
            const time = keyframe.time;
            const value = keyframe.value;
            matrix.fromArray(value).transpose();
            matrix.decompose(position, quaternion, scale);
            times.push(time);
            positionData.push(position.x, position.y, position.z);
            quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
            scaleData.push(scale.x, scale.y, scale.z);
          }
          if (positionData.length > 0)
            tracks.push(new VectorKeyframeTrack(name + ".position", times, positionData));
          if (quaternionData.length > 0)
            tracks.push(new QuaternionKeyframeTrack(name + ".quaternion", times, quaternionData));
          if (scaleData.length > 0)
            tracks.push(new VectorKeyframeTrack(name + ".scale", times, scaleData));
          return tracks;
        }
        function transformAnimationData(keyframes, property, defaultValue) {
          let keyframe;
          let empty = true;
          let i, l;
          for (i = 0, l = keyframes.length; i < l; i++) {
            keyframe = keyframes[i];
            if (keyframe.value[property] === void 0) {
              keyframe.value[property] = null;
            } else {
              empty = false;
            }
          }
          if (empty === true) {
            for (i = 0, l = keyframes.length; i < l; i++) {
              keyframe = keyframes[i];
              keyframe.value[property] = defaultValue;
            }
          } else {
            createMissingKeyframes(keyframes, property);
          }
        }
        function createMissingKeyframes(keyframes, property) {
          let prev, next;
          for (let i = 0, l = keyframes.length; i < l; i++) {
            const keyframe = keyframes[i];
            if (keyframe.value[property] === null) {
              prev = getPrev(keyframes, i, property);
              next = getNext(keyframes, i, property);
              if (prev === null) {
                keyframe.value[property] = next.value[property];
                continue;
              }
              if (next === null) {
                keyframe.value[property] = prev.value[property];
                continue;
              }
              interpolate(keyframe, prev, next, property);
            }
          }
        }
        function getPrev(keyframes, i, property) {
          while (i >= 0) {
            const keyframe = keyframes[i];
            if (keyframe.value[property] !== null)
              return keyframe;
            i--;
          }
          return null;
        }
        function getNext(keyframes, i, property) {
          while (i < keyframes.length) {
            const keyframe = keyframes[i];
            if (keyframe.value[property] !== null)
              return keyframe;
            i++;
          }
          return null;
        }
        function interpolate(key, prev, next, property) {
          if (next.time - prev.time === 0) {
            key.value[property] = prev.value[property];
            return;
          }
          key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
        }
        function parseAnimationClip(xml2) {
          const data = {
            name: xml2.getAttribute("id") || "default",
            start: parseFloat(xml2.getAttribute("start") || 0),
            end: parseFloat(xml2.getAttribute("end") || 0),
            animations: []
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "instance_animation":
                data.animations.push(parseId(child.getAttribute("url")));
                break;
            }
          }
          library.clips[xml2.getAttribute("id")] = data;
        }
        function buildAnimationClip(data) {
          const tracks = [];
          const name = data.name;
          const duration = data.end - data.start || -1;
          const animations2 = data.animations;
          for (let i = 0, il = animations2.length; i < il; i++) {
            const animationTracks = getAnimation(animations2[i]);
            for (let j = 0, jl = animationTracks.length; j < jl; j++) {
              tracks.push(animationTracks[j]);
            }
          }
          return new AnimationClip(name, duration, tracks);
        }
        function getAnimationClip(id) {
          return getBuild(library.clips[id], buildAnimationClip);
        }
        function parseController(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "skin":
                data.id = parseId(child.getAttribute("source"));
                data.skin = parseSkin(child);
                break;
              case "morph":
                data.id = parseId(child.getAttribute("source"));
                console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                break;
            }
          }
          library.controllers[xml2.getAttribute("id")] = data;
        }
        function parseSkin(xml2) {
          const data = {
            sources: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "bind_shape_matrix":
                data.bindShapeMatrix = parseFloats(child.textContent);
                break;
              case "source":
                const id = child.getAttribute("id");
                data.sources[id] = parseSource(child);
                break;
              case "joints":
                data.joints = parseJoints(child);
                break;
              case "vertex_weights":
                data.vertexWeights = parseVertexWeights(child);
                break;
            }
          }
          return data;
        }
        function parseJoints(xml2) {
          const data = {
            inputs: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "input":
                const semantic = child.getAttribute("semantic");
                const id = parseId(child.getAttribute("source"));
                data.inputs[semantic] = id;
                break;
            }
          }
          return data;
        }
        function parseVertexWeights(xml2) {
          const data = {
            inputs: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "input":
                const semantic = child.getAttribute("semantic");
                const id = parseId(child.getAttribute("source"));
                const offset = parseInt(child.getAttribute("offset"));
                data.inputs[semantic] = { id, offset };
                break;
              case "vcount":
                data.vcount = parseInts(child.textContent);
                break;
              case "v":
                data.v = parseInts(child.textContent);
                break;
            }
          }
          return data;
        }
        function buildController(data) {
          const build = {
            id: data.id
          };
          const geometry = library.geometries[build.id];
          if (data.skin !== void 0) {
            build.skin = buildSkin(data.skin);
            geometry.sources.skinIndices = build.skin.indices;
            geometry.sources.skinWeights = build.skin.weights;
          }
          return build;
        }
        function buildSkin(data) {
          const BONE_LIMIT = 4;
          const build = {
            joints: [],
            // this must be an array to preserve the joint order
            indices: {
              array: [],
              stride: BONE_LIMIT
            },
            weights: {
              array: [],
              stride: BONE_LIMIT
            }
          };
          const sources = data.sources;
          const vertexWeights = data.vertexWeights;
          const vcount = vertexWeights.vcount;
          const v = vertexWeights.v;
          const jointOffset = vertexWeights.inputs.JOINT.offset;
          const weightOffset = vertexWeights.inputs.WEIGHT.offset;
          const jointSource = data.sources[data.joints.inputs.JOINT];
          const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
          const weights = sources[vertexWeights.inputs.WEIGHT.id].array;
          let stride = 0;
          let i, j, l;
          for (i = 0, l = vcount.length; i < l; i++) {
            const jointCount = vcount[i];
            const vertexSkinData = [];
            for (j = 0; j < jointCount; j++) {
              const skinIndex = v[stride + jointOffset];
              const weightId = v[stride + weightOffset];
              const skinWeight = weights[weightId];
              vertexSkinData.push({ index: skinIndex, weight: skinWeight });
              stride += 2;
            }
            vertexSkinData.sort(descending);
            for (j = 0; j < BONE_LIMIT; j++) {
              const d = vertexSkinData[j];
              if (d !== void 0) {
                build.indices.array.push(d.index);
                build.weights.array.push(d.weight);
              } else {
                build.indices.array.push(0);
                build.weights.array.push(0);
              }
            }
          }
          if (data.bindShapeMatrix) {
            build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();
          } else {
            build.bindMatrix = new Matrix4().identity();
          }
          for (i = 0, l = jointSource.array.length; i < l; i++) {
            const name = jointSource.array[i];
            const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();
            build.joints.push({ name, boneInverse });
          }
          return build;
          function descending(a, b) {
            return b.weight - a.weight;
          }
        }
        function getController(id) {
          return getBuild(library.controllers[id], buildController);
        }
        function parseImage(xml2) {
          const data = {
            init_from: getElementsByTagName(xml2, "init_from")[0].textContent
          };
          library.images[xml2.getAttribute("id")] = data;
        }
        function buildImage(data) {
          if (data.build !== void 0)
            return data.build;
          return data.init_from;
        }
        function getImage(id) {
          const data = library.images[id];
          if (data !== void 0) {
            return getBuild(data, buildImage);
          }
          console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
          return null;
        }
        function parseEffect(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "profile_COMMON":
                data.profile = parseEffectProfileCOMMON(child);
                break;
            }
          }
          library.effects[xml2.getAttribute("id")] = data;
        }
        function parseEffectProfileCOMMON(xml2) {
          const data = {
            surfaces: {},
            samplers: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "newparam":
                parseEffectNewparam(child, data);
                break;
              case "technique":
                data.technique = parseEffectTechnique(child);
                break;
              case "extra":
                data.extra = parseEffectExtra(child);
                break;
            }
          }
          return data;
        }
        function parseEffectNewparam(xml2, data) {
          const sid = xml2.getAttribute("sid");
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "surface":
                data.surfaces[sid] = parseEffectSurface(child);
                break;
              case "sampler2D":
                data.samplers[sid] = parseEffectSampler(child);
                break;
            }
          }
        }
        function parseEffectSurface(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "init_from":
                data.init_from = child.textContent;
                break;
            }
          }
          return data;
        }
        function parseEffectSampler(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "source":
                data.source = child.textContent;
                break;
            }
          }
          return data;
        }
        function parseEffectTechnique(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "constant":
              case "lambert":
              case "blinn":
              case "phong":
                data.type = child.nodeName;
                data.parameters = parseEffectParameters(child);
                break;
              case "extra":
                data.extra = parseEffectExtra(child);
                break;
            }
          }
          return data;
        }
        function parseEffectParameters(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "emission":
              case "diffuse":
              case "specular":
              case "bump":
              case "ambient":
              case "shininess":
              case "transparency":
                data[child.nodeName] = parseEffectParameter(child);
                break;
              case "transparent":
                data[child.nodeName] = {
                  opaque: child.hasAttribute("opaque") ? child.getAttribute("opaque") : "A_ONE",
                  data: parseEffectParameter(child)
                };
                break;
            }
          }
          return data;
        }
        function parseEffectParameter(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "color":
                data[child.nodeName] = parseFloats(child.textContent);
                break;
              case "float":
                data[child.nodeName] = parseFloat(child.textContent);
                break;
              case "texture":
                data[child.nodeName] = { id: child.getAttribute("texture"), extra: parseEffectParameterTexture(child) };
                break;
            }
          }
          return data;
        }
        function parseEffectParameterTexture(xml2) {
          const data = {
            technique: {}
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "extra":
                parseEffectParameterTextureExtra(child, data);
                break;
            }
          }
          return data;
        }
        function parseEffectParameterTextureExtra(xml2, data) {
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "technique":
                parseEffectParameterTextureExtraTechnique(child, data);
                break;
            }
          }
        }
        function parseEffectParameterTextureExtraTechnique(xml2, data) {
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "repeatU":
              case "repeatV":
              case "offsetU":
              case "offsetV":
                data.technique[child.nodeName] = parseFloat(child.textContent);
                break;
              case "wrapU":
              case "wrapV":
                if (child.textContent.toUpperCase() === "TRUE") {
                  data.technique[child.nodeName] = 1;
                } else if (child.textContent.toUpperCase() === "FALSE") {
                  data.technique[child.nodeName] = 0;
                } else {
                  data.technique[child.nodeName] = parseInt(child.textContent);
                }
                break;
              case "bump":
                data[child.nodeName] = parseEffectExtraTechniqueBump(child);
                break;
            }
          }
        }
        function parseEffectExtra(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "technique":
                data.technique = parseEffectExtraTechnique(child);
                break;
            }
          }
          return data;
        }
        function parseEffectExtraTechnique(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "double_sided":
                data[child.nodeName] = parseInt(child.textContent);
                break;
              case "bump":
                data[child.nodeName] = parseEffectExtraTechniqueBump(child);
                break;
            }
          }
          return data;
        }
        function parseEffectExtraTechniqueBump(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "texture":
                data[child.nodeName] = { id: child.getAttribute("texture"), texcoord: child.getAttribute("texcoord"), extra: parseEffectParameterTexture(child) };
                break;
            }
          }
          return data;
        }
        function buildEffect(data) {
          return data;
        }
        function getEffect(id) {
          return getBuild(library.effects[id], buildEffect);
        }
        function parseMaterial(xml2) {
          const data = {
            name: xml2.getAttribute("name")
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "instance_effect":
                data.url = parseId(child.getAttribute("url"));
                break;
            }
          }
          library.materials[xml2.getAttribute("id")] = data;
        }
        function getTextureLoader(image) {
          let loader;
          let extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
          extension = extension.toLowerCase();
          switch (extension) {
            case "tga":
              loader = tgaLoader;
              break;
            default:
              loader = textureLoader;
          }
          return loader;
        }
        function buildMaterial(data) {
          const effect = getEffect(data.url);
          const technique = effect.profile.technique;
          let material;
          switch (technique.type) {
            case "phong":
            case "blinn":
              material = new MeshPhongMaterial();
              break;
            case "lambert":
              material = new MeshLambertMaterial();
              break;
            default:
              material = new MeshBasicMaterial();
              break;
          }
          material.name = data.name || "";
          function getTexture(textureObject, encoding = null) {
            const sampler = effect.profile.samplers[textureObject.id];
            let image = null;
            if (sampler !== void 0) {
              const surface = effect.profile.surfaces[sampler.source];
              image = getImage(surface.init_from);
            } else {
              console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
              image = getImage(textureObject.id);
            }
            if (image !== null) {
              const loader = getTextureLoader(image);
              if (loader !== void 0) {
                const texture = loader.load(image);
                const extra = textureObject.extra;
                if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {
                  const technique2 = extra.technique;
                  texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;
                  texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;
                  texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
                  texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
                } else {
                  texture.wrapS = RepeatWrapping;
                  texture.wrapT = RepeatWrapping;
                }
                if (encoding !== null) {
                  texture.encoding = encoding;
                }
                return texture;
              } else {
                console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
                return null;
              }
            } else {
              console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
              return null;
            }
          }
          const parameters = technique.parameters;
          for (const key in parameters) {
            const parameter = parameters[key];
            switch (key) {
              case "diffuse":
                if (parameter.color)
                  material.color.fromArray(parameter.color);
                if (parameter.texture)
                  material.map = getTexture(parameter.texture, sRGBEncoding);
                break;
              case "specular":
                if (parameter.color && material.specular)
                  material.specular.fromArray(parameter.color);
                if (parameter.texture)
                  material.specularMap = getTexture(parameter.texture);
                break;
              case "bump":
                if (parameter.texture)
                  material.normalMap = getTexture(parameter.texture);
                break;
              case "ambient":
                if (parameter.texture)
                  material.lightMap = getTexture(parameter.texture, sRGBEncoding);
                break;
              case "shininess":
                if (parameter.float && material.shininess)
                  material.shininess = parameter.float;
                break;
              case "emission":
                if (parameter.color && material.emissive)
                  material.emissive.fromArray(parameter.color);
                if (parameter.texture)
                  material.emissiveMap = getTexture(parameter.texture, sRGBEncoding);
                break;
            }
          }
          material.color.convertSRGBToLinear();
          if (material.specular)
            material.specular.convertSRGBToLinear();
          if (material.emissive)
            material.emissive.convertSRGBToLinear();
          let transparent = parameters["transparent"];
          let transparency = parameters["transparency"];
          if (transparency === void 0 && transparent) {
            transparency = {
              float: 1
            };
          }
          if (transparent === void 0 && transparency) {
            transparent = {
              opaque: "A_ONE",
              data: {
                color: [1, 1, 1, 1]
              }
            };
          }
          if (transparent && transparency) {
            if (transparent.data.texture) {
              material.transparent = true;
            } else {
              const color = transparent.data.color;
              switch (transparent.opaque) {
                case "A_ONE":
                  material.opacity = color[3] * transparency.float;
                  break;
                case "RGB_ZERO":
                  material.opacity = 1 - color[0] * transparency.float;
                  break;
                case "A_ZERO":
                  material.opacity = 1 - color[3] * transparency.float;
                  break;
                case "RGB_ONE":
                  material.opacity = color[0] * transparency.float;
                  break;
                default:
                  console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
              }
              if (material.opacity < 1)
                material.transparent = true;
            }
          }
          if (technique.extra !== void 0 && technique.extra.technique !== void 0) {
            const techniques = technique.extra.technique;
            for (const k in techniques) {
              const v = techniques[k];
              switch (k) {
                case "double_sided":
                  material.side = v === 1 ? DoubleSide : FrontSide;
                  break;
                case "bump":
                  material.normalMap = getTexture(v.texture);
                  material.normalScale = new Vector2(1, 1);
                  break;
              }
            }
          }
          return material;
        }
        function getMaterial(id) {
          return getBuild(library.materials[id], buildMaterial);
        }
        function parseCamera(xml2) {
          const data = {
            name: xml2.getAttribute("name")
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "optics":
                data.optics = parseCameraOptics(child);
                break;
            }
          }
          library.cameras[xml2.getAttribute("id")] = data;
        }
        function parseCameraOptics(xml2) {
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "technique_common":
                return parseCameraTechnique(child);
            }
          }
          return {};
        }
        function parseCameraTechnique(xml2) {
          const data = {};
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "perspective":
              case "orthographic":
                data.technique = child.nodeName;
                data.parameters = parseCameraParameters(child);
                break;
            }
          }
          return data;
        }
        function parseCameraParameters(xml2) {
          const data = {};
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "xfov":
              case "yfov":
              case "xmag":
              case "ymag":
              case "znear":
              case "zfar":
              case "aspect_ratio":
                data[child.nodeName] = parseFloat(child.textContent);
                break;
            }
          }
          return data;
        }
        function buildCamera(data) {
          let camera;
          switch (data.optics.technique) {
            case "perspective":
              camera = new PerspectiveCamera(
                data.optics.parameters.yfov,
                data.optics.parameters.aspect_ratio,
                data.optics.parameters.znear,
                data.optics.parameters.zfar
              );
              break;
            case "orthographic":
              let ymag = data.optics.parameters.ymag;
              let xmag = data.optics.parameters.xmag;
              const aspectRatio = data.optics.parameters.aspect_ratio;
              xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
              ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
              xmag *= 0.5;
              ymag *= 0.5;
              camera = new OrthographicCamera(
                -xmag,
                xmag,
                ymag,
                -ymag,
                // left, right, top, bottom
                data.optics.parameters.znear,
                data.optics.parameters.zfar
              );
              break;
            default:
              camera = new PerspectiveCamera();
              break;
          }
          camera.name = data.name || "";
          return camera;
        }
        function getCamera(id) {
          const data = library.cameras[id];
          if (data !== void 0) {
            return getBuild(data, buildCamera);
          }
          console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
          return null;
        }
        function parseLight(xml2) {
          let data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "technique_common":
                data = parseLightTechnique(child);
                break;
            }
          }
          library.lights[xml2.getAttribute("id")] = data;
        }
        function parseLightTechnique(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "directional":
              case "point":
              case "spot":
              case "ambient":
                data.technique = child.nodeName;
                data.parameters = parseLightParameters(child);
            }
          }
          return data;
        }
        function parseLightParameters(xml2) {
          const data = {};
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "color":
                const array = parseFloats(child.textContent);
                data.color = new Color().fromArray(array).convertSRGBToLinear();
                break;
              case "falloff_angle":
                data.falloffAngle = parseFloat(child.textContent);
                break;
              case "quadratic_attenuation":
                const f = parseFloat(child.textContent);
                data.distance = f ? Math.sqrt(1 / f) : 0;
                break;
            }
          }
          return data;
        }
        function buildLight(data) {
          let light;
          switch (data.technique) {
            case "directional":
              light = new DirectionalLight();
              break;
            case "point":
              light = new PointLight();
              break;
            case "spot":
              light = new SpotLight();
              break;
            case "ambient":
              light = new AmbientLight();
              break;
          }
          if (data.parameters.color)
            light.color.copy(data.parameters.color);
          if (data.parameters.distance)
            light.distance = data.parameters.distance;
          return light;
        }
        function getLight(id) {
          const data = library.lights[id];
          if (data !== void 0) {
            return getBuild(data, buildLight);
          }
          console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
          return null;
        }
        function parseGeometry(xml2) {
          const data = {
            name: xml2.getAttribute("name"),
            sources: {},
            vertices: {},
            primitives: []
          };
          const mesh = getElementsByTagName(xml2, "mesh")[0];
          if (mesh === void 0)
            return;
          for (let i = 0; i < mesh.childNodes.length; i++) {
            const child = mesh.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            const id = child.getAttribute("id");
            switch (child.nodeName) {
              case "source":
                data.sources[id] = parseSource(child);
                break;
              case "vertices":
                data.vertices = parseGeometryVertices(child);
                break;
              case "polygons":
                console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
                break;
              case "lines":
              case "linestrips":
              case "polylist":
              case "triangles":
                data.primitives.push(parseGeometryPrimitive(child));
                break;
              default:
                console.log(child);
            }
          }
          library.geometries[xml2.getAttribute("id")] = data;
        }
        function parseSource(xml2) {
          const data = {
            array: [],
            stride: 3
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "float_array":
                data.array = parseFloats(child.textContent);
                break;
              case "Name_array":
                data.array = parseStrings(child.textContent);
                break;
              case "technique_common":
                const accessor = getElementsByTagName(child, "accessor")[0];
                if (accessor !== void 0) {
                  data.stride = parseInt(accessor.getAttribute("stride"));
                }
                break;
            }
          }
          return data;
        }
        function parseGeometryVertices(xml2) {
          const data = {};
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
          }
          return data;
        }
        function parseGeometryPrimitive(xml2) {
          const primitive = {
            type: xml2.nodeName,
            material: xml2.getAttribute("material"),
            count: parseInt(xml2.getAttribute("count")),
            inputs: {},
            stride: 0,
            hasUV: false
          };
          for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "input":
                const id = parseId(child.getAttribute("source"));
                const semantic = child.getAttribute("semantic");
                const offset = parseInt(child.getAttribute("offset"));
                const set = parseInt(child.getAttribute("set"));
                const inputname = set > 0 ? semantic + set : semantic;
                primitive.inputs[inputname] = { id, offset };
                primitive.stride = Math.max(primitive.stride, offset + 1);
                if (semantic === "TEXCOORD")
                  primitive.hasUV = true;
                break;
              case "vcount":
                primitive.vcount = parseInts(child.textContent);
                break;
              case "p":
                primitive.p = parseInts(child.textContent);
                break;
            }
          }
          return primitive;
        }
        function groupPrimitives(primitives) {
          const build = {};
          for (let i = 0; i < primitives.length; i++) {
            const primitive = primitives[i];
            if (build[primitive.type] === void 0)
              build[primitive.type] = [];
            build[primitive.type].push(primitive);
          }
          return build;
        }
        function checkUVCoordinates(primitives) {
          let count2 = 0;
          for (let i = 0, l = primitives.length; i < l; i++) {
            const primitive = primitives[i];
            if (primitive.hasUV === true) {
              count2++;
            }
          }
          if (count2 > 0 && count2 < primitives.length) {
            primitives.uvsNeedsFix = true;
          }
        }
        function buildGeometry(data) {
          const build = {};
          const sources = data.sources;
          const vertices = data.vertices;
          const primitives = data.primitives;
          if (primitives.length === 0)
            return {};
          const groupedPrimitives = groupPrimitives(primitives);
          for (const type in groupedPrimitives) {
            const primitiveType = groupedPrimitives[type];
            checkUVCoordinates(primitiveType);
            build[type] = buildGeometryType(primitiveType, sources, vertices);
          }
          return build;
        }
        function buildGeometryType(primitives, sources, vertices) {
          const build = {};
          const position2 = { array: [], stride: 0 };
          const normal = { array: [], stride: 0 };
          const uv = { array: [], stride: 0 };
          const uv2 = { array: [], stride: 0 };
          const color = { array: [], stride: 0 };
          const skinIndex = { array: [], stride: 4 };
          const skinWeight = { array: [], stride: 4 };
          const geometry = new BufferGeometry();
          const materialKeys = [];
          let start = 0;
          for (let p = 0; p < primitives.length; p++) {
            const primitive = primitives[p];
            const inputs = primitive.inputs;
            let count2 = 0;
            switch (primitive.type) {
              case "lines":
              case "linestrips":
                count2 = primitive.count * 2;
                break;
              case "triangles":
                count2 = primitive.count * 3;
                break;
              case "polylist":
                for (let g = 0; g < primitive.count; g++) {
                  const vc = primitive.vcount[g];
                  switch (vc) {
                    case 3:
                      count2 += 3;
                      break;
                    case 4:
                      count2 += 6;
                      break;
                    default:
                      count2 += (vc - 2) * 3;
                      break;
                  }
                }
                break;
              default:
                console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
            }
            geometry.addGroup(start, count2, p);
            start += count2;
            if (primitive.material) {
              materialKeys.push(primitive.material);
            }
            for (const name in inputs) {
              const input = inputs[name];
              switch (name) {
                case "VERTEX":
                  for (const key in vertices) {
                    const id = vertices[key];
                    switch (key) {
                      case "POSITION":
                        const prevLength = position2.array.length;
                        buildGeometryData(primitive, sources[id], input.offset, position2.array);
                        position2.stride = sources[id].stride;
                        if (sources.skinWeights && sources.skinIndices) {
                          buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                          buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                        }
                        if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                          const count3 = (position2.array.length - prevLength) / position2.stride;
                          for (let i = 0; i < count3; i++) {
                            uv.array.push(0, 0);
                          }
                        }
                        break;
                      case "NORMAL":
                        buildGeometryData(primitive, sources[id], input.offset, normal.array);
                        normal.stride = sources[id].stride;
                        break;
                      case "COLOR":
                        buildGeometryData(primitive, sources[id], input.offset, color.array);
                        color.stride = sources[id].stride;
                        break;
                      case "TEXCOORD":
                        buildGeometryData(primitive, sources[id], input.offset, uv.array);
                        uv.stride = sources[id].stride;
                        break;
                      case "TEXCOORD1":
                        buildGeometryData(primitive, sources[id], input.offset, uv2.array);
                        uv.stride = sources[id].stride;
                        break;
                      default:
                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                    }
                  }
                  break;
                case "NORMAL":
                  buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
                  normal.stride = sources[input.id].stride;
                  break;
                case "COLOR":
                  buildGeometryData(primitive, sources[input.id], input.offset, color.array, true);
                  color.stride = sources[input.id].stride;
                  break;
                case "TEXCOORD":
                  buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
                  uv.stride = sources[input.id].stride;
                  break;
                case "TEXCOORD1":
                  buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
                  uv2.stride = sources[input.id].stride;
                  break;
              }
            }
          }
          if (position2.array.length > 0)
            geometry.setAttribute("position", new Float32BufferAttribute(position2.array, position2.stride));
          if (normal.array.length > 0)
            geometry.setAttribute("normal", new Float32BufferAttribute(normal.array, normal.stride));
          if (color.array.length > 0)
            geometry.setAttribute("color", new Float32BufferAttribute(color.array, color.stride));
          if (uv.array.length > 0)
            geometry.setAttribute("uv", new Float32BufferAttribute(uv.array, uv.stride));
          if (uv2.array.length > 0)
            geometry.setAttribute("uv2", new Float32BufferAttribute(uv2.array, uv2.stride));
          if (skinIndex.array.length > 0)
            geometry.setAttribute("skinIndex", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));
          if (skinWeight.array.length > 0)
            geometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));
          build.data = geometry;
          build.type = primitives[0].type;
          build.materialKeys = materialKeys;
          return build;
        }
        function buildGeometryData(primitive, source, offset, array, isColor = false) {
          const indices = primitive.p;
          const stride = primitive.stride;
          const vcount = primitive.vcount;
          function pushVector(i) {
            let index = indices[i + offset] * sourceStride;
            const length = index + sourceStride;
            for (; index < length; index++) {
              array.push(sourceArray[index]);
            }
            if (isColor) {
              const startIndex = array.length - sourceStride - 1;
              tempColor.setRGB(
                array[startIndex + 0],
                array[startIndex + 1],
                array[startIndex + 2]
              ).convertSRGBToLinear();
              array[startIndex + 0] = tempColor.r;
              array[startIndex + 1] = tempColor.g;
              array[startIndex + 2] = tempColor.b;
            }
          }
          const sourceArray = source.array;
          const sourceStride = source.stride;
          if (primitive.vcount !== void 0) {
            let index = 0;
            for (let i = 0, l = vcount.length; i < l; i++) {
              const count2 = vcount[i];
              if (count2 === 4) {
                const a = index + stride * 0;
                const b = index + stride * 1;
                const c = index + stride * 2;
                const d = index + stride * 3;
                pushVector(a);
                pushVector(b);
                pushVector(d);
                pushVector(b);
                pushVector(c);
                pushVector(d);
              } else if (count2 === 3) {
                const a = index + stride * 0;
                const b = index + stride * 1;
                const c = index + stride * 2;
                pushVector(a);
                pushVector(b);
                pushVector(c);
              } else if (count2 > 4) {
                for (let k = 1, kl = count2 - 2; k <= kl; k++) {
                  const a = index + stride * 0;
                  const b = index + stride * k;
                  const c = index + stride * (k + 1);
                  pushVector(a);
                  pushVector(b);
                  pushVector(c);
                }
              }
              index += stride * count2;
            }
          } else {
            for (let i = 0, l = indices.length; i < l; i += stride) {
              pushVector(i);
            }
          }
        }
        function getGeometry(id) {
          return getBuild(library.geometries[id], buildGeometry);
        }
        function parseKinematicsModel(xml2) {
          const data = {
            name: xml2.getAttribute("name") || "",
            joints: {},
            links: []
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "technique_common":
                parseKinematicsTechniqueCommon(child, data);
                break;
            }
          }
          library.kinematicsModels[xml2.getAttribute("id")] = data;
        }
        function buildKinematicsModel(data) {
          if (data.build !== void 0)
            return data.build;
          return data;
        }
        function getKinematicsModel(id) {
          return getBuild(library.kinematicsModels[id], buildKinematicsModel);
        }
        function parseKinematicsTechniqueCommon(xml2, data) {
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "joint":
                data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
                break;
              case "link":
                data.links.push(parseKinematicsLink(child));
                break;
            }
          }
        }
        function parseKinematicsJoint(xml2) {
          let data;
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "prismatic":
              case "revolute":
                data = parseKinematicsJointParameter(child);
                break;
            }
          }
          return data;
        }
        function parseKinematicsJointParameter(xml2) {
          const data = {
            sid: xml2.getAttribute("sid"),
            name: xml2.getAttribute("name") || "",
            axis: new Vector3(),
            limits: {
              min: 0,
              max: 0
            },
            type: xml2.nodeName,
            static: false,
            zeroPosition: 0,
            middlePosition: 0
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "axis":
                const array = parseFloats(child.textContent);
                data.axis.fromArray(array);
                break;
              case "limits":
                const max2 = child.getElementsByTagName("max")[0];
                const min = child.getElementsByTagName("min")[0];
                data.limits.max = parseFloat(max2.textContent);
                data.limits.min = parseFloat(min.textContent);
                break;
            }
          }
          if (data.limits.min >= data.limits.max) {
            data.static = true;
          }
          data.middlePosition = (data.limits.min + data.limits.max) / 2;
          return data;
        }
        function parseKinematicsLink(xml2) {
          const data = {
            sid: xml2.getAttribute("sid"),
            name: xml2.getAttribute("name") || "",
            attachments: [],
            transforms: []
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "attachment_full":
                data.attachments.push(parseKinematicsAttachment(child));
                break;
              case "matrix":
              case "translate":
              case "rotate":
                data.transforms.push(parseKinematicsTransform(child));
                break;
            }
          }
          return data;
        }
        function parseKinematicsAttachment(xml2) {
          const data = {
            joint: xml2.getAttribute("joint").split("/").pop(),
            transforms: [],
            links: []
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "link":
                data.links.push(parseKinematicsLink(child));
                break;
              case "matrix":
              case "translate":
              case "rotate":
                data.transforms.push(parseKinematicsTransform(child));
                break;
            }
          }
          return data;
        }
        function parseKinematicsTransform(xml2) {
          const data = {
            type: xml2.nodeName
          };
          const array = parseFloats(xml2.textContent);
          switch (data.type) {
            case "matrix":
              data.obj = new Matrix4();
              data.obj.fromArray(array).transpose();
              break;
            case "translate":
              data.obj = new Vector3();
              data.obj.fromArray(array);
              break;
            case "rotate":
              data.obj = new Vector3();
              data.obj.fromArray(array);
              data.angle = MathUtils.degToRad(array[3]);
              break;
          }
          return data;
        }
        function parsePhysicsModel(xml2) {
          const data = {
            name: xml2.getAttribute("name") || "",
            rigidBodies: {}
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "rigid_body":
                data.rigidBodies[child.getAttribute("name")] = {};
                parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
                break;
            }
          }
          library.physicsModels[xml2.getAttribute("id")] = data;
        }
        function parsePhysicsRigidBody(xml2, data) {
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "technique_common":
                parsePhysicsTechniqueCommon(child, data);
                break;
            }
          }
        }
        function parsePhysicsTechniqueCommon(xml2, data) {
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "inertia":
                data.inertia = parseFloats(child.textContent);
                break;
              case "mass":
                data.mass = parseFloats(child.textContent)[0];
                break;
            }
          }
        }
        function parseKinematicsScene(xml2) {
          const data = {
            bindJointAxis: []
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "bind_joint_axis":
                data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
                break;
            }
          }
          library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
        }
        function parseKinematicsBindJointAxis(xml2) {
          const data = {
            target: xml2.getAttribute("target").split("/").pop()
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            switch (child.nodeName) {
              case "axis":
                const param = child.getElementsByTagName("param")[0];
                data.axis = param.textContent;
                const tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
                data.jointIndex = tmpJointIndex.substring(0, tmpJointIndex.length - 1);
                break;
            }
          }
          return data;
        }
        function buildKinematicsScene(data) {
          if (data.build !== void 0)
            return data.build;
          return data;
        }
        function getKinematicsScene(id) {
          return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
        }
        function setupKinematics() {
          const kinematicsModelId = Object.keys(library.kinematicsModels)[0];
          const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
          const visualSceneId = Object.keys(library.visualScenes)[0];
          if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)
            return;
          const kinematicsModel = getKinematicsModel(kinematicsModelId);
          const kinematicsScene = getKinematicsScene(kinematicsSceneId);
          const visualScene = getVisualScene(visualSceneId);
          const bindJointAxis = kinematicsScene.bindJointAxis;
          const jointMap = {};
          for (let i = 0, l = bindJointAxis.length; i < l; i++) {
            const axis = bindJointAxis[i];
            const targetElement = collada.querySelector('[sid="' + axis.target + '"]');
            if (targetElement) {
              const parentVisualElement = targetElement.parentElement;
              connect(axis.jointIndex, parentVisualElement);
            }
          }
          function connect(jointIndex, visualElement) {
            const visualElementName = visualElement.getAttribute("name");
            const joint = kinematicsModel.joints[jointIndex];
            visualScene.traverse(function(object) {
              if (object.name === visualElementName) {
                jointMap[jointIndex] = {
                  object,
                  transforms: buildTransformList(visualElement),
                  joint,
                  position: joint.zeroPosition
                };
              }
            });
          }
          const m0 = new Matrix4();
          kinematics = {
            joints: kinematicsModel && kinematicsModel.joints,
            getJointValue: function(jointIndex) {
              const jointData = jointMap[jointIndex];
              if (jointData) {
                return jointData.position;
              } else {
                console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
              }
            },
            setJointValue: function(jointIndex, value) {
              const jointData = jointMap[jointIndex];
              if (jointData) {
                const joint = jointData.joint;
                if (value > joint.limits.max || value < joint.limits.min) {
                  console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
                } else if (joint.static) {
                  console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
                } else {
                  const object = jointData.object;
                  const axis = joint.axis;
                  const transforms = jointData.transforms;
                  matrix.identity();
                  for (let i = 0; i < transforms.length; i++) {
                    const transform = transforms[i];
                    if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {
                      switch (joint.type) {
                        case "revolute":
                          matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));
                          break;
                        case "prismatic":
                          matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                          break;
                        default:
                          console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                          break;
                      }
                    } else {
                      switch (transform.type) {
                        case "matrix":
                          matrix.multiply(transform.obj);
                          break;
                        case "translate":
                          matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                          break;
                        case "scale":
                          matrix.scale(transform.obj);
                          break;
                        case "rotate":
                          matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                          break;
                      }
                    }
                  }
                  object.matrix.copy(matrix);
                  object.matrix.decompose(object.position, object.quaternion, object.scale);
                  jointMap[jointIndex].position = value;
                }
              } else {
                console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
              }
            }
          };
        }
        function buildTransformList(node) {
          const transforms = [];
          const xml2 = collada.querySelector('[id="' + node.id + '"]');
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            let array, vector2;
            switch (child.nodeName) {
              case "matrix":
                array = parseFloats(child.textContent);
                const matrix2 = new Matrix4().fromArray(array).transpose();
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: matrix2
                });
                break;
              case "translate":
              case "scale":
                array = parseFloats(child.textContent);
                vector2 = new Vector3().fromArray(array);
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: vector2
                });
                break;
              case "rotate":
                array = parseFloats(child.textContent);
                vector2 = new Vector3().fromArray(array);
                const angle = MathUtils.degToRad(array[3]);
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: vector2,
                  angle
                });
                break;
            }
          }
          return transforms;
        }
        function prepareNodes(xml2) {
          const elements = xml2.getElementsByTagName("node");
          for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            if (element.hasAttribute("id") === false) {
              element.setAttribute("id", generateId());
            }
          }
        }
        const matrix = new Matrix4();
        const vector = new Vector3();
        function parseNode(xml2) {
          const data = {
            name: xml2.getAttribute("name") || "",
            type: xml2.getAttribute("type"),
            id: xml2.getAttribute("id"),
            sid: xml2.getAttribute("sid"),
            matrix: new Matrix4(),
            nodes: [],
            instanceCameras: [],
            instanceControllers: [],
            instanceLights: [],
            instanceGeometries: [],
            instanceNodes: [],
            transforms: {}
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            if (child.nodeType !== 1)
              continue;
            let array;
            switch (child.nodeName) {
              case "node":
                data.nodes.push(child.getAttribute("id"));
                parseNode(child);
                break;
              case "instance_camera":
                data.instanceCameras.push(parseId(child.getAttribute("url")));
                break;
              case "instance_controller":
                data.instanceControllers.push(parseNodeInstance(child));
                break;
              case "instance_light":
                data.instanceLights.push(parseId(child.getAttribute("url")));
                break;
              case "instance_geometry":
                data.instanceGeometries.push(parseNodeInstance(child));
                break;
              case "instance_node":
                data.instanceNodes.push(parseId(child.getAttribute("url")));
                break;
              case "matrix":
                array = parseFloats(child.textContent);
                data.matrix.multiply(matrix.fromArray(array).transpose());
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "translate":
                array = parseFloats(child.textContent);
                vector.fromArray(array);
                data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "rotate":
                array = parseFloats(child.textContent);
                const angle = MathUtils.degToRad(array[3]);
                data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "scale":
                array = parseFloats(child.textContent);
                data.matrix.scale(vector.fromArray(array));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "extra":
                break;
              default:
                console.log(child);
            }
          }
          if (hasNode(data.id)) {
            console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
          } else {
            library.nodes[data.id] = data;
          }
          return data;
        }
        function parseNodeInstance(xml2) {
          const data = {
            id: parseId(xml2.getAttribute("url")),
            materials: {},
            skeletons: []
          };
          for (let i = 0; i < xml2.childNodes.length; i++) {
            const child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "bind_material":
                const instances = child.getElementsByTagName("instance_material");
                for (let j = 0; j < instances.length; j++) {
                  const instance = instances[j];
                  const symbol = instance.getAttribute("symbol");
                  const target = instance.getAttribute("target");
                  data.materials[symbol] = parseId(target);
                }
                break;
              case "skeleton":
                data.skeletons.push(parseId(child.textContent));
                break;
              default:
                break;
            }
          }
          return data;
        }
        function buildSkeleton(skeletons, joints) {
          const boneData = [];
          const sortedBoneData = [];
          let i, j, data;
          for (i = 0; i < skeletons.length; i++) {
            const skeleton = skeletons[i];
            let root;
            if (hasNode(skeleton)) {
              root = getNode(skeleton);
              buildBoneHierarchy(root, joints, boneData);
            } else if (hasVisualScene(skeleton)) {
              const visualScene = library.visualScenes[skeleton];
              const children = visualScene.children;
              for (let j2 = 0; j2 < children.length; j2++) {
                const child = children[j2];
                if (child.type === "JOINT") {
                  const root2 = getNode(child.id);
                  buildBoneHierarchy(root2, joints, boneData);
                }
              }
            } else {
              console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
            }
          }
          for (i = 0; i < joints.length; i++) {
            for (j = 0; j < boneData.length; j++) {
              data = boneData[j];
              if (data.bone.name === joints[i].name) {
                sortedBoneData[i] = data;
                data.processed = true;
                break;
              }
            }
          }
          for (i = 0; i < boneData.length; i++) {
            data = boneData[i];
            if (data.processed === false) {
              sortedBoneData.push(data);
              data.processed = true;
            }
          }
          const bones = [];
          const boneInverses = [];
          for (i = 0; i < sortedBoneData.length; i++) {
            data = sortedBoneData[i];
            bones.push(data.bone);
            boneInverses.push(data.boneInverse);
          }
          return new Skeleton(bones, boneInverses);
        }
        function buildBoneHierarchy(root, joints, boneData) {
          root.traverse(function(object) {
            if (object.isBone === true) {
              let boneInverse;
              for (let i = 0; i < joints.length; i++) {
                const joint = joints[i];
                if (joint.name === object.name) {
                  boneInverse = joint.boneInverse;
                  break;
                }
              }
              if (boneInverse === void 0) {
                boneInverse = new Matrix4();
              }
              boneData.push({ bone: object, boneInverse, processed: false });
            }
          });
        }
        function buildNode(data) {
          const objects = [];
          const matrix2 = data.matrix;
          const nodes = data.nodes;
          const type = data.type;
          const instanceCameras = data.instanceCameras;
          const instanceControllers = data.instanceControllers;
          const instanceLights = data.instanceLights;
          const instanceGeometries = data.instanceGeometries;
          const instanceNodes = data.instanceNodes;
          for (let i = 0, l = nodes.length; i < l; i++) {
            objects.push(getNode(nodes[i]));
          }
          for (let i = 0, l = instanceCameras.length; i < l; i++) {
            const instanceCamera = getCamera(instanceCameras[i]);
            if (instanceCamera !== null) {
              objects.push(instanceCamera.clone());
            }
          }
          for (let i = 0, l = instanceControllers.length; i < l; i++) {
            const instance = instanceControllers[i];
            const controller = getController(instance.id);
            const geometries = getGeometry(controller.id);
            const newObjects = buildObjects(geometries, instance.materials);
            const skeletons = instance.skeletons;
            const joints = controller.skin.joints;
            const skeleton = buildSkeleton(skeletons, joints);
            for (let j = 0, jl = newObjects.length; j < jl; j++) {
              const object2 = newObjects[j];
              if (object2.isSkinnedMesh) {
                object2.bind(skeleton, controller.skin.bindMatrix);
                object2.normalizeSkinWeights();
              }
              objects.push(object2);
            }
          }
          for (let i = 0, l = instanceLights.length; i < l; i++) {
            const instanceLight = getLight(instanceLights[i]);
            if (instanceLight !== null) {
              objects.push(instanceLight.clone());
            }
          }
          for (let i = 0, l = instanceGeometries.length; i < l; i++) {
            const instance = instanceGeometries[i];
            const geometries = getGeometry(instance.id);
            const newObjects = buildObjects(geometries, instance.materials);
            for (let j = 0, jl = newObjects.length; j < jl; j++) {
              objects.push(newObjects[j]);
            }
          }
          for (let i = 0, l = instanceNodes.length; i < l; i++) {
            objects.push(getNode(instanceNodes[i]).clone());
          }
          let object;
          if (nodes.length === 0 && objects.length === 1) {
            object = objects[0];
          } else {
            object = type === "JOINT" ? new Bone() : new Group();
            for (let i = 0; i < objects.length; i++) {
              object.add(objects[i]);
            }
          }
          object.name = type === "JOINT" ? data.sid : data.name;
          object.matrix.copy(matrix2);
          object.matrix.decompose(object.position, object.quaternion, object.scale);
          return object;
        }
        const fallbackMaterial = new MeshBasicMaterial({ color: 16711935 });
        function resolveMaterialBinding(keys, instanceMaterials) {
          const materials = [];
          for (let i = 0, l = keys.length; i < l; i++) {
            const id = instanceMaterials[keys[i]];
            if (id === void 0) {
              console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i]);
              materials.push(fallbackMaterial);
            } else {
              materials.push(getMaterial(id));
            }
          }
          return materials;
        }
        function buildObjects(geometries, instanceMaterials) {
          const objects = [];
          for (const type in geometries) {
            const geometry = geometries[type];
            const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
            if (materials.length === 0) {
              if (type === "lines" || type === "linestrips") {
                materials.push(new LineBasicMaterial());
              } else {
                materials.push(new MeshPhongMaterial());
              }
            }
            if (type === "lines" || type === "linestrips") {
              for (let i = 0, l = materials.length; i < l; i++) {
                const material2 = materials[i];
                if (material2.isMeshPhongMaterial === true || material2.isMeshLambertMaterial === true) {
                  const lineMaterial = new LineBasicMaterial();
                  lineMaterial.color.copy(material2.color);
                  lineMaterial.opacity = material2.opacity;
                  lineMaterial.transparent = material2.transparent;
                  materials[i] = lineMaterial;
                }
              }
            }
            const skinning = geometry.data.attributes.skinIndex !== void 0;
            const material = materials.length === 1 ? materials[0] : materials;
            let object;
            switch (type) {
              case "lines":
                object = new LineSegments(geometry.data, material);
                break;
              case "linestrips":
                object = new Line(geometry.data, material);
                break;
              case "triangles":
              case "polylist":
                if (skinning) {
                  object = new SkinnedMesh(geometry.data, material);
                } else {
                  object = new Mesh(geometry.data, material);
                }
                break;
            }
            objects.push(object);
          }
          return objects;
        }
        function hasNode(id) {
          return library.nodes[id] !== void 0;
        }
        function getNode(id) {
          return getBuild(library.nodes[id], buildNode);
        }
        function parseVisualScene(xml2) {
          const data = {
            name: xml2.getAttribute("name"),
            children: []
          };
          prepareNodes(xml2);
          const elements = getElementsByTagName(xml2, "node");
          for (let i = 0; i < elements.length; i++) {
            data.children.push(parseNode(elements[i]));
          }
          library.visualScenes[xml2.getAttribute("id")] = data;
        }
        function buildVisualScene(data) {
          const group = new Group();
          group.name = data.name;
          const children = data.children;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            group.add(getNode(child.id));
          }
          return group;
        }
        function hasVisualScene(id) {
          return library.visualScenes[id] !== void 0;
        }
        function getVisualScene(id) {
          return getBuild(library.visualScenes[id], buildVisualScene);
        }
        function parseScene(xml2) {
          const instance = getElementsByTagName(xml2, "instance_visual_scene")[0];
          return getVisualScene(parseId(instance.getAttribute("url")));
        }
        function setupAnimations() {
          const clips = library.clips;
          if (isEmpty(clips) === true) {
            if (isEmpty(library.animations) === false) {
              const tracks = [];
              for (const id in library.animations) {
                const animationTracks = getAnimation(id);
                for (let i = 0, l = animationTracks.length; i < l; i++) {
                  tracks.push(animationTracks[i]);
                }
              }
              animations.push(new AnimationClip("default", -1, tracks));
            }
          } else {
            for (const id in clips) {
              animations.push(getAnimationClip(id));
            }
          }
        }
        function parserErrorToText(parserError2) {
          let result = "";
          const stack = [parserError2];
          while (stack.length) {
            const node = stack.shift();
            if (node.nodeType === Node.TEXT_NODE) {
              result += node.textContent;
            } else {
              result += "\n";
              stack.push.apply(stack, node.childNodes);
            }
          }
          return result.trim();
        }
        if (text.length === 0) {
          return { scene: new Scene() };
        }
        const xml = new DOMParser().parseFromString(text, "application/xml");
        const collada = getElementsByTagName(xml, "COLLADA")[0];
        const parserError = xml.getElementsByTagName("parsererror")[0];
        if (parserError !== void 0) {
          const errorElement = getElementsByTagName(parserError, "div")[0];
          let errorText;
          if (errorElement) {
            errorText = errorElement.textContent;
          } else {
            errorText = parserErrorToText(parserError);
          }
          console.error("THREE.ColladaLoader: Failed to parse collada file.\n", errorText);
          return null;
        }
        const version = collada.getAttribute("version");
        console.debug("THREE.ColladaLoader: File version", version);
        const asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
        const textureLoader = new TextureLoader(this.manager);
        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        let tgaLoader;
        if (TGALoader) {
          tgaLoader = new TGALoader(this.manager);
          tgaLoader.setPath(this.resourcePath || path);
        }
        const tempColor = new Color();
        const animations = [];
        let kinematics = {};
        let count = 0;
        const library = {
          animations: {},
          clips: {},
          controllers: {},
          images: {},
          effects: {},
          materials: {},
          cameras: {},
          lights: {},
          geometries: {},
          nodes: {},
          visualScenes: {},
          kinematicsModels: {},
          physicsModels: {},
          kinematicsScenes: {}
        };
        parseLibrary(collada, "library_animations", "animation", parseAnimation);
        parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
        parseLibrary(collada, "library_controllers", "controller", parseController);
        parseLibrary(collada, "library_images", "image", parseImage);
        parseLibrary(collada, "library_effects", "effect", parseEffect);
        parseLibrary(collada, "library_materials", "material", parseMaterial);
        parseLibrary(collada, "library_cameras", "camera", parseCamera);
        parseLibrary(collada, "library_lights", "light", parseLight);
        parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
        parseLibrary(collada, "library_nodes", "node", parseNode);
        parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
        parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
        parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
        parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
        buildLibrary(library.animations, buildAnimation);
        buildLibrary(library.clips, buildAnimationClip);
        buildLibrary(library.controllers, buildController);
        buildLibrary(library.images, buildImage);
        buildLibrary(library.effects, buildEffect);
        buildLibrary(library.materials, buildMaterial);
        buildLibrary(library.cameras, buildCamera);
        buildLibrary(library.lights, buildLight);
        buildLibrary(library.geometries, buildGeometry);
        buildLibrary(library.visualScenes, buildVisualScene);
        setupAnimations();
        setupKinematics();
        const scene = parseScene(getElementsByTagName(collada, "scene")[0]);
        scene.animations = animations;
        if (asset.upAxis === "Z_UP") {
          console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.");
          scene.rotation.set(-Math.PI / 2, 0, 0);
        }
        scene.scale.multiplyScalar(asset.unit);
        return {
          get animations() {
            console.warn("THREE.ColladaLoader: Please access animations over scene.animations now.");
            return animations;
          },
          kinematics,
          library,
          scene
        };
      }
    };
  }
});

// node_modules/three/examples/jsm/libs/fflate.module.js
function AsyncCmpStrm(opts, cb) {
  if (!cb && typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
function inflateSync(data, out) {
  return inflt(data, out);
}
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td)
    return td.decode(dat);
  else {
    var _a2 = dutf8(dat), out = _a2[0], ext = _a2[1];
    if (ext.length)
      throw "invalid utf-8 data";
    return out;
  }
}
var ch2, durl, cwk, wk, u8, u16, u32, fleb, fdeb, clim, freb, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap, flt, i, i, i, i, fdt, i, flm, flrm, fdm, fdrm, max, bits, bits16, shft, slc, inflt, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, deo, et, dflt, crct, crc, adler, dopt, mrg, wcln, ch, cbfs, wrkr, bInflt, bDflt, gze, guze, zle, zule, pbf, gu8, astrm, astrmify, b2, b4, b8, wbytes, gzh, gzs, gzl, gzhl, zlh, zlv, Deflate, AsyncDeflate, Inflate, AsyncInflate, Gzip, AsyncGzip, Gunzip, AsyncGunzip, Zlib, AsyncZlib, Unzlib, AsyncUnzlib, Decompress, AsyncDecompress, te, td, tds, dutf8, DecodeUTF8, EncodeUTF8, dbf, z64e, exfl, wzh, wzf, ZipPassThrough, ZipDeflate, AsyncZipDeflate, Zip, UnzipPassThrough, UnzipInflate, AsyncUnzipInflate, Unzip;
var init_fflate_module = __esm({
  "node_modules/three/examples/jsm/libs/fflate.module.js"() {
    ch2 = {};
    durl = function(c) {
      return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
    };
    cwk = function(u) {
      return new Worker(u);
    };
    try {
      URL.revokeObjectURL(durl(""));
    } catch (e) {
      durl = function(c) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(c);
      };
      cwk = function(u) {
        return new Worker(u, { type: "module" });
      };
    }
    wk = function(c, id, msg, transfer, cb) {
      var w = cwk(ch2[id] || (ch2[id] = durl(c)));
      w.onerror = function(e) {
        return cb(e.error, null);
      };
      w.onmessage = function(e) {
        return cb(null, e.data);
      };
      w.postMessage(msg, transfer);
      return w;
    };
    u8 = Uint8Array;
    u16 = Uint16Array;
    u32 = Uint32Array;
    fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    freb = function(eb, start) {
      var b = new u16(31);
      for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
      }
      var r = new u32(b[30]);
      for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
          r[j] = j - b[i] << 5 | i;
        }
      }
      return [b, r];
    };
    _a = freb(fleb, 2);
    fl = _a[0];
    revfl = _a[1];
    fl[28] = 258, revfl[258] = 28;
    _b = freb(fdeb, 0);
    fd = _b[0];
    revfd = _b[1];
    rev = new u16(32768);
    for (i = 0; i < 32768; ++i) {
      x = (i & 43690) >>> 1 | (i & 21845) << 1;
      x = (x & 52428) >>> 2 | (x & 13107) << 2;
      x = (x & 61680) >>> 4 | (x & 3855) << 4;
      rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
    }
    hMap = function(cd, mb, r) {
      var s = cd.length;
      var i = 0;
      var l = new u16(mb);
      for (; i < s; ++i)
        ++l[cd[i] - 1];
      var le = new u16(mb);
      for (i = 0; i < mb; ++i) {
        le[i] = le[i - 1] + l[i - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
          if (cd[i]) {
            var sv = i << 4 | cd[i];
            var r_1 = mb - cd[i];
            var v = le[cd[i] - 1]++ << r_1;
            for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
              co[rev[v] >>> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
          if (cd[i]) {
            co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
          }
        }
      }
      return co;
    };
    flt = new u8(288);
    for (i = 0; i < 144; ++i)
      flt[i] = 8;
    for (i = 144; i < 256; ++i)
      flt[i] = 9;
    for (i = 256; i < 280; ++i)
      flt[i] = 7;
    for (i = 280; i < 288; ++i)
      flt[i] = 8;
    fdt = new u8(32);
    for (i = 0; i < 32; ++i)
      fdt[i] = 5;
    flm = hMap(flt, 9, 0);
    flrm = hMap(flt, 9, 1);
    fdm = hMap(fdt, 5, 0);
    fdrm = hMap(fdt, 5, 1);
    max = function(a) {
      var m = a[0];
      for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
          m = a[i];
      }
      return m;
    };
    bits = function(d, p, m) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
    };
    bits16 = function(d, p) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
    };
    shft = function(p) {
      return (p / 8 | 0) + (p & 7 && 1);
    };
    slc = function(v, s, e) {
      if (s == null || s < 0)
        s = 0;
      if (e == null || e > v.length)
        e = v.length;
      var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
      n.set(v.subarray(s, e));
      return n;
    };
    inflt = function(dat, buf, st) {
      var sl = dat.length;
      if (!sl || st && !st.l && sl < 5)
        return buf || new u8(0);
      var noBuf = !buf || st;
      var noSt = !st || st.i;
      if (!st)
        st = {};
      if (!buf)
        buf = new u8(sl * 3);
      var cbuf = function(l2) {
        var bl = buf.length;
        if (l2 > bl) {
          var nbuf = new u8(Math.max(bl * 2, l2));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      var tbts = sl * 8;
      do {
        if (!lm) {
          st.f = final = bits(dat, pos, 1);
          var type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
            if (t > sl) {
              if (noSt)
                throw "unexpected EOF";
              break;
            }
            if (noBuf)
              cbuf(bt + l);
            buf.set(dat.subarray(s, t), bt);
            st.b = bt += l, st.p = pos = t * 8;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            var tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            var ldt = new u8(tl);
            var clt = new u8(19);
            for (var i = 0; i < hcLen; ++i) {
              clt[clim[i]] = bits(dat, pos + i * 3, 7);
            }
            pos += hcLen * 3;
            var clb = max(clt), clbmsk = (1 << clb) - 1;
            var clm = hMap(clt, clb, 1);
            for (var i = 0; i < tl; ) {
              var r = clm[bits(dat, pos, clbmsk)];
              pos += r & 15;
              var s = r >>> 4;
              if (s < 16) {
                ldt[i++] = s;
              } else {
                var c = 0, n = 0;
                if (s == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                else if (s == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i++] = c;
              }
            }
            var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            throw "invalid block type";
          if (pos > tbts) {
            if (noSt)
              throw "unexpected EOF";
            break;
          }
        }
        if (noBuf)
          cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (; ; lpos = pos) {
          var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
          pos += c & 15;
          if (pos > tbts) {
            if (noSt)
              throw "unexpected EOF";
            break;
          }
          if (!c)
            throw "invalid length/literal";
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lpos = pos, lm = null;
            break;
          } else {
            var add = sym - 254;
            if (sym > 264) {
              var i = sym - 257, b = fleb[i];
              add = bits(dat, pos, (1 << b) - 1) + fl[i];
              pos += b;
            }
            var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
            if (!d)
              throw "invalid distance";
            pos += d & 15;
            var dt = fd[dsym];
            if (dsym > 3) {
              var b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts) {
              if (noSt)
                throw "unexpected EOF";
              break;
            }
            if (noBuf)
              cbuf(bt + 131072);
            var end = bt + add;
            for (; bt < end; bt += 4) {
              buf[bt] = buf[bt - dt];
              buf[bt + 1] = buf[bt + 1 - dt];
              buf[bt + 2] = buf[bt + 2 - dt];
              buf[bt + 3] = buf[bt + 3 - dt];
            }
            bt = end;
          }
        }
        st.l = lm, st.p = lpos, st.b = bt;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt == buf.length ? buf : slc(buf, 0, bt);
    };
    wbits = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
    };
    wbits16 = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
      d[o + 2] |= v >>> 16;
    };
    hTree = function(d, mb) {
      var t = [];
      for (var i = 0; i < d.length; ++i) {
        if (d[i])
          t.push({ s: i, f: d[i] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
        return [et, 0];
      if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return [v, 1];
      }
      t.sort(function(a, b) {
        return a.f - b.f;
      });
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
      t[0] = { s: -1, f: l.f + r.f, l, r };
      while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l, r };
      }
      var maxSym = t2[0].s;
      for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
          maxSym = t2[i].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i = 0, dt = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
          return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for (; i < s; ++i) {
          var i2_1 = t2[i].s;
          if (tr[i2_1] > mb) {
            dt += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt >>>= lft;
        while (dt > 0) {
          var i2_2 = t2[i].s;
          if (tr[i2_2] < mb)
            dt -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i;
        }
        for (; i >= 0 && dt; --i) {
          var i2_3 = t2[i].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt;
          }
        }
        mbt = mb;
      }
      return [new u8(tr), mbt];
    };
    ln = function(n, l, d) {
      return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
    };
    lc = function(c) {
      var s = c.length;
      while (s && !c[--s])
        ;
      var cl = new u16(++s);
      var cli = 0, cln = c[0], cls = 1;
      var w = function(v) {
        cl[cli++] = v;
      };
      for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w(32754);
            if (cls > 2) {
              w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w(cln), --cls;
            for (; cls > 6; cls -= 6)
              w(8304);
            if (cls > 2)
              w(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w(cln);
          cls = 1;
          cln = c[i];
        }
      }
      return [cl.subarray(0, cli), s];
    };
    clen = function(cf, cl) {
      var l = 0;
      for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
      return l;
    };
    wfblk = function(out, pos, dat) {
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >>> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
      return (o + 4 + s) * 8;
    };
    wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
      var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
      var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
      var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
      var lcfreq = new u16(19);
      for (var i = 0; i < lclt.length; ++i)
        lcfreq[lclt[i] & 31]++;
      for (var i = 0; i < lcdt.length; ++i)
        lcfreq[lcdt[i] & 31]++;
      var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
      if (flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i = 0; i < nlcc; ++i)
          wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
          var clct = lcts[it];
          for (var i = 0; i < clct.length; ++i) {
            var len = clct[i] & 31;
            wbits(out, p, llm[len]), p += lct[len];
            if (len > 15)
              wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i = 0; i < li; ++i) {
        if (syms[i] > 255) {
          var len = syms[i] >>> 18 & 31;
          wbits16(out, p, lm[len + 257]), p += ll[len + 257];
          if (len > 7)
            wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
          var dst = syms[i] & 31;
          wbits16(out, p, dm[dst]), p += dl[dst];
          if (dst > 3)
            wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
        } else {
          wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
        }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
    };
    deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    et = new u8(0);
    dflt = function(dat, lvl, plvl, pre, post, lst) {
      var s = dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
      var w = o.subarray(pre, o.length - post);
      var pos = 0;
      if (!lvl || s < 8) {
        for (var i = 0; i <= s; i += 65535) {
          var e = i + 65535;
          if (e < s) {
            pos = wfblk(w, pos, dat.subarray(i, e));
          } else {
            w[i] = lst;
            pos = wfblk(w, pos, dat.subarray(i, s));
          }
        }
      } else {
        var opt = deo[lvl - 1];
        var n = opt >>> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = new u16(32768), head = new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i2) {
          return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
        };
        var syms = new u32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
        for (; i < s; ++i) {
          var hv = hsh(i);
          var imod = i & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i) {
            var rem = s - i;
            if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
              pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
              li = lc_1 = eb = 0, bs = i;
              for (var j = 0; j < 286; ++j)
                lf[j] = 0;
              for (var j = 0; j < 30; ++j)
                df[j] = 0;
            }
            var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i + l] == dat[i + l - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                    ;
                  if (nl > l) {
                    l = nl, d = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j = 0; j < mmd; ++j) {
                      var ti = i - dif + j + 32768 & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti + 32768 & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod + 32768 & 32767;
              }
            }
            if (d) {
              syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
              var lin = revfl[l] & 31, din = revfd[d] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i + l;
              ++lc_1;
            } else {
              syms[li++] = dat[i];
              ++lf[dat[i]];
            }
          }
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst && pos & 7)
          pos = wfblk(w, pos + 1, et);
      }
      return slc(o, 0, pre + shft(pos) + post);
    };
    crct = function() {
      var t = new u32(256);
      for (var i = 0; i < 256; ++i) {
        var c = i, k = 9;
        while (--k)
          c = (c & 1 && 3988292384) ^ c >>> 1;
        t[i] = c;
      }
      return t;
    }();
    crc = function() {
      var c = -1;
      return {
        p: function(d) {
          var cr = c;
          for (var i = 0; i < d.length; ++i)
            cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
          c = cr;
        },
        d: function() {
          return ~c;
        }
      };
    };
    adler = function() {
      var a = 1, b = 0;
      return {
        p: function(d) {
          var n = a, m = b;
          var l = d.length;
          for (var i = 0; i != l; ) {
            var e = Math.min(i + 2655, l);
            for (; i < e; ++i)
              m += n += d[i];
            n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
          }
          a = n, b = m;
        },
        d: function() {
          a %= 65521, b %= 65521;
          return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
        }
      };
    };
    dopt = function(dat, opt, pre, post, st) {
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
    };
    mrg = function(a, b) {
      var o = {};
      for (var k in a)
        o[k] = a[k];
      for (var k in b)
        o[k] = b[k];
      return o;
    };
    wcln = function(fn, fnStr, td2) {
      var dt = fn();
      var st = fn.toString();
      var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/ /g, "").split(",");
      for (var i = 0; i < dt.length; ++i) {
        var v = dt[i], k = ks[i];
        if (typeof v == "function") {
          fnStr += ";" + k + "=";
          var st_1 = v.toString();
          if (v.prototype) {
            if (st_1.indexOf("[native code]") != -1) {
              var spInd = st_1.indexOf(" ", 8) + 1;
              fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
            } else {
              fnStr += st_1;
              for (var t in v.prototype)
                fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
            }
          } else
            fnStr += st_1;
        } else
          td2[k] = v;
      }
      return [fnStr, td2];
    };
    ch = [];
    cbfs = function(v) {
      var tl = [];
      for (var k in v) {
        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)
          tl.push((v[k] = new v[k].constructor(v[k])).buffer);
      }
      return tl;
    };
    wrkr = function(fns, init, id, cb) {
      var _a2;
      if (!ch[id]) {
        var fnStr = "", td_1 = {}, m = fns.length - 1;
        for (var i = 0; i < m; ++i)
          _a2 = wcln(fns[i], fnStr, td_1), fnStr = _a2[0], td_1 = _a2[1];
        ch[id] = wcln(fns[m], fnStr, td_1);
      }
      var td2 = mrg({}, ch[id][1]);
      return wk(ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
    };
    bInflt = function() {
      return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
    };
    bDflt = function() {
      return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
    };
    gze = function() {
      return [gzh, gzhl, wbytes, crc, crct];
    };
    guze = function() {
      return [gzs, gzl];
    };
    zle = function() {
      return [zlh, wbytes, adler];
    };
    zule = function() {
      return [zlv];
    };
    pbf = function(msg) {
      return postMessage(msg, [msg.buffer]);
    };
    gu8 = function(o) {
      return o && o.size && new u8(o.size);
    };
    astrm = function(strm) {
      strm.ondata = function(dat, final) {
        return postMessage([dat, final], [dat.buffer]);
      };
      return function(ev) {
        return strm.push(ev.data[0], ev.data[1]);
      };
    };
    astrmify = function(fns, strm, opts, init, id) {
      var t;
      var w = wrkr(fns, init, id, function(err, dat) {
        if (err)
          w.terminate(), strm.ondata.call(strm, err);
        else {
          if (dat[1])
            w.terminate();
          strm.ondata.call(strm, err, dat[0], dat[1]);
        }
      });
      w.postMessage(opts);
      strm.push = function(d, f) {
        if (t)
          throw "stream finished";
        if (!strm.ondata)
          throw "no stream handler";
        w.postMessage([d, t = f], [d.buffer]);
      };
      strm.terminate = function() {
        w.terminate();
      };
    };
    b2 = function(d, b) {
      return d[b] | d[b + 1] << 8;
    };
    b4 = function(d, b) {
      return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
    };
    b8 = function(d, b) {
      return b4(d, b) + b4(d, b + 4) * 4294967296;
    };
    wbytes = function(d, b, v) {
      for (; v; ++b)
        d[b] = v, v >>>= 8;
    };
    gzh = function(c, o) {
      var fn = o.filename;
      c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
      if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
      if (fn) {
        c[3] = 8;
        for (var i = 0; i <= fn.length; ++i)
          c[i + 10] = fn.charCodeAt(i);
      }
    };
    gzs = function(d) {
      if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        throw "invalid gzip data";
      var flg = d[3];
      var st = 10;
      if (flg & 4)
        st += d[10] | (d[11] << 8) + 2;
      for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
      return st + (flg & 2);
    };
    gzl = function(d) {
      var l = d.length;
      return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
    };
    gzhl = function(o) {
      return 10 + (o.filename && o.filename.length + 1 || 0);
    };
    zlh = function(c, o) {
      var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
    };
    zlv = function(d) {
      if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        throw "invalid zlib data";
      if (d[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported";
    };
    Deflate = function() {
      function Deflate2(opts, cb) {
        if (!cb && typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
      }
      Deflate2.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, !f), f);
      };
      Deflate2.prototype.push = function(chunk, final) {
        if (this.d)
          throw "stream finished";
        if (!this.ondata)
          throw "no stream handler";
        this.d = final;
        this.p(chunk, final || false);
      };
      return Deflate2;
    }();
    AsyncDeflate = function() {
      function AsyncDeflate2(opts, cb) {
        astrmify([
          bDflt,
          function() {
            return [astrm, Deflate];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Deflate(ev.data);
          onmessage = astrm(strm);
        }, 6);
      }
      return AsyncDeflate2;
    }();
    Inflate = function() {
      function Inflate2(cb) {
        this.s = {};
        this.p = new u8(0);
        this.ondata = cb;
      }
      Inflate2.prototype.e = function(c) {
        if (this.d)
          throw "stream finished";
        if (!this.ondata)
          throw "no stream handler";
        var l = this.p.length;
        var n = new u8(l + c.length);
        n.set(this.p), n.set(c, l), this.p = n;
      };
      Inflate2.prototype.c = function(final) {
        this.d = this.s.i = final || false;
        var bts = this.s.b;
        var dt = inflt(this.p, this.o, this.s);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      };
      Inflate2.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
      };
      return Inflate2;
    }();
    AsyncInflate = function() {
      function AsyncInflate2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          function() {
            return [astrm, Inflate];
          }
        ], this, 0, function() {
          var strm = new Inflate();
          onmessage = astrm(strm);
        }, 7);
      }
      return AsyncInflate2;
    }();
    Gzip = function() {
      function Gzip2(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Gzip2.prototype.push = function(chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
      };
      Gzip2.prototype.p = function(c, f) {
        this.c.p(c);
        this.l += c.length;
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
        if (this.v)
          gzh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
      };
      return Gzip2;
    }();
    AsyncGzip = function() {
      function AsyncGzip2(opts, cb) {
        astrmify([
          bDflt,
          gze,
          function() {
            return [astrm, Deflate, Gzip];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Gzip(ev.data);
          onmessage = astrm(strm);
        }, 8);
      }
      return AsyncGzip2;
    }();
    Gunzip = function() {
      function Gunzip2(cb) {
        this.v = 1;
        Inflate.call(this, cb);
      }
      Gunzip2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          var s = this.p.length > 3 ? gzs(this.p) : 4;
          if (s >= this.p.length && !final)
            return;
          this.p = this.p.subarray(s), this.v = 0;
        }
        if (final) {
          if (this.p.length < 8)
            throw "invalid gzip stream";
          this.p = this.p.subarray(0, -8);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Gunzip2;
    }();
    AsyncGunzip = function() {
      function AsyncGunzip2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          guze,
          function() {
            return [astrm, Inflate, Gunzip];
          }
        ], this, 0, function() {
          var strm = new Gunzip();
          onmessage = astrm(strm);
        }, 9);
      }
      return AsyncGunzip2;
    }();
    Zlib = function() {
      function Zlib2(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Zlib2.prototype.push = function(chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
      };
      Zlib2.prototype.p = function(c, f) {
        this.c.p(c);
        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
        if (this.v)
          zlh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
      };
      return Zlib2;
    }();
    AsyncZlib = function() {
      function AsyncZlib2(opts, cb) {
        astrmify([
          bDflt,
          zle,
          function() {
            return [astrm, Deflate, Zlib];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Zlib(ev.data);
          onmessage = astrm(strm);
        }, 10);
      }
      return AsyncZlib2;
    }();
    Unzlib = function() {
      function Unzlib2(cb) {
        this.v = 1;
        Inflate.call(this, cb);
      }
      Unzlib2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          if (this.p.length < 2 && !final)
            return;
          this.p = this.p.subarray(2), this.v = 0;
        }
        if (final) {
          if (this.p.length < 4)
            throw "invalid zlib stream";
          this.p = this.p.subarray(0, -4);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Unzlib2;
    }();
    AsyncUnzlib = function() {
      function AsyncUnzlib2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          zule,
          function() {
            return [astrm, Inflate, Unzlib];
          }
        ], this, 0, function() {
          var strm = new Unzlib();
          onmessage = astrm(strm);
        }, 11);
      }
      return AsyncUnzlib2;
    }();
    Decompress = function() {
      function Decompress2(cb) {
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
        this.ondata = cb;
      }
      Decompress2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          throw "no stream handler";
        if (!this.s) {
          if (this.p && this.p.length) {
            var n = new u8(this.p.length + chunk.length);
            n.set(this.p), n.set(chunk, this.p.length);
          } else
            this.p = chunk;
          if (this.p.length > 2) {
            var _this_1 = this;
            var cb = function() {
              _this_1.ondata.apply(_this_1, arguments);
            };
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
            this.s.push(this.p, final);
            this.p = null;
          }
        } else
          this.s.push(chunk, final);
      };
      return Decompress2;
    }();
    AsyncDecompress = function() {
      function AsyncDecompress2(cb) {
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
        this.ondata = cb;
      }
      AsyncDecompress2.prototype.push = function(chunk, final) {
        Decompress.prototype.push.call(this, chunk, final);
      };
      return AsyncDecompress2;
    }();
    te = typeof TextEncoder != "undefined" && new TextEncoder();
    td = typeof TextDecoder != "undefined" && new TextDecoder();
    tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e) {
    }
    dutf8 = function(d) {
      for (var r = "", i = 0; ; ) {
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length)
          return [r, slc(d, i - 1)];
        if (!eb)
          r += String.fromCharCode(c);
        else if (eb == 3) {
          c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1)
          r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
        else
          r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
      }
    };
    DecodeUTF8 = function() {
      function DecodeUTF82(cb) {
        this.ondata = cb;
        if (tds)
          this.t = new TextDecoder();
        else
          this.p = et;
      }
      DecodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          throw "no callback";
        final = !!final;
        if (this.t) {
          this.ondata(this.t.decode(chunk, { stream: true }), final);
          if (final) {
            if (this.t.decode().length)
              throw "invalid utf-8 data";
            this.t = null;
          }
          return;
        }
        if (!this.p)
          throw "stream finished";
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a2 = dutf8(dat), ch3 = _a2[0], np = _a2[1];
        if (final) {
          if (np.length)
            throw "invalid utf-8 data";
          this.p = null;
        } else
          this.p = np;
        this.ondata(ch3, final);
      };
      return DecodeUTF82;
    }();
    EncodeUTF8 = function() {
      function EncodeUTF82(cb) {
        this.ondata = cb;
      }
      EncodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          throw "no callback";
        if (this.d)
          throw "stream finished";
        this.ondata(strToU8(chunk), this.d = final || false);
      };
      return EncodeUTF82;
    }();
    dbf = function(l) {
      return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    z64e = function(d, b) {
      for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
      return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
    };
    exfl = function(ex) {
      var le = 0;
      if (ex) {
        for (var k in ex) {
          var l = ex[k].length;
          if (l > 65535)
            throw "extra field too long";
          le += l + 4;
        }
      }
      return le;
    };
    wzh = function(d, b, f, fn, u, c, ce, co) {
      var fl2 = fn.length, ex = f.extra, col = co && co.length;
      var exl = exfl(ex);
      wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
      if (ce != null)
        d[b++] = 20, d[b++] = f.os;
      d[b] = 20, b += 2;
      d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
      d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
      var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
      if (y < 0 || y > 119)
        throw "date not in range 1980-2099";
      wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;
      if (c != null) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c);
        wbytes(d, b + 8, f.size);
      }
      wbytes(d, b + 12, fl2);
      wbytes(d, b + 14, exl), b += 16;
      if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
      }
      d.set(fn, b);
      b += fl2;
      if (exl) {
        for (var k in ex) {
          var exf = ex[k], l = exf.length;
          wbytes(d, b, +k);
          wbytes(d, b + 2, l);
          d.set(exf, b + 4), b += 4 + l;
        }
      }
      if (col)
        d.set(co, b), b += col;
      return b;
    };
    wzf = function(o, b, c, d, e) {
      wbytes(o, b, 101010256);
      wbytes(o, b + 8, c);
      wbytes(o, b + 10, c);
      wbytes(o, b + 12, d);
      wbytes(o, b + 16, e);
    };
    ZipPassThrough = function() {
      function ZipPassThrough2(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
      }
      ZipPassThrough2.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
      };
      ZipPassThrough2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          throw "no callback - add to ZIP archive before pushing";
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
          this.crc = this.c.d();
        this.process(chunk, final || false);
      };
      return ZipPassThrough2;
    }();
    ZipDeflate = function() {
      function ZipDeflate2(filename, opts) {
        var _this_1 = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
          _this_1.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
      }
      ZipDeflate2.prototype.process = function(chunk, final) {
        try {
          this.d.push(chunk, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      ZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return ZipDeflate2;
    }();
    AsyncZipDeflate = function() {
      function AsyncZipDeflate2(filename, opts) {
        var _this_1 = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err, dat, final) {
          _this_1.ondata(err, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
      }
      AsyncZipDeflate2.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
      };
      AsyncZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return AsyncZipDeflate2;
    }();
    Zip = function() {
      function Zip2(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
      }
      Zip2.prototype.add = function(file) {
        var _this_1 = this;
        if (this.d & 2)
          throw "stream finished";
        var f = strToU8(file.filename), fl2 = f.length;
        var com = file.comment, o = com && strToU8(com);
        var u = fl2 != file.filename.length || o && com.length != o.length;
        var hl = fl2 + exfl(file.extra) + 30;
        if (fl2 > 65535)
          throw "filename too long";
        var header = new u8(hl);
        wzh(header, 0, file, f, u);
        var chks = [header];
        var pAll = function() {
          for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
            var chk = chks_1[_i];
            _this_1.ondata(null, chk, false);
          }
          chks = [];
        };
        var tr = this.d;
        this.d = 0;
        var ind = this.u.length;
        var uf = mrg(file, {
          f,
          u,
          o,
          t: function() {
            if (file.terminate)
              file.terminate();
          },
          r: function() {
            pAll();
            if (tr) {
              var nxt = _this_1.u[ind + 1];
              if (nxt)
                nxt.r();
              else
                _this_1.d = 1;
            }
            tr = 1;
          }
        });
        var cl = 0;
        file.ondata = function(err, dat, final) {
          if (err) {
            _this_1.ondata(err, dat, final);
            _this_1.terminate();
          } else {
            cl += dat.length;
            chks.push(dat);
            if (final) {
              var dd = new u8(16);
              wbytes(dd, 0, 134695760);
              wbytes(dd, 4, file.crc);
              wbytes(dd, 8, cl);
              wbytes(dd, 12, file.size);
              chks.push(dd);
              uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
              if (tr)
                uf.r();
              tr = 1;
            } else if (tr)
              pAll();
          }
        };
        this.u.push(uf);
      };
      Zip2.prototype.end = function() {
        var _this_1 = this;
        if (this.d & 2) {
          if (this.d & 1)
            throw "stream finishing";
          throw "stream finished";
        }
        if (this.d)
          this.e();
        else
          this.u.push({
            r: function() {
              if (!(_this_1.d & 1))
                return;
              _this_1.u.splice(-1, 1);
              _this_1.e();
            },
            t: function() {
            }
          });
        this.d = 3;
      };
      Zip2.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
          var f = _c[_b2];
          wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
          bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
      };
      Zip2.prototype.terminate = function() {
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          f.t();
        }
        this.d = 2;
      };
      return Zip2;
    }();
    UnzipPassThrough = function() {
      function UnzipPassThrough2() {
      }
      UnzipPassThrough2.prototype.push = function(data, final) {
        this.ondata(null, data, final);
      };
      UnzipPassThrough2.compression = 0;
      return UnzipPassThrough2;
    }();
    UnzipInflate = function() {
      function UnzipInflate2() {
        var _this_1 = this;
        this.i = new Inflate(function(dat, final) {
          _this_1.ondata(null, dat, final);
        });
      }
      UnzipInflate2.prototype.push = function(data, final) {
        try {
          this.i.push(data, final);
        } catch (e) {
          this.ondata(e, data, final);
        }
      };
      UnzipInflate2.compression = 8;
      return UnzipInflate2;
    }();
    AsyncUnzipInflate = function() {
      function AsyncUnzipInflate2(_, sz) {
        var _this_1 = this;
        if (sz < 32e4) {
          this.i = new Inflate(function(dat, final) {
            _this_1.ondata(null, dat, final);
          });
        } else {
          this.i = new AsyncInflate(function(err, dat, final) {
            _this_1.ondata(err, dat, final);
          });
          this.terminate = this.i.terminate;
        }
      }
      AsyncUnzipInflate2.prototype.push = function(data, final) {
        if (this.i.terminate)
          data = slc(data, 0);
        this.i.push(data, final);
      };
      AsyncUnzipInflate2.compression = 8;
      return AsyncUnzipInflate2;
    }();
    Unzip = function() {
      function Unzip2(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
          0: UnzipPassThrough
        };
        this.p = et;
      }
      Unzip2.prototype.push = function(chunk, final) {
        var _this_1 = this;
        if (!this.onfile)
          throw "no callback";
        if (!this.p)
          throw "stream finished";
        if (this.c > 0) {
          var len = Math.min(this.c, chunk.length);
          var toAdd = chunk.subarray(0, len);
          this.c -= len;
          if (this.d)
            this.d.push(toAdd, !this.c);
          else
            this.k[0].push(toAdd);
          chunk = chunk.subarray(len);
          if (chunk.length)
            return this.push(chunk, final);
        } else {
          var f = 0, i = 0, is = void 0, buf = void 0;
          if (!this.p.length)
            buf = chunk;
          else if (!chunk.length)
            buf = this.p;
          else {
            buf = new u8(this.p.length + chunk.length);
            buf.set(this.p), buf.set(chunk, this.p.length);
          }
          var l = buf.length, oc = this.c, add = oc && this.d;
          var _loop_2 = function() {
            var _a2;
            var sig = b4(buf, i);
            if (sig == 67324752) {
              f = 1, is = i;
              this_1.d = null;
              this_1.c = 0;
              var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
              if (l > i + 30 + fnl + es) {
                var chks_2 = [];
                this_1.k.unshift(chks_2);
                f = 2;
                var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                if (sc_1 == 4294967295) {
                  _a2 = dd ? [-2] : z64e(buf, i), sc_1 = _a2[0], su_1 = _a2[1];
                } else if (dd)
                  sc_1 = -1;
                i += es;
                this_1.c = sc_1;
                var d_1;
                var file_1 = {
                  name: fn_1,
                  compression: cmp_1,
                  start: function() {
                    if (!file_1.ondata)
                      throw "no callback";
                    if (!sc_1)
                      file_1.ondata(null, et, true);
                    else {
                      var ctr = _this_1.o[cmp_1];
                      if (!ctr)
                        throw "unknown compression type " + cmp_1;
                      d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                      d_1.ondata = function(err, dat3, final2) {
                        file_1.ondata(err, dat3, final2);
                      };
                      for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                        var dat2 = chks_3[_i];
                        d_1.push(dat2, false);
                      }
                      if (_this_1.k[0] == chks_2 && _this_1.c)
                        _this_1.d = d_1;
                      else
                        d_1.push(et, true);
                    }
                  },
                  terminate: function() {
                    if (d_1 && d_1.terminate)
                      d_1.terminate();
                  }
                };
                if (sc_1 >= 0)
                  file_1.size = sc_1, file_1.originalSize = su_1;
                this_1.onfile(file_1);
              }
              return "break";
            } else if (oc) {
              if (sig == 134695760) {
                is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                return "break";
              } else if (sig == 33639248) {
                is = i -= 4, f = 3, this_1.c = 0;
                return "break";
              }
            }
          };
          var this_1 = this;
          for (; i < l - 4; ++i) {
            var state_1 = _loop_2();
            if (state_1 === "break")
              break;
          }
          this.p = et;
          if (oc < 0) {
            var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
            if (add)
              add.push(dat, !!f);
            else
              this.k[+(f == 2)].push(dat);
          }
          if (f & 2)
            return this.push(buf.subarray(i), final);
          this.p = buf.subarray(i);
        }
        if (final) {
          if (this.c)
            throw "invalid zip file";
          this.p = null;
        }
      };
      Unzip2.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
      };
      return Unzip2;
    }();
  }
});

// node_modules/three/examples/jsm/curves/NURBSUtils.js
function findSpan(p, u, U) {
  const n = U.length - p - 1;
  if (u >= U[n]) {
    return n - 1;
  }
  if (u <= U[p]) {
    return p;
  }
  let low = p;
  let high = n;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u, p, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint(p, U, P, u) {
  const span = findSpan(p, u, U);
  const N = calcBasisFunctions(span, u, p, U);
  const C = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p; ++j) {
    const point = P[span - p + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C.x += point.x * wNj;
    C.y += point.y * wNj;
    C.z += point.z * wNj;
    C.w += point.w * Nj;
  }
  return C;
}
function calcBasisFunctionDerivatives(span, u, p, n, U) {
  const zeroArr = [];
  for (let i = 0; i <= p; ++i)
    zeroArr[i] = 0;
  const ders = [];
  for (let i = 0; i <= n; ++i)
    ders[i] = zeroArr.slice(0);
  const ndu = [];
  for (let i = 0; i <= p; ++i)
    ndu[i] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p; ++j) {
    ders[0][j] = ndu[j][p];
  }
  for (let r2 = 0; r2 <= p; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a = [];
    for (let i = 0; i <= p; ++i) {
      a[i] = zeroArr.slice(0);
    }
    a[0][0] = 1;
    for (let k = 1; k <= n; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p - k;
      if (r2 >= k) {
        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        d = a[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
        d += a[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p;
  for (let k = 1; k <= n; ++k) {
    for (let j = 0; j <= p; ++j) {
      ders[k][j] *= r;
    }
    r *= p - k;
  }
  return ders;
}
function calcBSplineDerivatives(p, U, P, u, nd) {
  const du = nd < p ? nd : p;
  const CK = [];
  const span = findSpan(p, u, U);
  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);
  const Pw = [];
  for (let i = 0; i < P.length; ++i) {
    const point = P[i].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p; ++j) {
      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i = 0; i < nd; ++i) {
    const point = Pders[i];
    Aders[i] = new Vector3(point.x, point.y, point.z);
    wders[i] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v = Aders[k].clone();
    for (let i = 1; i <= k; ++i) {
      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
    }
    CK[k] = v.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p, U, P, u, nd) {
  const Pders = calcBSplineDerivatives(p, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}
var init_NURBSUtils = __esm({
  "node_modules/three/examples/jsm/curves/NURBSUtils.js"() {
    init_three_module();
  }
});

// node_modules/three/examples/jsm/curves/NURBSCurve.js
var NURBSCurve;
var init_NURBSCurve = __esm({
  "node_modules/three/examples/jsm/curves/NURBSCurve.js"() {
    init_three_module();
    init_NURBSUtils();
    NURBSCurve = class extends Curve {
      constructor(degree, knots, controlPoints, startKnot, endKnot) {
        super();
        this.degree = degree;
        this.knots = knots;
        this.controlPoints = [];
        this.startKnot = startKnot || 0;
        this.endKnot = endKnot || this.knots.length - 1;
        for (let i = 0; i < controlPoints.length; ++i) {
          const point = controlPoints[i];
          this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
        }
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);
        const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
        if (hpoint.w !== 1) {
          hpoint.divideScalar(hpoint.w);
        }
        return point.set(hpoint.x, hpoint.y, hpoint.z);
      }
      getTangent(t, optionalTarget = new Vector3()) {
        const tangent = optionalTarget;
        const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
        const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
        tangent.copy(ders[1]).normalize();
        return tangent;
      }
    };
  }
});

// node_modules/three/examples/jsm/loaders/FBXLoader.js
var FBXLoader_exports = {};
__export(FBXLoader_exports, {
  FBXLoader: () => FBXLoader
});
function isFbxFormatBinary(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);
    if (num === CORRECT[i]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect")
    index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation)
    lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale)
    lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset)
    lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot)
    lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset)
    lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot)
    lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer, from, to) {
  if (from === void 0)
    from = 0;
  if (to === void 0)
    to = buffer.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer, from, to));
}
function append(a, b) {
  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}
function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }
  return a;
}
function inject(a1, index, a2) {
  return a1.slice(0, index).concat(a2).concat(a1.slice(index));
}
var fbxTree, connections, sceneGraph, FBXLoader, FBXTreeParser, GeometryParser, AnimationParser, TextParser, BinaryParser, BinaryReader, FBXTree, dataArray, tempEuler, tempVec;
var init_FBXLoader = __esm({
  "node_modules/three/examples/jsm/loaders/FBXLoader.js"() {
    init_three_module();
    init_fflate_module();
    init_NURBSCurve();
    FBXLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
        const loader = new FileLoader(this.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
          try {
            onLoad(scope.parse(buffer, path));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(FBXBuffer, path) {
        if (isFbxFormatBinary(FBXBuffer)) {
          fbxTree = new BinaryParser().parse(FBXBuffer);
        } else {
          const FBXText = convertArrayBufferToString(FBXBuffer);
          if (!isFbxFormatASCII(FBXText)) {
            throw new Error("THREE.FBXLoader: Unknown format.");
          }
          if (getFbxVersion(FBXText) < 7e3) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
          }
          fbxTree = new TextParser().parse(FBXText);
        }
        const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
      }
    };
    FBXTreeParser = class {
      constructor(textureLoader, manager) {
        this.textureLoader = textureLoader;
        this.manager = manager;
      }
      parse() {
        connections = this.parseConnections();
        const images = this.parseImages();
        const textures = this.parseTextures(images);
        const materials = this.parseMaterials(textures);
        const deformers = this.parseDeformers();
        const geometryMap = new GeometryParser().parse(deformers);
        this.parseScene(deformers, geometryMap, materials);
        return sceneGraph;
      }
      // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
      // and details the connection type
      parseConnections() {
        const connectionMap = /* @__PURE__ */ new Map();
        if ("Connections" in fbxTree) {
          const rawConnections = fbxTree.Connections.connections;
          rawConnections.forEach(function(rawConnection) {
            const fromID = rawConnection[0];
            const toID = rawConnection[1];
            const relationship = rawConnection[2];
            if (!connectionMap.has(fromID)) {
              connectionMap.set(fromID, {
                parents: [],
                children: []
              });
            }
            const parentRelationship = { ID: toID, relationship };
            connectionMap.get(fromID).parents.push(parentRelationship);
            if (!connectionMap.has(toID)) {
              connectionMap.set(toID, {
                parents: [],
                children: []
              });
            }
            const childRelationship = { ID: fromID, relationship };
            connectionMap.get(toID).children.push(childRelationship);
          });
        }
        return connectionMap;
      }
      // Parse FBXTree.Objects.Video for embedded image data
      // These images are connected to textures in FBXTree.Objects.Textures
      // via FBXTree.Connections.
      parseImages() {
        const images = {};
        const blobs = {};
        if ("Video" in fbxTree.Objects) {
          const videoNodes = fbxTree.Objects.Video;
          for (const nodeID in videoNodes) {
            const videoNode = videoNodes[nodeID];
            const id = parseInt(nodeID);
            images[id] = videoNode.RelativeFilename || videoNode.Filename;
            if ("Content" in videoNode) {
              const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
              const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
              if (arrayBufferContent || base64Content) {
                const image = this.parseImage(videoNodes[nodeID]);
                blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
              }
            }
          }
        }
        for (const id in images) {
          const filename = images[id];
          if (blobs[filename] !== void 0)
            images[id] = blobs[filename];
          else
            images[id] = images[id].split("\\").pop();
        }
        return images;
      }
      // Parse embedded image data in FBXTree.Video.Content
      parseImage(videoNode) {
        const content = videoNode.Content;
        const fileName = videoNode.RelativeFilename || videoNode.Filename;
        const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
        let type;
        switch (extension) {
          case "bmp":
            type = "image/bmp";
            break;
          case "jpg":
          case "jpeg":
            type = "image/jpeg";
            break;
          case "png":
            type = "image/png";
            break;
          case "tif":
            type = "image/tiff";
            break;
          case "tga":
            if (this.manager.getHandler(".tga") === null) {
              console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
            }
            type = "image/tga";
            break;
          default:
            console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
            return;
        }
        if (typeof content === "string") {
          return "data:" + type + ";base64," + content;
        } else {
          const array = new Uint8Array(content);
          return window.URL.createObjectURL(new Blob([array], { type }));
        }
      }
      // Parse nodes in FBXTree.Objects.Texture
      // These contain details such as UV scaling, cropping, rotation etc and are connected
      // to images in FBXTree.Objects.Video
      parseTextures(images) {
        const textureMap = /* @__PURE__ */ new Map();
        if ("Texture" in fbxTree.Objects) {
          const textureNodes = fbxTree.Objects.Texture;
          for (const nodeID in textureNodes) {
            const texture = this.parseTexture(textureNodes[nodeID], images);
            textureMap.set(parseInt(nodeID), texture);
          }
        }
        return textureMap;
      }
      // Parse individual node in FBXTree.Objects.Texture
      parseTexture(textureNode, images) {
        const texture = this.loadTexture(textureNode, images);
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        const wrapModeU = textureNode.WrapModeU;
        const wrapModeV = textureNode.WrapModeV;
        const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
        const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
        texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        if ("Scaling" in textureNode) {
          const values = textureNode.Scaling.value;
          texture.repeat.x = values[0];
          texture.repeat.y = values[1];
        }
        if ("Translation" in textureNode) {
          const values = textureNode.Translation.value;
          texture.offset.x = values[0];
          texture.offset.y = values[1];
        }
        return texture;
      }
      // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
      loadTexture(textureNode, images) {
        let fileName;
        const currentPath = this.textureLoader.path;
        const children = connections.get(textureNode.id).children;
        if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
          fileName = images[children[0].ID];
          if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
            this.textureLoader.setPath(void 0);
          }
        }
        let texture;
        const extension = textureNode.FileName.slice(-3).toLowerCase();
        if (extension === "tga") {
          const loader = this.manager.getHandler(".tga");
          if (loader === null) {
            console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            loader.setPath(this.textureLoader.path);
            texture = loader.load(fileName);
          }
        } else if (extension === "psd") {
          console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
          texture = new Texture();
        } else {
          texture = this.textureLoader.load(fileName);
        }
        this.textureLoader.setPath(currentPath);
        return texture;
      }
      // Parse nodes in FBXTree.Objects.Material
      parseMaterials(textureMap) {
        const materialMap = /* @__PURE__ */ new Map();
        if ("Material" in fbxTree.Objects) {
          const materialNodes = fbxTree.Objects.Material;
          for (const nodeID in materialNodes) {
            const material = this.parseMaterial(materialNodes[nodeID], textureMap);
            if (material !== null)
              materialMap.set(parseInt(nodeID), material);
          }
        }
        return materialMap;
      }
      // Parse single node in FBXTree.Objects.Material
      // Materials are connected to texture maps in FBXTree.Objects.Textures
      // FBX format currently only supports Lambert and Phong shading models
      parseMaterial(materialNode, textureMap) {
        const ID = materialNode.id;
        const name = materialNode.attrName;
        let type = materialNode.ShadingModel;
        if (typeof type === "object") {
          type = type.value;
        }
        if (!connections.has(ID))
          return null;
        const parameters = this.parseParameters(materialNode, textureMap, ID);
        let material;
        switch (type.toLowerCase()) {
          case "phong":
            material = new MeshPhongMaterial();
            break;
          case "lambert":
            material = new MeshLambertMaterial();
            break;
          default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
            material = new MeshPhongMaterial();
            break;
        }
        material.setValues(parameters);
        material.name = name;
        return material;
      }
      // Parse FBX material and return parameters suitable for a three.js material
      // Also parse the texture map and return any textures associated with the material
      parseParameters(materialNode, textureMap, ID) {
        const parameters = {};
        if (materialNode.BumpFactor) {
          parameters.bumpScale = materialNode.BumpFactor.value;
        }
        if (materialNode.Diffuse) {
          parameters.color = new Color().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();
        } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
          parameters.color = new Color().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();
        }
        if (materialNode.DisplacementFactor) {
          parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        if (materialNode.Emissive) {
          parameters.emissive = new Color().fromArray(materialNode.Emissive.value).convertSRGBToLinear();
        } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
          parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();
        }
        if (materialNode.EmissiveFactor) {
          parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
        }
        if (materialNode.Opacity) {
          parameters.opacity = parseFloat(materialNode.Opacity.value);
        }
        if (parameters.opacity < 1) {
          parameters.transparent = true;
        }
        if (materialNode.ReflectionFactor) {
          parameters.reflectivity = materialNode.ReflectionFactor.value;
        }
        if (materialNode.Shininess) {
          parameters.shininess = materialNode.Shininess.value;
        }
        if (materialNode.Specular) {
          parameters.specular = new Color().fromArray(materialNode.Specular.value).convertSRGBToLinear();
        } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
          parameters.specular = new Color().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();
        }
        const scope = this;
        connections.get(ID).children.forEach(function(child) {
          const type = child.relationship;
          switch (type) {
            case "Bump":
              parameters.bumpMap = scope.getTexture(textureMap, child.ID);
              break;
            case "Maya|TEX_ao_map":
              parameters.aoMap = scope.getTexture(textureMap, child.ID);
              break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
              parameters.map = scope.getTexture(textureMap, child.ID);
              if (parameters.map !== void 0) {
                parameters.map.encoding = sRGBEncoding;
              }
              break;
            case "DisplacementColor":
              parameters.displacementMap = scope.getTexture(textureMap, child.ID);
              break;
            case "EmissiveColor":
              parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
              if (parameters.emissiveMap !== void 0) {
                parameters.emissiveMap.encoding = sRGBEncoding;
              }
              break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
              parameters.normalMap = scope.getTexture(textureMap, child.ID);
              break;
            case "ReflectionColor":
              parameters.envMap = scope.getTexture(textureMap, child.ID);
              if (parameters.envMap !== void 0) {
                parameters.envMap.mapping = EquirectangularReflectionMapping;
                parameters.envMap.encoding = sRGBEncoding;
              }
              break;
            case "SpecularColor":
              parameters.specularMap = scope.getTexture(textureMap, child.ID);
              if (parameters.specularMap !== void 0) {
                parameters.specularMap.encoding = sRGBEncoding;
              }
              break;
            case "TransparentColor":
            case "TransparencyFactor":
              parameters.alphaMap = scope.getTexture(textureMap, child.ID);
              parameters.transparent = true;
              break;
            case "AmbientColor":
            case "ShininessExponent":
            case "SpecularFactor":
            case "VectorDisplacementColor":
            default:
              console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
              break;
          }
        });
        return parameters;
      }
      // get a texture from the textureMap for use by a material.
      getTexture(textureMap, id) {
        if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
          console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
          id = connections.get(id).children[0].ID;
        }
        return textureMap.get(id);
      }
      // Parse nodes in FBXTree.Objects.Deformer
      // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
      // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
      parseDeformers() {
        const skeletons = {};
        const morphTargets = {};
        if ("Deformer" in fbxTree.Objects) {
          const DeformerNodes = fbxTree.Objects.Deformer;
          for (const nodeID in DeformerNodes) {
            const deformerNode = DeformerNodes[nodeID];
            const relationships = connections.get(parseInt(nodeID));
            if (deformerNode.attrType === "Skin") {
              const skeleton = this.parseSkeleton(relationships, DeformerNodes);
              skeleton.ID = nodeID;
              if (relationships.parents.length > 1)
                console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
              skeleton.geometryID = relationships.parents[0].ID;
              skeletons[nodeID] = skeleton;
            } else if (deformerNode.attrType === "BlendShape") {
              const morphTarget = {
                id: nodeID
              };
              morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
              morphTarget.id = nodeID;
              if (relationships.parents.length > 1)
                console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
              morphTargets[nodeID] = morphTarget;
            }
          }
        }
        return {
          skeletons,
          morphTargets
        };
      }
      // Parse single nodes in FBXTree.Objects.Deformer
      // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
      // Each skin node represents a skeleton and each cluster node represents a bone
      parseSkeleton(relationships, deformerNodes) {
        const rawBones = [];
        relationships.children.forEach(function(child) {
          const boneNode = deformerNodes[child.ID];
          if (boneNode.attrType !== "Cluster")
            return;
          const rawBone = {
            ID: child.ID,
            indices: [],
            weights: [],
            transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
            // transform: new Matrix4().fromArray( boneNode.Transform.a ),
            // linkMode: boneNode.Mode,
          };
          if ("Indexes" in boneNode) {
            rawBone.indices = boneNode.Indexes.a;
            rawBone.weights = boneNode.Weights.a;
          }
          rawBones.push(rawBone);
        });
        return {
          rawBones,
          bones: []
        };
      }
      // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
      parseMorphTargets(relationships, deformerNodes) {
        const rawMorphTargets = [];
        for (let i = 0; i < relationships.children.length; i++) {
          const child = relationships.children[i];
          const morphTargetNode = deformerNodes[child.ID];
          const rawMorphTarget = {
            name: morphTargetNode.attrName,
            initialWeight: morphTargetNode.DeformPercent,
            id: morphTargetNode.id,
            fullWeights: morphTargetNode.FullWeights.a
          };
          if (morphTargetNode.attrType !== "BlendShapeChannel")
            return;
          rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
            return child2.relationship === void 0;
          })[0].ID;
          rawMorphTargets.push(rawMorphTarget);
        }
        return rawMorphTargets;
      }
      // create the main Group() to be returned by the loader
      parseScene(deformers, geometryMap, materialMap) {
        sceneGraph = new Group();
        const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
        const modelNodes = fbxTree.Objects.Model;
        const scope = this;
        modelMap.forEach(function(model) {
          const modelNode = modelNodes[model.ID];
          scope.setLookAtProperties(model, modelNode);
          const parentConnections = connections.get(model.ID).parents;
          parentConnections.forEach(function(connection) {
            const parent = modelMap.get(connection.ID);
            if (parent !== void 0)
              parent.add(model);
          });
          if (model.parent === null) {
            sceneGraph.add(model);
          }
        });
        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
        this.createAmbientLight();
        sceneGraph.traverse(function(node) {
          if (node.userData.transformData) {
            if (node.parent) {
              node.userData.transformData.parentMatrix = node.parent.matrix;
              node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
            }
            const transform = generateTransform(node.userData.transformData);
            node.applyMatrix4(transform);
            node.updateWorldMatrix();
          }
        });
        const animations = new AnimationParser().parse();
        if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
          sceneGraph.children[0].animations = animations;
          sceneGraph = sceneGraph.children[0];
        }
        sceneGraph.animations = animations;
      }
      // parse nodes in FBXTree.Objects.Model
      parseModels(skeletons, geometryMap, materialMap) {
        const modelMap = /* @__PURE__ */ new Map();
        const modelNodes = fbxTree.Objects.Model;
        for (const nodeID in modelNodes) {
          const id = parseInt(nodeID);
          const node = modelNodes[nodeID];
          const relationships = connections.get(id);
          let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
          if (!model) {
            switch (node.attrType) {
              case "Camera":
                model = this.createCamera(relationships);
                break;
              case "Light":
                model = this.createLight(relationships);
                break;
              case "Mesh":
                model = this.createMesh(relationships, geometryMap, materialMap);
                break;
              case "NurbsCurve":
                model = this.createCurve(relationships, geometryMap);
                break;
              case "LimbNode":
              case "Root":
                model = new Bone();
                break;
              case "Null":
              default:
                model = new Group();
                break;
            }
            model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
            model.ID = id;
          }
          this.getTransformData(model, node);
          modelMap.set(id, model);
        }
        return modelMap;
      }
      buildSkeleton(relationships, skeletons, id, name) {
        let bone = null;
        relationships.parents.forEach(function(parent) {
          for (const ID in skeletons) {
            const skeleton = skeletons[ID];
            skeleton.rawBones.forEach(function(rawBone, i) {
              if (rawBone.ID === parent.ID) {
                const subBone = bone;
                bone = new Bone();
                bone.matrixWorld.copy(rawBone.transformLink);
                bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
                bone.ID = id;
                skeleton.bones[i] = bone;
                if (subBone !== null) {
                  bone.add(subBone);
                }
              }
            });
          }
        });
        return bone;
      }
      // create a PerspectiveCamera or OrthographicCamera
      createCamera(relationships) {
        let model;
        let cameraAttribute;
        relationships.children.forEach(function(child) {
          const attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            cameraAttribute = attr;
          }
        });
        if (cameraAttribute === void 0) {
          model = new Object3D();
        } else {
          let type = 0;
          if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
            type = 1;
          }
          let nearClippingPlane = 1;
          if (cameraAttribute.NearPlane !== void 0) {
            nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
          }
          let farClippingPlane = 1e3;
          if (cameraAttribute.FarPlane !== void 0) {
            farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
          }
          let width = window.innerWidth;
          let height = window.innerHeight;
          if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
            width = cameraAttribute.AspectWidth.value;
            height = cameraAttribute.AspectHeight.value;
          }
          const aspect = width / height;
          let fov = 45;
          if (cameraAttribute.FieldOfView !== void 0) {
            fov = cameraAttribute.FieldOfView.value;
          }
          const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
          switch (type) {
            case 0:
              model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
              if (focalLength !== null)
                model.setFocalLength(focalLength);
              break;
            case 1:
              model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
              model = new Object3D();
              break;
          }
        }
        return model;
      }
      // Create a DirectionalLight, PointLight or SpotLight
      createLight(relationships) {
        let model;
        let lightAttribute;
        relationships.children.forEach(function(child) {
          const attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            lightAttribute = attr;
          }
        });
        if (lightAttribute === void 0) {
          model = new Object3D();
        } else {
          let type;
          if (lightAttribute.LightType === void 0) {
            type = 0;
          } else {
            type = lightAttribute.LightType.value;
          }
          let color = 16777215;
          if (lightAttribute.Color !== void 0) {
            color = new Color().fromArray(lightAttribute.Color.value).convertSRGBToLinear();
          }
          let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
          if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
            intensity = 0;
          }
          let distance = 0;
          if (lightAttribute.FarAttenuationEnd !== void 0) {
            if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
              distance = 0;
            } else {
              distance = lightAttribute.FarAttenuationEnd.value;
            }
          }
          const decay = 1;
          switch (type) {
            case 0:
              model = new PointLight(color, intensity, distance, decay);
              break;
            case 1:
              model = new DirectionalLight(color, intensity);
              break;
            case 2:
              let angle = Math.PI / 3;
              if (lightAttribute.InnerAngle !== void 0) {
                angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
              }
              let penumbra = 0;
              if (lightAttribute.OuterAngle !== void 0) {
                penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
                penumbra = Math.max(penumbra, 1);
              }
              model = new SpotLight(color, intensity, distance, angle, penumbra, decay);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
              model = new PointLight(color, intensity);
              break;
          }
          if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
            model.castShadow = true;
          }
        }
        return model;
      }
      createMesh(relationships, geometryMap, materialMap) {
        let model;
        let geometry = null;
        let material = null;
        const materials = [];
        relationships.children.forEach(function(child) {
          if (geometryMap.has(child.ID)) {
            geometry = geometryMap.get(child.ID);
          }
          if (materialMap.has(child.ID)) {
            materials.push(materialMap.get(child.ID));
          }
        });
        if (materials.length > 1) {
          material = materials;
        } else if (materials.length > 0) {
          material = materials[0];
        } else {
          material = new MeshPhongMaterial({ color: 13421772 });
          materials.push(material);
        }
        if ("color" in geometry.attributes) {
          materials.forEach(function(material2) {
            material2.vertexColors = true;
          });
        }
        if (geometry.FBX_Deformer) {
          model = new SkinnedMesh(geometry, material);
          model.normalizeSkinWeights();
        } else {
          model = new Mesh(geometry, material);
        }
        return model;
      }
      createCurve(relationships, geometryMap) {
        const geometry = relationships.children.reduce(function(geo, child) {
          if (geometryMap.has(child.ID))
            geo = geometryMap.get(child.ID);
          return geo;
        }, null);
        const material = new LineBasicMaterial({ color: 3342591, linewidth: 1 });
        return new Line(geometry, material);
      }
      // parse the model node for transform data
      getTransformData(model, modelNode) {
        const transformData = {};
        if ("InheritType" in modelNode)
          transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("RotationOrder" in modelNode)
          transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        else
          transformData.eulerOrder = "ZYX";
        if ("Lcl_Translation" in modelNode)
          transformData.translation = modelNode.Lcl_Translation.value;
        if ("PreRotation" in modelNode)
          transformData.preRotation = modelNode.PreRotation.value;
        if ("Lcl_Rotation" in modelNode)
          transformData.rotation = modelNode.Lcl_Rotation.value;
        if ("PostRotation" in modelNode)
          transformData.postRotation = modelNode.PostRotation.value;
        if ("Lcl_Scaling" in modelNode)
          transformData.scale = modelNode.Lcl_Scaling.value;
        if ("ScalingOffset" in modelNode)
          transformData.scalingOffset = modelNode.ScalingOffset.value;
        if ("ScalingPivot" in modelNode)
          transformData.scalingPivot = modelNode.ScalingPivot.value;
        if ("RotationOffset" in modelNode)
          transformData.rotationOffset = modelNode.RotationOffset.value;
        if ("RotationPivot" in modelNode)
          transformData.rotationPivot = modelNode.RotationPivot.value;
        model.userData.transformData = transformData;
      }
      setLookAtProperties(model, modelNode) {
        if ("LookAtProperty" in modelNode) {
          const children = connections.get(model.ID).children;
          children.forEach(function(child) {
            if (child.relationship === "LookAtProperty") {
              const lookAtTarget = fbxTree.Objects.Model[child.ID];
              if ("Lcl_Translation" in lookAtTarget) {
                const pos = lookAtTarget.Lcl_Translation.value;
                if (model.target !== void 0) {
                  model.target.position.fromArray(pos);
                  sceneGraph.add(model.target);
                } else {
                  model.lookAt(new Vector3().fromArray(pos));
                }
              }
            }
          });
        }
      }
      bindSkeleton(skeletons, geometryMap, modelMap) {
        const bindMatrices = this.parsePoseNodes();
        for (const ID in skeletons) {
          const skeleton = skeletons[ID];
          const parents = connections.get(parseInt(skeleton.ID)).parents;
          parents.forEach(function(parent) {
            if (geometryMap.has(parent.ID)) {
              const geoID = parent.ID;
              const geoRelationships = connections.get(geoID);
              geoRelationships.parents.forEach(function(geoConnParent) {
                if (modelMap.has(geoConnParent.ID)) {
                  const model = modelMap.get(geoConnParent.ID);
                  model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                }
              });
            }
          });
        }
      }
      parsePoseNodes() {
        const bindMatrices = {};
        if ("Pose" in fbxTree.Objects) {
          const BindPoseNode = fbxTree.Objects.Pose;
          for (const nodeID in BindPoseNode) {
            if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
              const poseNodes = BindPoseNode[nodeID].PoseNode;
              if (Array.isArray(poseNodes)) {
                poseNodes.forEach(function(poseNode) {
                  bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
                });
              } else {
                bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
              }
            }
          }
        }
        return bindMatrices;
      }
      // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
      createAmbientLight() {
        if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
          const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
          const r = ambientColor[0];
          const g = ambientColor[1];
          const b = ambientColor[2];
          if (r !== 0 || g !== 0 || b !== 0) {
            const color = new Color(r, g, b).convertSRGBToLinear();
            sceneGraph.add(new AmbientLight(color, 1));
          }
        }
      }
    };
    GeometryParser = class {
      constructor() {
        this.negativeMaterialIndices = false;
      }
      // Parse nodes in FBXTree.Objects.Geometry
      parse(deformers) {
        const geometryMap = /* @__PURE__ */ new Map();
        if ("Geometry" in fbxTree.Objects) {
          const geoNodes = fbxTree.Objects.Geometry;
          for (const nodeID in geoNodes) {
            const relationships = connections.get(parseInt(nodeID));
            const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
            geometryMap.set(parseInt(nodeID), geo);
          }
        }
        if (this.negativeMaterialIndices === true) {
          console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
        }
        return geometryMap;
      }
      // Parse single node in FBXTree.Objects.Geometry
      parseGeometry(relationships, geoNode, deformers) {
        switch (geoNode.attrType) {
          case "Mesh":
            return this.parseMeshGeometry(relationships, geoNode, deformers);
            break;
          case "NurbsCurve":
            return this.parseNurbsGeometry(geoNode);
            break;
        }
      }
      // Parse single node mesh geometry in FBXTree.Objects.Geometry
      parseMeshGeometry(relationships, geoNode, deformers) {
        const skeletons = deformers.skeletons;
        const morphTargets = [];
        const modelNodes = relationships.parents.map(function(parent) {
          return fbxTree.Objects.Model[parent.ID];
        });
        if (modelNodes.length === 0)
          return;
        const skeleton = relationships.children.reduce(function(skeleton2, child) {
          if (skeletons[child.ID] !== void 0)
            skeleton2 = skeletons[child.ID];
          return skeleton2;
        }, null);
        relationships.children.forEach(function(child) {
          if (deformers.morphTargets[child.ID] !== void 0) {
            morphTargets.push(deformers.morphTargets[child.ID]);
          }
        });
        const modelNode = modelNodes[0];
        const transformData = {};
        if ("RotationOrder" in modelNode)
          transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        if ("InheritType" in modelNode)
          transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("GeometricTranslation" in modelNode)
          transformData.translation = modelNode.GeometricTranslation.value;
        if ("GeometricRotation" in modelNode)
          transformData.rotation = modelNode.GeometricRotation.value;
        if ("GeometricScaling" in modelNode)
          transformData.scale = modelNode.GeometricScaling.value;
        const transform = generateTransform(transformData);
        return this.genGeometry(geoNode, skeleton, morphTargets, transform);
      }
      // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
      genGeometry(geoNode, skeleton, morphTargets, preTransform) {
        const geo = new BufferGeometry();
        if (geoNode.attrName)
          geo.name = geoNode.attrName;
        const geoInfo = this.parseGeoNode(geoNode, skeleton);
        const buffers = this.genBuffers(geoInfo);
        const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
        positionAttribute.applyMatrix4(preTransform);
        geo.setAttribute("position", positionAttribute);
        if (buffers.colors.length > 0) {
          geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
        }
        if (skeleton) {
          geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
          geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
          geo.FBX_Deformer = skeleton;
        }
        if (buffers.normal.length > 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
          const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
          normalAttribute.applyNormalMatrix(normalMatrix);
          geo.setAttribute("normal", normalAttribute);
        }
        buffers.uvs.forEach(function(uvBuffer, i) {
          let name = "uv" + (i + 1).toString();
          if (i === 0) {
            name = "uv";
          }
          geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
        });
        if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
          let prevMaterialIndex = buffers.materialIndex[0];
          let startIndex = 0;
          buffers.materialIndex.forEach(function(currentIndex, i) {
            if (currentIndex !== prevMaterialIndex) {
              geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
              prevMaterialIndex = currentIndex;
              startIndex = i;
            }
          });
          if (geo.groups.length > 0) {
            const lastGroup = geo.groups[geo.groups.length - 1];
            const lastIndex = lastGroup.start + lastGroup.count;
            if (lastIndex !== buffers.materialIndex.length) {
              geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
            }
          }
          if (geo.groups.length === 0) {
            geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
          }
        }
        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
        return geo;
      }
      parseGeoNode(geoNode, skeleton) {
        const geoInfo = {};
        geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
        if (geoNode.LayerElementColor) {
          geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
        }
        if (geoNode.LayerElementMaterial) {
          geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
        }
        if (geoNode.LayerElementNormal) {
          geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
        }
        if (geoNode.LayerElementUV) {
          geoInfo.uv = [];
          let i = 0;
          while (geoNode.LayerElementUV[i]) {
            if (geoNode.LayerElementUV[i].UV) {
              geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
            }
            i++;
          }
        }
        geoInfo.weightTable = {};
        if (skeleton !== null) {
          geoInfo.skeleton = skeleton;
          skeleton.rawBones.forEach(function(rawBone, i) {
            rawBone.indices.forEach(function(index, j) {
              if (geoInfo.weightTable[index] === void 0)
                geoInfo.weightTable[index] = [];
              geoInfo.weightTable[index].push({
                id: i,
                weight: rawBone.weights[j]
              });
            });
          });
        }
        return geoInfo;
      }
      genBuffers(geoInfo) {
        const buffers = {
          vertex: [],
          normal: [],
          colors: [],
          uvs: [],
          materialIndex: [],
          vertexWeights: [],
          weightsIndices: []
        };
        let polygonIndex = 0;
        let faceLength = 0;
        let displayedWeightsWarning = false;
        let facePositionIndexes = [];
        let faceNormals = [];
        let faceColors = [];
        let faceUVs = [];
        let faceWeights = [];
        let faceWeightIndices = [];
        const scope = this;
        geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
          let materialIndex;
          let endOfFace = false;
          if (vertexIndex < 0) {
            vertexIndex = vertexIndex ^ -1;
            endOfFace = true;
          }
          let weightIndices = [];
          let weights = [];
          facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
          if (geoInfo.color) {
            const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
            faceColors.push(data[0], data[1], data[2]);
          }
          if (geoInfo.skeleton) {
            if (geoInfo.weightTable[vertexIndex] !== void 0) {
              geoInfo.weightTable[vertexIndex].forEach(function(wt) {
                weights.push(wt.weight);
                weightIndices.push(wt.id);
              });
            }
            if (weights.length > 4) {
              if (!displayedWeightsWarning) {
                console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                displayedWeightsWarning = true;
              }
              const wIndex = [0, 0, 0, 0];
              const Weight = [0, 0, 0, 0];
              weights.forEach(function(weight, weightIndex) {
                let currentWeight = weight;
                let currentIndex = weightIndices[weightIndex];
                Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                  if (currentWeight > comparedWeight) {
                    comparedWeightArray[comparedWeightIndex] = currentWeight;
                    currentWeight = comparedWeight;
                    const tmp = wIndex[comparedWeightIndex];
                    wIndex[comparedWeightIndex] = currentIndex;
                    currentIndex = tmp;
                  }
                });
              });
              weightIndices = wIndex;
              weights = Weight;
            }
            while (weights.length < 4) {
              weights.push(0);
              weightIndices.push(0);
            }
            for (let i = 0; i < 4; ++i) {
              faceWeights.push(weights[i]);
              faceWeightIndices.push(weightIndices[i]);
            }
          }
          if (geoInfo.normal) {
            const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
            faceNormals.push(data[0], data[1], data[2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
            if (materialIndex < 0) {
              scope.negativeMaterialIndices = true;
              materialIndex = 0;
            }
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, i) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
              if (faceUVs[i] === void 0) {
                faceUVs[i] = [];
              }
              faceUVs[i].push(data[0]);
              faceUVs[i].push(data[1]);
            });
          }
          faceLength++;
          if (endOfFace) {
            if (faceLength > 4)
              console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.");
            scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
            polygonIndex++;
            faceLength = 0;
            facePositionIndexes = [];
            faceNormals = [];
            faceColors = [];
            faceUVs = [];
            faceWeights = [];
            faceWeightIndices = [];
          }
        });
        return buffers;
      }
      // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
      genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
        for (let i = 2; i < faceLength; i++) {
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);
          if (geoInfo.skeleton) {
            buffers.vertexWeights.push(faceWeights[0]);
            buffers.vertexWeights.push(faceWeights[1]);
            buffers.vertexWeights.push(faceWeights[2]);
            buffers.vertexWeights.push(faceWeights[3]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
            buffers.vertexWeights.push(faceWeights[i * 4]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[0]);
            buffers.weightsIndices.push(faceWeightIndices[1]);
            buffers.weightsIndices.push(faceWeightIndices[2]);
            buffers.weightsIndices.push(faceWeightIndices[3]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
          }
          if (geoInfo.color) {
            buffers.colors.push(faceColors[0]);
            buffers.colors.push(faceColors[1]);
            buffers.colors.push(faceColors[2]);
            buffers.colors.push(faceColors[(i - 1) * 3]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
            buffers.colors.push(faceColors[i * 3]);
            buffers.colors.push(faceColors[i * 3 + 1]);
            buffers.colors.push(faceColors[i * 3 + 2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
          }
          if (geoInfo.normal) {
            buffers.normal.push(faceNormals[0]);
            buffers.normal.push(faceNormals[1]);
            buffers.normal.push(faceNormals[2]);
            buffers.normal.push(faceNormals[(i - 1) * 3]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
            buffers.normal.push(faceNormals[i * 3]);
            buffers.normal.push(faceNormals[i * 3 + 1]);
            buffers.normal.push(faceNormals[i * 3 + 2]);
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, j) {
              if (buffers.uvs[j] === void 0)
                buffers.uvs[j] = [];
              buffers.uvs[j].push(faceUVs[j][0]);
              buffers.uvs[j].push(faceUVs[j][1]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
              buffers.uvs[j].push(faceUVs[j][i * 2]);
              buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
            });
          }
        }
      }
      addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
        if (morphTargets.length === 0)
          return;
        parentGeo.morphTargetsRelative = true;
        parentGeo.morphAttributes.position = [];
        const scope = this;
        morphTargets.forEach(function(morphTarget) {
          morphTarget.rawTargets.forEach(function(rawTarget) {
            const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
            if (morphGeoNode !== void 0) {
              scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
            }
          });
        });
      }
      // a morph geometry node is similar to a standard  node, and the node is also contained
      // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
      // and a special attribute Index defining which vertices of the original geometry are affected
      // Normal and position attributes only have data for the vertices that are affected by the morph
      genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
        const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
        const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
        const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
        const length = parentGeo.attributes.position.count * 3;
        const morphPositions = new Float32Array(length);
        for (let i = 0; i < indices.length; i++) {
          const morphIndex = indices[i] * 3;
          morphPositions[morphIndex] = morphPositionsSparse[i * 3];
          morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
          morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
        }
        const morphGeoInfo = {
          vertexIndices,
          vertexPositions: morphPositions
        };
        const morphBuffers = this.genBuffers(morphGeoInfo);
        const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
        positionAttribute.name = name || morphGeoNode.attrName;
        positionAttribute.applyMatrix4(preTransform);
        parentGeo.morphAttributes.position.push(positionAttribute);
      }
      // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
      parseNormals(NormalNode) {
        const mappingType = NormalNode.MappingInformationType;
        const referenceType = NormalNode.ReferenceInformationType;
        const buffer = NormalNode.Normals.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          if ("NormalIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalIndex.a;
          } else if ("NormalsIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalsIndex.a;
          }
        }
        return {
          dataSize: 3,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
      parseUVs(UVNode) {
        const mappingType = UVNode.MappingInformationType;
        const referenceType = UVNode.ReferenceInformationType;
        const buffer = UVNode.UV.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = UVNode.UVIndex.a;
        }
        return {
          dataSize: 2,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
      parseVertexColors(ColorNode) {
        const mappingType = ColorNode.MappingInformationType;
        const referenceType = ColorNode.ReferenceInformationType;
        const buffer = ColorNode.Colors.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = ColorNode.ColorIndex.a;
        }
        for (let i = 0, c = new Color(); i < buffer.length; i += 4) {
          c.fromArray(buffer, i).convertSRGBToLinear().toArray(buffer, i);
        }
        return {
          dataSize: 4,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
      parseMaterialIndices(MaterialNode) {
        const mappingType = MaterialNode.MappingInformationType;
        const referenceType = MaterialNode.ReferenceInformationType;
        if (mappingType === "NoMappingInformation") {
          return {
            dataSize: 1,
            buffer: [0],
            indices: [0],
            mappingType: "AllSame",
            referenceType
          };
        }
        const materialIndexBuffer = MaterialNode.Materials.a;
        const materialIndices = [];
        for (let i = 0; i < materialIndexBuffer.length; ++i) {
          materialIndices.push(i);
        }
        return {
          dataSize: 1,
          buffer: materialIndexBuffer,
          indices: materialIndices,
          mappingType,
          referenceType
        };
      }
      // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
      parseNurbsGeometry(geoNode) {
        const order = parseInt(geoNode.Order);
        if (isNaN(order)) {
          console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
          return new BufferGeometry();
        }
        const degree = order - 1;
        const knots = geoNode.KnotVector.a;
        const controlPoints = [];
        const pointsValues = geoNode.Points.a;
        for (let i = 0, l = pointsValues.length; i < l; i += 4) {
          controlPoints.push(new Vector4().fromArray(pointsValues, i));
        }
        let startKnot, endKnot;
        if (geoNode.Form === "Closed") {
          controlPoints.push(controlPoints[0]);
        } else if (geoNode.Form === "Periodic") {
          startKnot = degree;
          endKnot = knots.length - 1 - startKnot;
          for (let i = 0; i < degree; ++i) {
            controlPoints.push(controlPoints[i]);
          }
        }
        const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
        const points = curve.getPoints(controlPoints.length * 12);
        return new BufferGeometry().setFromPoints(points);
      }
    };
    AnimationParser = class {
      // take raw animation clips and turn them into three.js animation clips
      parse() {
        const animationClips = [];
        const rawClips = this.parseClips();
        if (rawClips !== void 0) {
          for (const key in rawClips) {
            const rawClip = rawClips[key];
            const clip = this.addClip(rawClip);
            animationClips.push(clip);
          }
        }
        return animationClips;
      }
      parseClips() {
        if (fbxTree.Objects.AnimationCurve === void 0)
          return void 0;
        const curveNodesMap = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(curveNodesMap);
        const layersMap = this.parseAnimationLayers(curveNodesMap);
        const rawClips = this.parseAnimStacks(layersMap);
        return rawClips;
      }
      // parse nodes in FBXTree.Objects.AnimationCurveNode
      // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
      // and is referenced by an AnimationLayer
      parseAnimationCurveNodes() {
        const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
        const curveNodesMap = /* @__PURE__ */ new Map();
        for (const nodeID in rawCurveNodes) {
          const rawCurveNode = rawCurveNodes[nodeID];
          if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
            const curveNode = {
              id: rawCurveNode.id,
              attr: rawCurveNode.attrName,
              curves: {}
            };
            curveNodesMap.set(curveNode.id, curveNode);
          }
        }
        return curveNodesMap;
      }
      // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
      // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
      // axis ( e.g. times and values of x rotation)
      parseAnimationCurves(curveNodesMap) {
        const rawCurves = fbxTree.Objects.AnimationCurve;
        for (const nodeID in rawCurves) {
          const animationCurve = {
            id: rawCurves[nodeID].id,
            times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
            values: rawCurves[nodeID].KeyValueFloat.a
          };
          const relationships = connections.get(animationCurve.id);
          if (relationships !== void 0) {
            const animationCurveID = relationships.parents[0].ID;
            const animationCurveRelationship = relationships.parents[0].relationship;
            if (animationCurveRelationship.match(/X/)) {
              curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
            } else if (animationCurveRelationship.match(/Y/)) {
              curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
            } else if (animationCurveRelationship.match(/Z/)) {
              curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
            } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
              curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
            }
          }
        }
      }
      // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
      // to various AnimationCurveNodes and is referenced by an AnimationStack node
      // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
      parseAnimationLayers(curveNodesMap) {
        const rawLayers = fbxTree.Objects.AnimationLayer;
        const layersMap = /* @__PURE__ */ new Map();
        for (const nodeID in rawLayers) {
          const layerCurveNodes = [];
          const connection = connections.get(parseInt(nodeID));
          if (connection !== void 0) {
            const children = connection.children;
            children.forEach(function(child, i) {
              if (curveNodesMap.has(child.ID)) {
                const curveNode = curveNodesMap.get(child.ID);
                if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    const modelID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    if (modelID !== void 0) {
                      const rawModel = fbxTree.Objects.Model[modelID.toString()];
                      if (rawModel === void 0) {
                        console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                        return;
                      }
                      const node = {
                        modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                        ID: rawModel.id,
                        initialPosition: [0, 0, 0],
                        initialRotation: [0, 0, 0],
                        initialScale: [1, 1, 1]
                      };
                      sceneGraph.traverse(function(child2) {
                        if (child2.ID === rawModel.id) {
                          node.transform = child2.matrix;
                          if (child2.userData.transformData)
                            node.eulerOrder = child2.userData.transformData.eulerOrder;
                        }
                      });
                      if (!node.transform)
                        node.transform = new Matrix4();
                      if ("PreRotation" in rawModel)
                        node.preRotation = rawModel.PreRotation.value;
                      if ("PostRotation" in rawModel)
                        node.postRotation = rawModel.PostRotation.value;
                      layerCurveNodes[i] = node;
                    }
                  }
                  if (layerCurveNodes[i])
                    layerCurveNodes[i][curveNode.attr] = curveNode;
                } else if (curveNode.curves.morph !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    const morpherID = connections.get(deformerID).parents[0].ID;
                    const geoID = connections.get(morpherID).parents[0].ID;
                    const modelID = connections.get(geoID).parents[0].ID;
                    const rawModel = fbxTree.Objects.Model[modelID];
                    const node = {
                      modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                      morphName: fbxTree.Objects.Deformer[deformerID].attrName
                    };
                    layerCurveNodes[i] = node;
                  }
                  layerCurveNodes[i][curveNode.attr] = curveNode;
                }
              }
            });
            layersMap.set(parseInt(nodeID), layerCurveNodes);
          }
        }
        return layersMap;
      }
      // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
      // hierarchy. Each Stack node will be used to create a AnimationClip
      parseAnimStacks(layersMap) {
        const rawStacks = fbxTree.Objects.AnimationStack;
        const rawClips = {};
        for (const nodeID in rawStacks) {
          const children = connections.get(parseInt(nodeID)).children;
          if (children.length > 1) {
            console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
          }
          const layer = layersMap.get(children[0].ID);
          rawClips[nodeID] = {
            name: rawStacks[nodeID].attrName,
            layer
          };
        }
        return rawClips;
      }
      addClip(rawClip) {
        let tracks = [];
        const scope = this;
        rawClip.layer.forEach(function(rawTracks) {
          tracks = tracks.concat(scope.generateTracks(rawTracks));
        });
        return new AnimationClip(rawClip.name, -1, tracks);
      }
      generateTracks(rawTracks) {
        const tracks = [];
        let initialPosition = new Vector3();
        let initialRotation = new Quaternion();
        let initialScale = new Vector3();
        if (rawTracks.transform)
          rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
        initialPosition = initialPosition.toArray();
        initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
        initialScale = initialScale.toArray();
        if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
          const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
          if (positionTrack !== void 0)
            tracks.push(positionTrack);
        }
        if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
          const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
          if (rotationTrack !== void 0)
            tracks.push(rotationTrack);
        }
        if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
          const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
          if (scaleTrack !== void 0)
            tracks.push(scaleTrack);
        }
        if (rawTracks.DeformPercent !== void 0) {
          const morphTrack = this.generateMorphTrack(rawTracks);
          if (morphTrack !== void 0)
            tracks.push(morphTrack);
        }
        return tracks;
      }
      generateVectorTrack(modelName, curves, initialValue, type) {
        const times = this.getTimesForAllAxes(curves);
        const values = this.getKeyframeTrackValues(times, curves, initialValue);
        return new VectorKeyframeTrack(modelName + "." + type, times, values);
      }
      generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
        if (curves.x !== void 0) {
          this.interpolateRotations(curves.x);
          curves.x.values = curves.x.values.map(MathUtils.degToRad);
        }
        if (curves.y !== void 0) {
          this.interpolateRotations(curves.y);
          curves.y.values = curves.y.values.map(MathUtils.degToRad);
        }
        if (curves.z !== void 0) {
          this.interpolateRotations(curves.z);
          curves.z.values = curves.z.values.map(MathUtils.degToRad);
        }
        const times = this.getTimesForAllAxes(curves);
        const values = this.getKeyframeTrackValues(times, curves, initialValue);
        if (preRotation !== void 0) {
          preRotation = preRotation.map(MathUtils.degToRad);
          preRotation.push(eulerOrder);
          preRotation = new Euler().fromArray(preRotation);
          preRotation = new Quaternion().setFromEuler(preRotation);
        }
        if (postRotation !== void 0) {
          postRotation = postRotation.map(MathUtils.degToRad);
          postRotation.push(eulerOrder);
          postRotation = new Euler().fromArray(postRotation);
          postRotation = new Quaternion().setFromEuler(postRotation).invert();
        }
        const quaternion = new Quaternion();
        const euler = new Euler();
        const quaternionValues = [];
        for (let i = 0; i < values.length; i += 3) {
          euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
          quaternion.setFromEuler(euler);
          if (preRotation !== void 0)
            quaternion.premultiply(preRotation);
          if (postRotation !== void 0)
            quaternion.multiply(postRotation);
          quaternion.toArray(quaternionValues, i / 3 * 4);
        }
        return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
      }
      generateMorphTrack(rawTracks) {
        const curves = rawTracks.DeformPercent.curves.morph;
        const values = curves.values.map(function(val) {
          return val / 100;
        });
        const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
        return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
      }
      // For all animated objects, times are defined separately for each axis
      // Here we'll combine the times into one sorted array without duplicates
      getTimesForAllAxes(curves) {
        let times = [];
        if (curves.x !== void 0)
          times = times.concat(curves.x.times);
        if (curves.y !== void 0)
          times = times.concat(curves.y.times);
        if (curves.z !== void 0)
          times = times.concat(curves.z.times);
        times = times.sort(function(a, b) {
          return a - b;
        });
        if (times.length > 1) {
          let targetIndex = 1;
          let lastValue = times[0];
          for (let i = 1; i < times.length; i++) {
            const currentValue = times[i];
            if (currentValue !== lastValue) {
              times[targetIndex] = currentValue;
              lastValue = currentValue;
              targetIndex++;
            }
          }
          times = times.slice(0, targetIndex);
        }
        return times;
      }
      getKeyframeTrackValues(times, curves, initialValue) {
        const prevValue = initialValue;
        const values = [];
        let xIndex = -1;
        let yIndex = -1;
        let zIndex = -1;
        times.forEach(function(time) {
          if (curves.x)
            xIndex = curves.x.times.indexOf(time);
          if (curves.y)
            yIndex = curves.y.times.indexOf(time);
          if (curves.z)
            zIndex = curves.z.times.indexOf(time);
          if (xIndex !== -1) {
            const xValue = curves.x.values[xIndex];
            values.push(xValue);
            prevValue[0] = xValue;
          } else {
            values.push(prevValue[0]);
          }
          if (yIndex !== -1) {
            const yValue = curves.y.values[yIndex];
            values.push(yValue);
            prevValue[1] = yValue;
          } else {
            values.push(prevValue[1]);
          }
          if (zIndex !== -1) {
            const zValue = curves.z.values[zIndex];
            values.push(zValue);
            prevValue[2] = zValue;
          } else {
            values.push(prevValue[2]);
          }
        });
        return values;
      }
      // Rotations are defined as Euler angles which can have values  of any size
      // These will be converted to quaternions which don't support values greater than
      // PI, so we'll interpolate large rotations
      interpolateRotations(curve) {
        for (let i = 1; i < curve.values.length; i++) {
          const initialValue = curve.values[i - 1];
          const valuesSpan = curve.values[i] - initialValue;
          const absoluteSpan = Math.abs(valuesSpan);
          if (absoluteSpan >= 180) {
            const numSubIntervals = absoluteSpan / 180;
            const step = valuesSpan / numSubIntervals;
            let nextValue = initialValue + step;
            const initialTime = curve.times[i - 1];
            const timeSpan = curve.times[i] - initialTime;
            const interval = timeSpan / numSubIntervals;
            let nextTime = initialTime + interval;
            const interpolatedTimes = [];
            const interpolatedValues = [];
            while (nextTime < curve.times[i]) {
              interpolatedTimes.push(nextTime);
              nextTime += interval;
              interpolatedValues.push(nextValue);
              nextValue += step;
            }
            curve.times = inject(curve.times, i, interpolatedTimes);
            curve.values = inject(curve.values, i, interpolatedValues);
          }
        }
      }
    };
    TextParser = class {
      getPrevNode() {
        return this.nodeStack[this.currentIndent - 2];
      }
      getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1];
      }
      getCurrentProp() {
        return this.currentProp;
      }
      pushStack(node) {
        this.nodeStack.push(node);
        this.currentIndent += 1;
      }
      popStack() {
        this.nodeStack.pop();
        this.currentIndent -= 1;
      }
      setCurrentProp(val, name) {
        this.currentProp = val;
        this.currentPropName = name;
      }
      parse(text) {
        this.currentIndent = 0;
        this.allNodes = new FBXTree();
        this.nodeStack = [];
        this.currentProp = [];
        this.currentPropName = "";
        const scope = this;
        const split = text.split(/[\r\n]+/);
        split.forEach(function(line, i) {
          const matchComment = line.match(/^[\s\t]*;/);
          const matchEmpty = line.match(/^[\s\t]*$/);
          if (matchComment || matchEmpty)
            return;
          const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
          const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
          const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
          if (matchBeginning) {
            scope.parseNodeBegin(line, matchBeginning);
          } else if (matchProperty) {
            scope.parseNodeProperty(line, matchProperty, split[++i]);
          } else if (matchEnd) {
            scope.popStack();
          } else if (line.match(/^[^\s\t}]/)) {
            scope.parseNodePropertyContinued(line);
          }
        });
        return this.allNodes;
      }
      parseNodeBegin(line, property) {
        const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
        const nodeAttrs = property[2].split(",").map(function(attr) {
          return attr.trim().replace(/^"/, "").replace(/"$/, "");
        });
        const node = { name: nodeName };
        const attrs = this.parseNodeAttr(nodeAttrs);
        const currentNode = this.getCurrentNode();
        if (this.currentIndent === 0) {
          this.allNodes.add(nodeName, node);
        } else {
          if (nodeName in currentNode) {
            if (nodeName === "PoseNode") {
              currentNode.PoseNode.push(node);
            } else if (currentNode[nodeName].id !== void 0) {
              currentNode[nodeName] = {};
              currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
            }
            if (attrs.id !== "")
              currentNode[nodeName][attrs.id] = node;
          } else if (typeof attrs.id === "number") {
            currentNode[nodeName] = {};
            currentNode[nodeName][attrs.id] = node;
          } else if (nodeName !== "Properties70") {
            if (nodeName === "PoseNode")
              currentNode[nodeName] = [node];
            else
              currentNode[nodeName] = node;
          }
        }
        if (typeof attrs.id === "number")
          node.id = attrs.id;
        if (attrs.name !== "")
          node.attrName = attrs.name;
        if (attrs.type !== "")
          node.attrType = attrs.type;
        this.pushStack(node);
      }
      parseNodeAttr(attrs) {
        let id = attrs[0];
        if (attrs[0] !== "") {
          id = parseInt(attrs[0]);
          if (isNaN(id)) {
            id = attrs[0];
          }
        }
        let name = "", type = "";
        if (attrs.length > 1) {
          name = attrs[1].replace(/^(\w+)::/, "");
          type = attrs[2];
        }
        return { id, name, type };
      }
      parseNodeProperty(line, property, contentLine) {
        let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
        let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
        if (propName === "Content" && propValue === ",") {
          propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
        }
        const currentNode = this.getCurrentNode();
        const parentName = currentNode.name;
        if (parentName === "Properties70") {
          this.parseNodeSpecialProperty(line, propName, propValue);
          return;
        }
        if (propName === "C") {
          const connProps = propValue.split(",").slice(1);
          const from = parseInt(connProps[0]);
          const to = parseInt(connProps[1]);
          let rest = propValue.split(",").slice(3);
          rest = rest.map(function(elem) {
            return elem.trim().replace(/^"/, "");
          });
          propName = "connections";
          propValue = [from, to];
          append(propValue, rest);
          if (currentNode[propName] === void 0) {
            currentNode[propName] = [];
          }
        }
        if (propName === "Node")
          currentNode.id = propValue;
        if (propName in currentNode && Array.isArray(currentNode[propName])) {
          currentNode[propName].push(propValue);
        } else {
          if (propName !== "a")
            currentNode[propName] = propValue;
          else
            currentNode.a = propValue;
        }
        this.setCurrentProp(currentNode, propName);
        if (propName === "a" && propValue.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(propValue);
        }
      }
      parseNodePropertyContinued(line) {
        const currentNode = this.getCurrentNode();
        currentNode.a += line;
        if (line.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(currentNode.a);
        }
      }
      // parse "Property70"
      parseNodeSpecialProperty(line, propName, propValue) {
        const props = propValue.split('",').map(function(prop) {
          return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
        });
        const innerPropName = props[0];
        const innerPropType1 = props[1];
        const innerPropType2 = props[2];
        const innerPropFlag = props[3];
        let innerPropValue = props[4];
        switch (innerPropType1) {
          case "int":
          case "enum":
          case "bool":
          case "ULongLong":
          case "double":
          case "Number":
          case "FieldOfView":
            innerPropValue = parseFloat(innerPropValue);
            break;
          case "Color":
          case "ColorRGB":
          case "Vector3D":
          case "Lcl_Translation":
          case "Lcl_Rotation":
          case "Lcl_Scaling":
            innerPropValue = parseNumberArray(innerPropValue);
            break;
        }
        this.getPrevNode()[innerPropName] = {
          "type": innerPropType1,
          "type2": innerPropType2,
          "flag": innerPropFlag,
          "value": innerPropValue
        };
        this.setCurrentProp(this.getPrevNode(), innerPropName);
      }
    };
    BinaryParser = class {
      parse(buffer) {
        const reader = new BinaryReader(buffer);
        reader.skip(23);
        const version = reader.getUint32();
        if (version < 6400) {
          throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
        }
        const allNodes = new FBXTree();
        while (!this.endOfContent(reader)) {
          const node = this.parseNode(reader, version);
          if (node !== null)
            allNodes.add(node.name, node);
        }
        return allNodes;
      }
      // Check if reader has reached the end of content.
      endOfContent(reader) {
        if (reader.size() % 16 === 0) {
          return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
        } else {
          return reader.getOffset() + 160 + 16 >= reader.size();
        }
      }
      // recursively parse nodes until the end of the file is reached
      parseNode(reader, version) {
        const node = {};
        const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
        const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
        version >= 7500 ? reader.getUint64() : reader.getUint32();
        const nameLen = reader.getUint8();
        const name = reader.getString(nameLen);
        if (endOffset === 0)
          return null;
        const propertyList = [];
        for (let i = 0; i < numProperties; i++) {
          propertyList.push(this.parseProperty(reader));
        }
        const id = propertyList.length > 0 ? propertyList[0] : "";
        const attrName = propertyList.length > 1 ? propertyList[1] : "";
        const attrType = propertyList.length > 2 ? propertyList[2] : "";
        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
        while (endOffset > reader.getOffset()) {
          const subNode = this.parseNode(reader, version);
          if (subNode !== null)
            this.parseSubNode(name, node, subNode);
        }
        node.propertyList = propertyList;
        if (typeof id === "number")
          node.id = id;
        if (attrName !== "")
          node.attrName = attrName;
        if (attrType !== "")
          node.attrType = attrType;
        if (name !== "")
          node.name = name;
        return node;
      }
      parseSubNode(name, node, subNode) {
        if (subNode.singleProperty === true) {
          const value = subNode.propertyList[0];
          if (Array.isArray(value)) {
            node[subNode.name] = subNode;
            subNode.a = value;
          } else {
            node[subNode.name] = value;
          }
        } else if (name === "Connections" && subNode.name === "C") {
          const array = [];
          subNode.propertyList.forEach(function(property, i) {
            if (i !== 0)
              array.push(property);
          });
          if (node.connections === void 0) {
            node.connections = [];
          }
          node.connections.push(array);
        } else if (subNode.name === "Properties70") {
          const keys = Object.keys(subNode);
          keys.forEach(function(key) {
            node[key] = subNode[key];
          });
        } else if (name === "Properties70" && subNode.name === "P") {
          let innerPropName = subNode.propertyList[0];
          let innerPropType1 = subNode.propertyList[1];
          const innerPropType2 = subNode.propertyList[2];
          const innerPropFlag = subNode.propertyList[3];
          let innerPropValue;
          if (innerPropName.indexOf("Lcl ") === 0)
            innerPropName = innerPropName.replace("Lcl ", "Lcl_");
          if (innerPropType1.indexOf("Lcl ") === 0)
            innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
          if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
            innerPropValue = [
              subNode.propertyList[4],
              subNode.propertyList[5],
              subNode.propertyList[6]
            ];
          } else {
            innerPropValue = subNode.propertyList[4];
          }
          node[innerPropName] = {
            "type": innerPropType1,
            "type2": innerPropType2,
            "flag": innerPropFlag,
            "value": innerPropValue
          };
        } else if (node[subNode.name] === void 0) {
          if (typeof subNode.id === "number") {
            node[subNode.name] = {};
            node[subNode.name][subNode.id] = subNode;
          } else {
            node[subNode.name] = subNode;
          }
        } else {
          if (subNode.name === "PoseNode") {
            if (!Array.isArray(node[subNode.name])) {
              node[subNode.name] = [node[subNode.name]];
            }
            node[subNode.name].push(subNode);
          } else if (node[subNode.name][subNode.id] === void 0) {
            node[subNode.name][subNode.id] = subNode;
          }
        }
      }
      parseProperty(reader) {
        const type = reader.getString(1);
        let length;
        switch (type) {
          case "C":
            return reader.getBoolean();
          case "D":
            return reader.getFloat64();
          case "F":
            return reader.getFloat32();
          case "I":
            return reader.getInt32();
          case "L":
            return reader.getInt64();
          case "R":
            length = reader.getUint32();
            return reader.getArrayBuffer(length);
          case "S":
            length = reader.getUint32();
            return reader.getString(length);
          case "Y":
            return reader.getInt16();
          case "b":
          case "c":
          case "d":
          case "f":
          case "i":
          case "l":
            const arrayLength = reader.getUint32();
            const encoding = reader.getUint32();
            const compressedLength = reader.getUint32();
            if (encoding === 0) {
              switch (type) {
                case "b":
                case "c":
                  return reader.getBooleanArray(arrayLength);
                case "d":
                  return reader.getFloat64Array(arrayLength);
                case "f":
                  return reader.getFloat32Array(arrayLength);
                case "i":
                  return reader.getInt32Array(arrayLength);
                case "l":
                  return reader.getInt64Array(arrayLength);
              }
            }
            const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
            const reader2 = new BinaryReader(data.buffer);
            switch (type) {
              case "b":
              case "c":
                return reader2.getBooleanArray(arrayLength);
              case "d":
                return reader2.getFloat64Array(arrayLength);
              case "f":
                return reader2.getFloat32Array(arrayLength);
              case "i":
                return reader2.getInt32Array(arrayLength);
              case "l":
                return reader2.getInt64Array(arrayLength);
            }
            break;
          default:
            throw new Error("THREE.FBXLoader: Unknown property type " + type);
        }
      }
    };
    BinaryReader = class {
      constructor(buffer, littleEndian) {
        this.dv = new DataView(buffer);
        this.offset = 0;
        this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
        this._textDecoder = new TextDecoder();
      }
      getOffset() {
        return this.offset;
      }
      size() {
        return this.dv.buffer.byteLength;
      }
      skip(length) {
        this.offset += length;
      }
      // seems like true/false representation depends on exporter.
      // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
      // then sees LSB.
      getBoolean() {
        return (this.getUint8() & 1) === 1;
      }
      getBooleanArray(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getBoolean());
        }
        return a;
      }
      getUint8() {
        const value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
      }
      getInt16() {
        const value = this.dv.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      getInt32() {
        const value = this.dv.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      getInt32Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getInt32());
        }
        return a;
      }
      getUint32() {
        const value = this.dv.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      // JavaScript doesn't support 64-bit integer so calculate this here
      // 1 << 32 will return 1 so using multiply operation instead here.
      // There's a possibility that this method returns wrong value if the value
      // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
      // TODO: safely handle 64-bit integer
      getInt64() {
        let low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        if (high & 2147483648) {
          high = ~high & 4294967295;
          low = ~low & 4294967295;
          if (low === 4294967295)
            high = high + 1 & 4294967295;
          low = low + 1 & 4294967295;
          return -(high * 4294967296 + low);
        }
        return high * 4294967296 + low;
      }
      getInt64Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getInt64());
        }
        return a;
      }
      // Note: see getInt64() comment
      getUint64() {
        let low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        return high * 4294967296 + low;
      }
      getFloat32() {
        const value = this.dv.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      getFloat32Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getFloat32());
        }
        return a;
      }
      getFloat64() {
        const value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      getFloat64Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getFloat64());
        }
        return a;
      }
      getArrayBuffer(size) {
        const value = this.dv.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return value;
      }
      getString(size) {
        const start = this.offset;
        let a = new Uint8Array(this.dv.buffer, start, size);
        this.skip(size);
        const nullByte = a.indexOf(0);
        if (nullByte >= 0)
          a = new Uint8Array(this.dv.buffer, start, nullByte);
        return this._textDecoder.decode(a);
      }
    };
    FBXTree = class {
      add(key, val) {
        this[key] = val;
      }
    };
    dataArray = [];
    tempEuler = new Euler();
    tempVec = new Vector3();
  }
});

// node_modules/react-model-viewer/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-model-viewer/dist/index.js"(exports, module) {
    !function(e, t) {
      if ("object" == typeof exports && "object" == typeof module)
        module.exports = t(require_react(), require_three(), (init_OrbitControls(), __toCommonJS(OrbitControls_exports)), (init_GLTFLoader(), __toCommonJS(GLTFLoader_exports)), (init_OBJLoader(), __toCommonJS(OBJLoader_exports)), (init_ColladaLoader(), __toCommonJS(ColladaLoader_exports)), (init_FBXLoader(), __toCommonJS(FBXLoader_exports)));
      else if ("function" == typeof define && define.amd)
        define(["react", "three", "three/examples/jsm/controls/OrbitControls", "three/examples/jsm/loaders/GLTFLoader", "three/examples/jsm/loaders/OBJLoader", "three/examples/jsm/loaders/ColladaLoader", "three/examples/jsm/loaders/FBXLoader"], t);
      else {
        var n = "object" == typeof exports ? t(require_react(), require_three(), (init_OrbitControls(), __toCommonJS(OrbitControls_exports)), (init_GLTFLoader(), __toCommonJS(GLTFLoader_exports)), (init_OBJLoader(), __toCommonJS(OBJLoader_exports)), (init_ColladaLoader(), __toCommonJS(ColladaLoader_exports)), (init_FBXLoader(), __toCommonJS(FBXLoader_exports))) : t(e.react, e.three, e["three/examples/jsm/controls/OrbitControls"], e["three/examples/jsm/loaders/GLTFLoader"], e["three/examples/jsm/loaders/OBJLoader"], e["three/examples/jsm/loaders/ColladaLoader"], e["three/examples/jsm/loaders/FBXLoader"]);
        for (var r in n)
          ("object" == typeof exports ? exports : e)[r] = n[r];
      }
    }(window, function(e, t, n, r, i, o, a) {
      return function(e2) {
        var t2 = {};
        function n2(r2) {
          if (t2[r2])
            return t2[r2].exports;
          var i2 = t2[r2] = { i: r2, l: false, exports: {} };
          return e2[r2].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
        }
        return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
          n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
        }, n2.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, n2.t = function(e3, t3) {
          if (1 & t3 && (e3 = n2(e3)), 8 & t3)
            return e3;
          if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
            return e3;
          var r2 = /* @__PURE__ */ Object.create(null);
          if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
            for (var i2 in e3)
              n2.d(r2, i2, function(t4) {
                return e3[t4];
              }.bind(null, i2));
          return r2;
        }, n2.n = function(e3) {
          var t3 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return n2.d(t3, "a", t3), t3;
        }, n2.o = function(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }, n2.p = "/", n2(n2.s = 118);
      }([function(t2, n2) {
        t2.exports = e;
      }, function(e2, t2, n2) {
        e2.exports = n2(116)();
      }, function(e2, n2) {
        e2.exports = t;
      }, function(e2, t2, n2) {
        (function(t3) {
          var n3 = "object", r2 = function(e3) {
            return e3 && e3.Math == Math && e3;
          };
          e2.exports = r2(typeof globalThis == n3 && globalThis) || r2(typeof window == n3 && window) || r2(typeof self == n3 && self) || r2(typeof t3 == n3 && t3) || Function("return this")();
        }).call(this, n2(49));
      }, function(e2, t2) {
        e2.exports = function(e3) {
          try {
            return !!e3();
          } catch (e4) {
            return true;
          }
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(15).f, o2 = n2(9), a2 = n2(14), l = n2(34), u = n2(53), c = n2(89);
        e2.exports = function(e3, t3) {
          var n3, s, f, p, d, h = e3.target, m = e3.global, v = e3.stat;
          if (n3 = m ? r2 : v ? r2[h] || l(h, {}) : (r2[h] || {}).prototype)
            for (s in t3) {
              if (p = t3[s], f = e3.noTargetGet ? (d = i2(n3, s)) && d.value : n3[s], !c(m ? s : h + (v ? "." : "#") + s, e3.forced) && void 0 !== f) {
                if (typeof p == typeof f)
                  continue;
                u(p, f);
              }
              (e3.sham || f && f.sham) && o2(p, "sham", true), a2(n3, s, p, e3);
            }
        };
      }, function(e2, t2, n2) {
        var r2 = n2(4);
        e2.exports = !r2(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e2, t2) {
        var n2 = {}.hasOwnProperty;
        e2.exports = function(e3, t3) {
          return n2.call(e3, t3);
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(17), o2 = n2(35), a2 = n2(58), l = r2.Symbol, u = i2("wks");
        e2.exports = function(e3) {
          return u[e3] || (u[e3] = a2 && l[e3] || (a2 ? l : o2)("Symbol." + e3));
        };
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(10), o2 = n2(16);
        e2.exports = r2 ? function(e3, t3, n3) {
          return i2.f(e3, t3, o2(1, n3));
        } : function(e3, t3, n3) {
          return e3[t3] = n3, e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(50), o2 = n2(13), a2 = n2(24), l = Object.defineProperty;
        t2.f = r2 ? l : function(e3, t3, n3) {
          if (o2(e3), t3 = a2(t3, true), o2(n3), i2)
            try {
              return l(e3, t3, n3);
            } catch (e4) {
            }
          if ("get" in n3 || "set" in n3)
            throw TypeError("Accessors not supported");
          return "value" in n3 && (e3[t3] = n3.value), e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(32), i2 = n2(23);
        e2.exports = function(e3) {
          return r2(i2(e3));
        };
      }, function(e2, t2) {
        e2.exports = function(e3) {
          return "object" == typeof e3 ? null !== e3 : "function" == typeof e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(12);
        e2.exports = function(e3) {
          if (!r2(e3))
            throw TypeError(String(e3) + " is not an object");
          return e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(17), o2 = n2(9), a2 = n2(7), l = n2(34), u = n2(52), c = n2(26), s = c.get, f = c.enforce, p = String(u).split("toString");
        i2("inspectSource", function(e3) {
          return u.call(e3);
        }), (e2.exports = function(e3, t3, n3, i3) {
          var u2 = !!i3 && !!i3.unsafe, c2 = !!i3 && !!i3.enumerable, s2 = !!i3 && !!i3.noTargetGet;
          "function" == typeof n3 && ("string" != typeof t3 || a2(n3, "name") || o2(n3, "name", t3), f(n3).source = p.join("string" == typeof t3 ? t3 : "")), e3 !== r2 ? (u2 ? !s2 && e3[t3] && (c2 = true) : delete e3[t3], c2 ? e3[t3] = n3 : o2(e3, t3, n3)) : c2 ? e3[t3] = n3 : l(t3, n3);
        })(Function.prototype, "toString", function() {
          return "function" == typeof this && s(this).source || u.call(this);
        });
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(22), o2 = n2(16), a2 = n2(11), l = n2(24), u = n2(7), c = n2(50), s = Object.getOwnPropertyDescriptor;
        t2.f = r2 ? s : function(e3, t3) {
          if (e3 = a2(e3), t3 = l(t3, true), c)
            try {
              return s(e3, t3);
            } catch (e4) {
            }
          if (u(e3, t3))
            return o2(!i2.f.call(e3, t3), e3[t3]);
        };
      }, function(e2, t2) {
        e2.exports = function(e3, t3) {
          return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(34), o2 = n2(25), a2 = r2["__core-js_shared__"] || i2("__core-js_shared__", {});
        (e2.exports = function(e3, t3) {
          return a2[e3] || (a2[e3] = void 0 !== t3 ? t3 : {});
        })("versions", []).push({ version: "3.1.3", mode: o2 ? "pure" : "global", copyright: " 2019 Denis Pushkarev (zloirock.ru)" });
      }, function(e2, t2, n2) {
        var r2 = n2(55), i2 = n2(37);
        e2.exports = Object.keys || function(e3) {
          return r2(e3, i2);
        };
      }, function(e2, t2, n2) {
        var r2 = n2(23);
        e2.exports = function(e3) {
          return Object(r2(e3));
        };
      }, function(e2, t2, n2) {
        "use strict";
        e2.exports = n2(114);
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(3), o2 = n2(7), a2 = n2(58), l = n2(6), u = n2(25), c = n2(14), s = n2(28), f = n2(4), p = n2(17), d = n2(38), h = n2(35), m = n2(8), v = n2(59), b = n2(60), y = n2(91), g = n2(61), x = n2(13), w = n2(12), E = n2(19), O = n2(11), T = n2(24), S = n2(16), _ = n2(39), k = n2(36), j = n2(94), P = n2(15), C = n2(10), z = n2(22), I = n2(9), M = n2(18), N = n2(30), L = n2(27), R = n2(26), A = L("hidden"), U = R.set, F = R.getterFor("Symbol"), D = P.f, W = C.f, B = j.f, H = i2.Symbol, q = i2.JSON, Q = q && q.stringify, V = m("toPrimitive"), G = z.f, $ = p("symbol-registry"), K = p("symbols"), X = p("op-symbols"), Y = p("wks"), J = Object.prototype, Z = i2.QObject, ee = !Z || !Z.prototype || !Z.prototype.findChild, te2 = l && f(function() {
          return 7 != _(W({}, "a", { get: function() {
            return W(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e3, t3, n3) {
          var r3 = D(J, t3);
          r3 && delete J[t3], W(e3, t3, n3), r3 && e3 !== J && W(J, t3, r3);
        } : W, ne = function(e3, t3) {
          var n3 = K[e3] = _(H.prototype);
          return U(n3, { type: "Symbol", tag: e3, description: t3 }), l || (n3.description = t3), n3;
        }, re = a2 && "symbol" == typeof H.iterator ? function(e3) {
          return "symbol" == typeof e3;
        } : function(e3) {
          return Object(e3) instanceof H;
        }, ie = function(e3, t3, n3) {
          return e3 === J && ie(X, t3, n3), x(e3), t3 = T(t3, true), x(n3), o2(K, t3) ? (n3.enumerable ? (o2(e3, A) && e3[A][t3] && (e3[A][t3] = false), n3 = _(n3, { enumerable: S(0, false) })) : (o2(e3, A) || W(e3, A, S(1, {})), e3[A][t3] = true), te2(e3, t3, n3)) : W(e3, t3, n3);
        }, oe = function(e3, t3) {
          x(e3);
          for (var n3, r3 = y(t3 = O(t3)), i3 = 0, o3 = r3.length; o3 > i3; )
            ie(e3, n3 = r3[i3++], t3[n3]);
          return e3;
        }, ae = function(e3) {
          var t3 = G.call(this, e3 = T(e3, true));
          return !(this === J && o2(K, e3) && !o2(X, e3)) && (!(t3 || !o2(this, e3) || !o2(K, e3) || o2(this, A) && this[A][e3]) || t3);
        }, le = function(e3, t3) {
          if (e3 = O(e3), t3 = T(t3, true), e3 !== J || !o2(K, t3) || o2(X, t3)) {
            var n3 = D(e3, t3);
            return !n3 || !o2(K, t3) || o2(e3, A) && e3[A][t3] || (n3.enumerable = true), n3;
          }
        }, ue = function(e3) {
          for (var t3, n3 = B(O(e3)), r3 = [], i3 = 0; n3.length > i3; )
            o2(K, t3 = n3[i3++]) || o2(s, t3) || r3.push(t3);
          return r3;
        }, ce = function(e3) {
          for (var t3, n3 = e3 === J, r3 = B(n3 ? X : O(e3)), i3 = [], a3 = 0; r3.length > a3; )
            !o2(K, t3 = r3[a3++]) || n3 && !o2(J, t3) || i3.push(K[t3]);
          return i3;
        };
        a2 || (c((H = function() {
          if (this instanceof H)
            throw TypeError("Symbol is not a constructor");
          var e3 = void 0 === arguments[0] ? void 0 : String(arguments[0]), t3 = h(e3), n3 = function(e4) {
            this === J && n3.call(X, e4), o2(this, A) && o2(this[A], t3) && (this[A][t3] = false), te2(this, t3, S(1, e4));
          };
          return l && ee && te2(J, t3, { configurable: true, set: n3 }), ne(t3, e3);
        }).prototype, "toString", function() {
          return F(this).tag;
        }), z.f = ae, C.f = ie, P.f = le, k.f = j.f = ue, N.f = ce, l && (W(H.prototype, "description", { configurable: true, get: function() {
          return F(this).description;
        } }), u || c(J, "propertyIsEnumerable", ae, { unsafe: true })), v.f = function(e3) {
          return ne(m(e3), e3);
        }), r2({ global: true, wrap: true, forced: !a2, sham: !a2 }, { Symbol: H });
        for (var se = M(Y), fe = 0; se.length > fe; )
          b(se[fe++]);
        r2({ target: "Symbol", stat: true, forced: !a2 }, { for: function(e3) {
          return o2($, e3 += "") ? $[e3] : $[e3] = H(e3);
        }, keyFor: function(e3) {
          if (!re(e3))
            throw TypeError(e3 + " is not a symbol");
          for (var t3 in $)
            if ($[t3] === e3)
              return t3;
        }, useSetter: function() {
          ee = true;
        }, useSimple: function() {
          ee = false;
        } }), r2({ target: "Object", stat: true, forced: !a2, sham: !l }, { create: function(e3, t3) {
          return void 0 === t3 ? _(e3) : oe(_(e3), t3);
        }, defineProperty: ie, defineProperties: oe, getOwnPropertyDescriptor: le }), r2({ target: "Object", stat: true, forced: !a2 }, { getOwnPropertyNames: ue, getOwnPropertySymbols: ce }), r2({ target: "Object", stat: true, forced: f(function() {
          N.f(1);
        }) }, { getOwnPropertySymbols: function(e3) {
          return N.f(E(e3));
        } }), q && r2({ target: "JSON", stat: true, forced: !a2 || f(function() {
          var e3 = H();
          return "[null]" != Q([e3]) || "{}" != Q({ a: e3 }) || "{}" != Q(Object(e3));
        }) }, { stringify: function(e3) {
          for (var t3, n3, r3 = [e3], i3 = 1; arguments.length > i3; )
            r3.push(arguments[i3++]);
          if (n3 = t3 = r3[1], (w(t3) || void 0 !== e3) && !re(e3))
            return g(t3) || (t3 = function(e4, t4) {
              if ("function" == typeof n3 && (t4 = n3.call(this, e4, t4)), !re(t4))
                return t4;
            }), r3[1] = t3, Q.apply(q, r3);
        } }), H.prototype[V] || I(H.prototype, V, H.prototype.valueOf), d(H, "Symbol"), s[A] = true;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = {}.propertyIsEnumerable, i2 = Object.getOwnPropertyDescriptor, o2 = i2 && !r2.call({ 1: 2 }, 1);
        t2.f = o2 ? function(e3) {
          var t3 = i2(this, e3);
          return !!t3 && t3.enumerable;
        } : r2;
      }, function(e2, t2) {
        e2.exports = function(e3) {
          if (null == e3)
            throw TypeError("Can't call method on " + e3);
          return e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(12);
        e2.exports = function(e3, t3) {
          if (!r2(e3))
            return e3;
          var n3, i2;
          if (t3 && "function" == typeof (n3 = e3.toString) && !r2(i2 = n3.call(e3)))
            return i2;
          if ("function" == typeof (n3 = e3.valueOf) && !r2(i2 = n3.call(e3)))
            return i2;
          if (!t3 && "function" == typeof (n3 = e3.toString) && !r2(i2 = n3.call(e3)))
            return i2;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e2, t2) {
        e2.exports = false;
      }, function(e2, t2, n2) {
        var r2, i2, o2, a2 = n2(87), l = n2(3), u = n2(12), c = n2(9), s = n2(7), f = n2(27), p = n2(28), d = l.WeakMap;
        if (a2) {
          var h = new d(), m = h.get, v = h.has, b = h.set;
          r2 = function(e3, t3) {
            return b.call(h, e3, t3), t3;
          }, i2 = function(e3) {
            return m.call(h, e3) || {};
          }, o2 = function(e3) {
            return v.call(h, e3);
          };
        } else {
          var y = f("state");
          p[y] = true, r2 = function(e3, t3) {
            return c(e3, y, t3), t3;
          }, i2 = function(e3) {
            return s(e3, y) ? e3[y] : {};
          }, o2 = function(e3) {
            return s(e3, y);
          };
        }
        e2.exports = { set: r2, get: i2, has: o2, enforce: function(e3) {
          return o2(e3) ? i2(e3) : r2(e3, {});
        }, getterFor: function(e3) {
          return function(t3) {
            var n3;
            if (!u(t3) || (n3 = i2(t3)).type !== e3)
              throw TypeError("Incompatible receiver, " + e3 + " required");
            return n3;
          };
        } };
      }, function(e2, t2, n2) {
        var r2 = n2(17), i2 = n2(35), o2 = r2("keys");
        e2.exports = function(e3) {
          return o2[e3] || (o2[e3] = i2(e3));
        };
      }, function(e2, t2) {
        e2.exports = {};
      }, function(e2, t2) {
        var n2 = Math.ceil, r2 = Math.floor;
        e2.exports = function(e3) {
          return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? r2 : n2)(e3);
        };
      }, function(e2, t2) {
        t2.f = Object.getOwnPropertySymbols;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(11), i2 = n2(98), o2 = n2(43), a2 = n2(26), l = n2(68), u = a2.set, c = a2.getterFor("Array Iterator");
        e2.exports = l(Array, "Array", function(e3, t3) {
          u(this, { type: "Array Iterator", target: r2(e3), index: 0, kind: t3 });
        }, function() {
          var e3 = c(this), t3 = e3.target, n3 = e3.kind, r3 = e3.index++;
          return !t3 || r3 >= t3.length ? (e3.target = void 0, { value: void 0, done: true }) : "keys" == n3 ? { value: r3, done: false } : "values" == n3 ? { value: t3[r3], done: false } : { value: [r3, t3[r3]], done: false };
        }, "values"), o2.Arguments = o2.Array, i2("keys"), i2("values"), i2("entries");
      }, function(e2, t2, n2) {
        var r2 = n2(4), i2 = n2(33), o2 = "".split;
        e2.exports = r2(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e3) {
          return "String" == i2(e3) ? o2.call(e3, "") : Object(e3);
        } : Object;
      }, function(e2, t2) {
        var n2 = {}.toString;
        e2.exports = function(e3) {
          return n2.call(e3).slice(8, -1);
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(9);
        e2.exports = function(e3, t3) {
          try {
            i2(r2, e3, t3);
          } catch (n3) {
            r2[e3] = t3;
          }
          return t3;
        };
      }, function(e2, t2) {
        var n2 = 0, r2 = Math.random();
        e2.exports = function(e3) {
          return "Symbol(".concat(void 0 === e3 ? "" : e3, ")_", (++n2 + r2).toString(36));
        };
      }, function(e2, t2, n2) {
        var r2 = n2(55), i2 = n2(37).concat("length", "prototype");
        t2.f = Object.getOwnPropertyNames || function(e3) {
          return r2(e3, i2);
        };
      }, function(e2, t2) {
        e2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, function(e2, t2, n2) {
        var r2 = n2(10).f, i2 = n2(7), o2 = n2(8)("toStringTag");
        e2.exports = function(e3, t3, n3) {
          e3 && !i2(e3 = n3 ? e3 : e3.prototype, o2) && r2(e3, o2, { configurable: true, value: t3 });
        };
      }, function(e2, t2, n2) {
        var r2 = n2(13), i2 = n2(92), o2 = n2(37), a2 = n2(28), l = n2(93), u = n2(51), c = n2(27)("IE_PROTO"), s = function() {
        }, f = function() {
          var e3, t3 = u("iframe"), n3 = o2.length;
          for (t3.style.display = "none", l.appendChild(t3), t3.src = String("javascript:"), (e3 = t3.contentWindow.document).open(), e3.write("<script>document.F=Object<\/script>"), e3.close(), f = e3.F; n3--; )
            delete f.prototype[o2[n3]];
          return f();
        };
        e2.exports = Object.create || function(e3, t3) {
          var n3;
          return null !== e3 ? (s.prototype = r2(e3), n3 = new s(), s.prototype = null, n3[c] = e3) : n3 = f(), void 0 === t3 ? n3 : i2(n3, t3);
        }, a2[c] = true;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(6), o2 = n2(3), a2 = n2(7), l = n2(12), u = n2(10).f, c = n2(53), s = o2.Symbol;
        if (i2 && "function" == typeof s && (!("description" in s.prototype) || void 0 !== s().description)) {
          var f = {}, p = function() {
            var e3 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), t3 = this instanceof p ? new s(e3) : void 0 === e3 ? s() : s(e3);
            return "" === e3 && (f[t3] = true), t3;
          };
          c(p, s);
          var d = p.prototype = s.prototype;
          d.constructor = p;
          var h = d.toString, m = "Symbol(test)" == String(s("test")), v = /^Symbol\((.*)\)[^)]+$/;
          u(d, "description", { configurable: true, get: function() {
            var e3 = l(this) ? this.valueOf() : this, t3 = h.call(e3);
            if (a2(f, e3))
              return "";
            var n3 = m ? t3.slice(7, -1) : t3.replace(v, "$1");
            return "" === n3 ? void 0 : n3;
          } }), r2({ global: true, forced: true }, { Symbol: p });
        }
      }, function(e2, t2, n2) {
        n2(60)("iterator");
      }, function(e2, t2, n2) {
        var r2 = n2(95), i2 = n2(32), o2 = n2(19), a2 = n2(57), l = n2(97);
        e2.exports = function(e3, t3) {
          var n3 = 1 == e3, u = 2 == e3, c = 3 == e3, s = 4 == e3, f = 6 == e3, p = 5 == e3 || f, d = t3 || l;
          return function(t4, l2, h) {
            for (var m, v, b = o2(t4), y = i2(b), g = r2(l2, h, 3), x = a2(y.length), w = 0, E = n3 ? d(t4, x) : u ? d(t4, 0) : void 0; x > w; w++)
              if ((p || w in y) && (v = g(m = y[w], w, b), e3)) {
                if (n3)
                  E[w] = v;
                else if (v)
                  switch (e3) {
                    case 3:
                      return true;
                    case 5:
                      return m;
                    case 6:
                      return w;
                    case 2:
                      E.push(m);
                  }
                else if (s)
                  return false;
              }
            return f ? -1 : c || s ? s : E;
          };
        };
      }, function(e2, t2) {
        e2.exports = {};
      }, function(e2, t2, n2) {
        var r2 = n2(14), i2 = Date.prototype, o2 = i2.toString, a2 = i2.getTime;
        /* @__PURE__ */ new Date(NaN) + "" != "Invalid Date" && r2(i2, "toString", function() {
          var e3 = a2.call(this);
          return e3 == e3 ? o2.call(this) : "Invalid Date";
        });
      }, function(e2, t2, n2) {
        var r2 = n2(14), i2 = n2(106), o2 = Object.prototype;
        i2 !== o2.toString && r2(o2, "toString", i2, { unsafe: true });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(14), i2 = n2(13), o2 = n2(4), a2 = n2(108), l = /./.toString, u = RegExp.prototype, c = o2(function() {
          return "/a/b" != l.call({ source: "a", flags: "b" });
        }), s = "toString" != l.name;
        (c || s) && r2(RegExp.prototype, "toString", function() {
          var e3 = i2(this), t3 = String(e3.source), n3 = e3.flags;
          return "/" + t3 + "/" + String(void 0 === n3 && e3 instanceof RegExp && !("flags" in u) ? a2.call(e3) : n3);
        }, { unsafe: true });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(109), i2 = n2(26), o2 = n2(68), a2 = i2.set, l = i2.getterFor("String Iterator");
        o2(String, "String", function(e3) {
          a2(this, { type: "String Iterator", string: String(e3), index: 0 });
        }, function() {
          var e3, t3 = l(this), n3 = t3.string, i3 = t3.index;
          return i3 >= n3.length ? { value: void 0, done: true } : (e3 = r2(n3, i3, true), t3.index += e3.length, { value: e3, done: false });
        });
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(77), o2 = n2(31), a2 = n2(9), l = n2(8), u = l("iterator"), c = l("toStringTag"), s = o2.values;
        for (var f in i2) {
          var p = r2[f], d = p && p.prototype;
          if (d) {
            if (d[u] !== s)
              try {
                a2(d, u, s);
              } catch (e3) {
                d[u] = s;
              }
            if (d[c] || a2(d, c, f), i2[f]) {
              for (var h in o2)
                if (d[h] !== o2[h])
                  try {
                    a2(d, h, o2[h]);
                  } catch (e3) {
                    d[h] = o2[h];
                  }
            }
          }
        }
      }, function(e2, t2) {
        var n2;
        n2 = function() {
          return this;
        }();
        try {
          n2 = n2 || new Function("return this")();
        } catch (e3) {
          "object" == typeof window && (n2 = window);
        }
        e2.exports = n2;
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(4), o2 = n2(51);
        e2.exports = !r2 && !i2(function() {
          return 7 != Object.defineProperty(o2("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(12), o2 = r2.document, a2 = i2(o2) && i2(o2.createElement);
        e2.exports = function(e3) {
          return a2 ? o2.createElement(e3) : {};
        };
      }, function(e2, t2, n2) {
        var r2 = n2(17);
        e2.exports = r2("native-function-to-string", Function.toString);
      }, function(e2, t2, n2) {
        var r2 = n2(7), i2 = n2(54), o2 = n2(15), a2 = n2(10);
        e2.exports = function(e3, t3) {
          for (var n3 = i2(t3), l = a2.f, u = o2.f, c = 0; c < n3.length; c++) {
            var s = n3[c];
            r2(e3, s) || l(e3, s, u(t3, s));
          }
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(36), o2 = n2(30), a2 = n2(13), l = r2.Reflect;
        e2.exports = l && l.ownKeys || function(e3) {
          var t3 = i2.f(a2(e3)), n3 = o2.f;
          return n3 ? t3.concat(n3(e3)) : t3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(7), i2 = n2(11), o2 = n2(56), a2 = n2(28), l = o2(false);
        e2.exports = function(e3, t3) {
          var n3, o3 = i2(e3), u = 0, c = [];
          for (n3 in o3)
            !r2(a2, n3) && r2(o3, n3) && c.push(n3);
          for (; t3.length > u; )
            r2(o3, n3 = t3[u++]) && (~l(c, n3) || c.push(n3));
          return c;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(11), i2 = n2(57), o2 = n2(88);
        e2.exports = function(e3) {
          return function(t3, n3, a2) {
            var l, u = r2(t3), c = i2(u.length), s = o2(a2, c);
            if (e3 && n3 != n3) {
              for (; c > s; )
                if ((l = u[s++]) != l)
                  return true;
            } else
              for (; c > s; s++)
                if ((e3 || s in u) && u[s] === n3)
                  return e3 || s || 0;
            return !e3 && -1;
          };
        };
      }, function(e2, t2, n2) {
        var r2 = n2(29), i2 = Math.min;
        e2.exports = function(e3) {
          return e3 > 0 ? i2(r2(e3), 9007199254740991) : 0;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(4);
        e2.exports = !!Object.getOwnPropertySymbols && !r2(function() {
          return !String(Symbol());
        });
      }, function(e2, t2, n2) {
        t2.f = n2(8);
      }, function(e2, t2, n2) {
        var r2 = n2(90), i2 = n2(7), o2 = n2(59), a2 = n2(10).f;
        e2.exports = function(e3) {
          var t3 = r2.Symbol || (r2.Symbol = {});
          i2(t3, e3) || a2(t3, e3, { value: o2.f(e3) });
        };
      }, function(e2, t2, n2) {
        var r2 = n2(33);
        e2.exports = Array.isArray || function(e3) {
          return "Array" == r2(e3);
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(42), o2 = n2(63), a2 = i2(2);
        r2({ target: "Array", proto: true, forced: !o2("filter") }, { filter: function(e3) {
          return a2(this, e3, arguments[1]);
        } });
      }, function(e2, t2, n2) {
        var r2 = n2(4), i2 = n2(8)("species");
        e2.exports = function(e3) {
          return !r2(function() {
            var t3 = [];
            return (t3.constructor = {})[i2] = function() {
              return { foo: 1 };
            }, 1 !== t3[e3](Boolean).foo;
          });
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(65);
        r2({ target: "Array", proto: true, forced: [].forEach != i2 }, { forEach: i2 });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(42), i2 = n2(66), o2 = r2(0), a2 = i2("forEach");
        e2.exports = a2 ? function(e3) {
          return o2(this, e3, arguments[1]);
        } : [].forEach;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(4);
        e2.exports = function(e3, t3) {
          var n3 = [][e3];
          return !n3 || !r2(function() {
            n3.call(null, t3 || function() {
              throw 1;
            }, 1);
          });
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(66), o2 = n2(56)(false), a2 = [].indexOf, l = !!a2 && 1 / [1].indexOf(1, -0) < 0, u = i2("indexOf");
        r2({ target: "Array", proto: true, forced: l || u }, { indexOf: function(e3) {
          return l ? a2.apply(this, arguments) || 0 : o2(this, e3, arguments[1]);
        } });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(99), o2 = n2(70), a2 = n2(101), l = n2(38), u = n2(9), c = n2(14), s = n2(8), f = n2(25), p = n2(43), d = n2(69), h = d.IteratorPrototype, m = d.BUGGY_SAFARI_ITERATORS, v = s("iterator"), b = function() {
          return this;
        };
        e2.exports = function(e3, t3, n3, s2, d2, y, g) {
          i2(n3, t3, s2);
          var x, w, E, O = function(e4) {
            if (e4 === d2 && j)
              return j;
            if (!m && e4 in _)
              return _[e4];
            switch (e4) {
              case "keys":
              case "values":
              case "entries":
                return function() {
                  return new n3(this, e4);
                };
            }
            return function() {
              return new n3(this);
            };
          }, T = t3 + " Iterator", S = false, _ = e3.prototype, k = _[v] || _["@@iterator"] || d2 && _[d2], j = !m && k || O(d2), P = "Array" == t3 && _.entries || k;
          if (P && (x = o2(P.call(new e3())), h !== Object.prototype && x.next && (f || o2(x) === h || (a2 ? a2(x, h) : "function" != typeof x[v] && u(x, v, b)), l(x, T, true, true), f && (p[T] = b))), "values" == d2 && k && "values" !== k.name && (S = true, j = function() {
            return k.call(this);
          }), f && !g || _[v] === j || u(_, v, j), p[t3] = j, d2)
            if (w = { values: O("values"), keys: y ? j : O("keys"), entries: O("entries") }, g)
              for (E in w)
                !m && !S && E in _ || c(_, E, w[E]);
            else
              r2({ target: t3, proto: true, forced: m || S }, w);
          return w;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2, i2, o2, a2 = n2(70), l = n2(9), u = n2(7), c = n2(8), s = n2(25), f = c("iterator"), p = false;
        [].keys && ("next" in (o2 = [].keys()) ? (i2 = a2(a2(o2))) !== Object.prototype && (r2 = i2) : p = true), null == r2 && (r2 = {}), s || u(r2, f) || l(r2, f, function() {
          return this;
        }), e2.exports = { IteratorPrototype: r2, BUGGY_SAFARI_ITERATORS: p };
      }, function(e2, t2, n2) {
        var r2 = n2(7), i2 = n2(19), o2 = n2(27), a2 = n2(100), l = o2("IE_PROTO"), u = Object.prototype;
        e2.exports = a2 ? Object.getPrototypeOf : function(e3) {
          return e3 = i2(e3), r2(e3, l) ? e3[l] : "function" == typeof e3.constructor && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? u : null;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(5), i2 = n2(42), o2 = n2(63), a2 = i2(1);
        r2({ target: "Array", proto: true, forced: !o2("map") }, { map: function(e3) {
          return a2(this, e3, arguments[1]);
        } });
      }, function(e2, t2, n2) {
        var r2 = n2(5), i2 = n2(104);
        r2({ target: "Object", stat: true, forced: Object.assign !== i2 }, { assign: i2 });
      }, function(e2, t2, n2) {
        var r2 = n2(5), i2 = n2(4), o2 = n2(11), a2 = n2(15).f, l = n2(6), u = i2(function() {
          a2(1);
        });
        r2({ target: "Object", stat: true, forced: !l || u, sham: !l }, { getOwnPropertyDescriptor: function(e3, t3) {
          return a2(o2(e3), t3);
        } });
      }, function(e2, t2, n2) {
        var r2 = n2(5), i2 = n2(6), o2 = n2(54), a2 = n2(11), l = n2(15), u = n2(105);
        r2({ target: "Object", stat: true, sham: !i2 }, { getOwnPropertyDescriptors: function(e3) {
          for (var t3, n3, r3 = a2(e3), i3 = l.f, c = o2(r3), s = {}, f = 0; c.length > f; )
            void 0 !== (n3 = i3(r3, t3 = c[f++])) && u(s, t3, n3);
          return s;
        } });
      }, function(e2, t2, n2) {
        var r2 = n2(5), i2 = n2(19), o2 = n2(18);
        r2({ target: "Object", stat: true, forced: n2(4)(function() {
          o2(1);
        }) }, { keys: function(e3) {
          return o2(i2(e3));
        } });
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(77), o2 = n2(65), a2 = n2(9);
        for (var l in i2) {
          var u = r2[l], c = u && u.prototype;
          if (c && c.forEach !== o2)
            try {
              a2(c, "forEach", o2);
            } catch (e3) {
              c.forEach = o2;
            }
        }
      }, function(e2, t2) {
        e2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
      }, function(e2, t2) {
        e2.exports = n;
      }, function(e2, t2) {
        e2.exports = r;
      }, function(e2, t2) {
        e2.exports = i;
      }, function(e2, t2) {
        e2.exports = o;
      }, function(e2, t2) {
        e2.exports = a;
      }, function(e2, t2, n2) {
        "use strict";
        e2.exports = n2(112);
      }, function(e2, t2) {
        function n2() {
        }
        n2.prototype = { on: function(e3, t3, n3) {
          var r2 = this.e || (this.e = {});
          return (r2[e3] || (r2[e3] = [])).push({ fn: t3, ctx: n3 }), this;
        }, once: function(e3, t3, n3) {
          var r2 = this;
          function i2() {
            r2.off(e3, i2), t3.apply(n3, arguments);
          }
          return i2._ = t3, this.on(e3, i2, n3);
        }, emit: function(e3) {
          for (var t3 = [].slice.call(arguments, 1), n3 = ((this.e || (this.e = {}))[e3] || []).slice(), r2 = 0, i2 = n3.length; r2 < i2; r2++)
            n3[r2].fn.apply(n3[r2].ctx, t3);
          return this;
        }, off: function(e3, t3) {
          var n3 = this.e || (this.e = {}), r2 = n3[e3], i2 = [];
          if (r2 && t3)
            for (var o2 = 0, a2 = r2.length; o2 < a2; o2++)
              r2[o2].fn !== t3 && r2[o2].fn._ !== t3 && i2.push(r2[o2]);
          return i2.length ? n3[e3] = i2 : delete n3[e3], this;
        } }, e2.exports = n2, e2.exports.TinyEmitter = n2;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = this && this.__values || function(e3) {
          var t3 = "function" == typeof Symbol && e3[Symbol.iterator], n3 = 0;
          return t3 ? t3.call(e3) : { next: function() {
            return e3 && n3 >= e3.length && (e3 = void 0), { value: e3 && e3[n3++], done: !e3 };
          } };
        }, i2 = this && this.__read || function(e3, t3) {
          var n3 = "function" == typeof Symbol && e3[Symbol.iterator];
          if (!n3)
            return e3;
          var r3, i3, o3 = n3.call(e3), a3 = [];
          try {
            for (; (void 0 === t3 || t3-- > 0) && !(r3 = o3.next()).done; )
              a3.push(r3.value);
          } catch (e4) {
            i3 = { error: e4 };
          } finally {
            try {
              r3 && !r3.done && (n3 = o3.return) && n3.call(o3);
            } finally {
              if (i3)
                throw i3.error;
            }
          }
          return a3;
        }, o2 = this && this.__spread || function() {
          for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
            e3 = e3.concat(i2(arguments[t3]));
          return e3;
        }, a2 = n2(115), l = [];
        e2.exports = function(e3, t3, n3) {
          var i3, u;
          void 0 === n3 && (n3 = 0);
          try {
            for (var c = r2(l), s = c.next(); !s.done; s = c.next()) {
              var f = s.value;
              if (a2(t3, f.inputs)) {
                if (Object.prototype.hasOwnProperty.call(f, "error"))
                  throw f.error;
                if (Object.prototype.hasOwnProperty.call(f, "response"))
                  return f.response;
                throw f.promise;
              }
            }
          } catch (e4) {
            i3 = { error: e4 };
          } finally {
            try {
              s && !s.done && (u = c.return) && u.call(c);
            } finally {
              if (i3)
                throw i3.error;
            }
          }
          var p = { promise: e3.apply(void 0, o2(t3)).then(function(e4) {
            p.response = e4;
          }).catch(function(e4) {
            p.error = e4;
          }).then(function() {
            n3 > 0 && setTimeout(function() {
              var e4 = l.indexOf(p);
              -1 !== e4 && l.splice(e4, 1);
            }, n3);
          }), inputs: t3 };
          throw l.push(p), p.promise;
        };
      }, function(e2, t2, n2) {
        "use strict";
        (function(e3) {
          var n3 = function() {
            if ("undefined" != typeof Map)
              return Map;
            function e4(e5, t3) {
              var n4 = -1;
              return e5.some(function(e6, r3) {
                return e6[0] === t3 && (n4 = r3, true);
              }), n4;
            }
            return function() {
              function t3() {
                this.__entries__ = [];
              }
              return Object.defineProperty(t3.prototype, "size", { get: function() {
                return this.__entries__.length;
              }, enumerable: true, configurable: true }), t3.prototype.get = function(t4) {
                var n4 = e4(this.__entries__, t4), r3 = this.__entries__[n4];
                return r3 && r3[1];
              }, t3.prototype.set = function(t4, n4) {
                var r3 = e4(this.__entries__, t4);
                ~r3 ? this.__entries__[r3][1] = n4 : this.__entries__.push([t4, n4]);
              }, t3.prototype.delete = function(t4) {
                var n4 = this.__entries__, r3 = e4(n4, t4);
                ~r3 && n4.splice(r3, 1);
              }, t3.prototype.has = function(t4) {
                return !!~e4(this.__entries__, t4);
              }, t3.prototype.clear = function() {
                this.__entries__.splice(0);
              }, t3.prototype.forEach = function(e5, t4) {
                void 0 === t4 && (t4 = null);
                for (var n4 = 0, r3 = this.__entries__; n4 < r3.length; n4++) {
                  var i3 = r3[n4];
                  e5.call(t4, i3[1], i3[0]);
                }
              }, t3;
            }();
          }(), r2 = "undefined" != typeof window && "undefined" != typeof document && window.document === document, i2 = void 0 !== e3 && e3.Math === Math ? e3 : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(), o2 = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(i2) : function(e4) {
            return setTimeout(function() {
              return e4(Date.now());
            }, 1e3 / 60);
          }, a2 = 2;
          var l = 20, u = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], c = "undefined" != typeof MutationObserver, s = function() {
            function e4() {
              this.connected_ = false, this.mutationEventsAdded_ = false, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = function(e5, t3) {
                var n4 = false, r3 = false, i3 = 0;
                function l2() {
                  n4 && (n4 = false, e5()), r3 && c2();
                }
                function u2() {
                  o2(l2);
                }
                function c2() {
                  var e6 = Date.now();
                  if (n4) {
                    if (e6 - i3 < a2)
                      return;
                    r3 = true;
                  } else
                    n4 = true, r3 = false, setTimeout(u2, t3);
                  i3 = e6;
                }
                return c2;
              }(this.refresh.bind(this), l);
            }
            return e4.prototype.addObserver = function(e5) {
              ~this.observers_.indexOf(e5) || this.observers_.push(e5), this.connected_ || this.connect_();
            }, e4.prototype.removeObserver = function(e5) {
              var t3 = this.observers_, n4 = t3.indexOf(e5);
              ~n4 && t3.splice(n4, 1), !t3.length && this.connected_ && this.disconnect_();
            }, e4.prototype.refresh = function() {
              this.updateObservers_() && this.refresh();
            }, e4.prototype.updateObservers_ = function() {
              var e5 = this.observers_.filter(function(e6) {
                return e6.gatherActive(), e6.hasActive();
              });
              return e5.forEach(function(e6) {
                return e6.broadcastActive();
              }), e5.length > 0;
            }, e4.prototype.connect_ = function() {
              r2 && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), c ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, { attributes: true, childList: true, characterData: true, subtree: true })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = true), this.connected_ = true);
            }, e4.prototype.disconnect_ = function() {
              r2 && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = false, this.connected_ = false);
            }, e4.prototype.onTransitionEnd_ = function(e5) {
              var t3 = e5.propertyName, n4 = void 0 === t3 ? "" : t3;
              u.some(function(e6) {
                return !!~n4.indexOf(e6);
              }) && this.refresh();
            }, e4.getInstance = function() {
              return this.instance_ || (this.instance_ = new e4()), this.instance_;
            }, e4.instance_ = null, e4;
          }(), f = function(e4, t3) {
            for (var n4 = 0, r3 = Object.keys(t3); n4 < r3.length; n4++) {
              var i3 = r3[n4];
              Object.defineProperty(e4, i3, { value: t3[i3], enumerable: false, writable: false, configurable: true });
            }
            return e4;
          }, p = function(e4) {
            return e4 && e4.ownerDocument && e4.ownerDocument.defaultView || i2;
          }, d = g(0, 0, 0, 0);
          function h(e4) {
            return parseFloat(e4) || 0;
          }
          function m(e4) {
            for (var t3 = [], n4 = 1; n4 < arguments.length; n4++)
              t3[n4 - 1] = arguments[n4];
            return t3.reduce(function(t4, n5) {
              return t4 + h(e4["border-" + n5 + "-width"]);
            }, 0);
          }
          function v(e4) {
            var t3 = e4.clientWidth, n4 = e4.clientHeight;
            if (!t3 && !n4)
              return d;
            var r3 = p(e4).getComputedStyle(e4), i3 = function(e5) {
              for (var t4 = {}, n5 = 0, r4 = ["top", "right", "bottom", "left"]; n5 < r4.length; n5++) {
                var i4 = r4[n5], o4 = e5["padding-" + i4];
                t4[i4] = h(o4);
              }
              return t4;
            }(r3), o3 = i3.left + i3.right, a3 = i3.top + i3.bottom, l2 = h(r3.width), u2 = h(r3.height);
            if ("border-box" === r3.boxSizing && (Math.round(l2 + o3) !== t3 && (l2 -= m(r3, "left", "right") + o3), Math.round(u2 + a3) !== n4 && (u2 -= m(r3, "top", "bottom") + a3)), !function(e5) {
              return e5 === p(e5).document.documentElement;
            }(e4)) {
              var c2 = Math.round(l2 + o3) - t3, s2 = Math.round(u2 + a3) - n4;
              1 !== Math.abs(c2) && (l2 -= c2), 1 !== Math.abs(s2) && (u2 -= s2);
            }
            return g(i3.left, i3.top, l2, u2);
          }
          var b = "undefined" != typeof SVGGraphicsElement ? function(e4) {
            return e4 instanceof p(e4).SVGGraphicsElement;
          } : function(e4) {
            return e4 instanceof p(e4).SVGElement && "function" == typeof e4.getBBox;
          };
          function y(e4) {
            return r2 ? b(e4) ? function(e5) {
              var t3 = e5.getBBox();
              return g(0, 0, t3.width, t3.height);
            }(e4) : v(e4) : d;
          }
          function g(e4, t3, n4, r3) {
            return { x: e4, y: t3, width: n4, height: r3 };
          }
          var x = function() {
            function e4(e5) {
              this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = g(0, 0, 0, 0), this.target = e5;
            }
            return e4.prototype.isActive = function() {
              var e5 = y(this.target);
              return this.contentRect_ = e5, e5.width !== this.broadcastWidth || e5.height !== this.broadcastHeight;
            }, e4.prototype.broadcastRect = function() {
              var e5 = this.contentRect_;
              return this.broadcastWidth = e5.width, this.broadcastHeight = e5.height, e5;
            }, e4;
          }(), w = function(e4, t3) {
            var n4, r3, i3, o3, a3, l2, u2, c2 = (r3 = (n4 = t3).x, i3 = n4.y, o3 = n4.width, a3 = n4.height, l2 = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, u2 = Object.create(l2.prototype), f(u2, { x: r3, y: i3, width: o3, height: a3, top: i3, right: r3 + o3, bottom: a3 + i3, left: r3 }), u2);
            f(this, { target: e4, contentRect: c2 });
          }, E = function() {
            function e4(e5, t3, r3) {
              if (this.activeObservations_ = [], this.observations_ = new n3(), "function" != typeof e5)
                throw new TypeError("The callback provided as parameter 1 is not a function.");
              this.callback_ = e5, this.controller_ = t3, this.callbackCtx_ = r3;
            }
            return e4.prototype.observe = function(e5) {
              if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
              if ("undefined" != typeof Element && Element instanceof Object) {
                if (!(e5 instanceof p(e5).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var t3 = this.observations_;
                t3.has(e5) || (t3.set(e5, new x(e5)), this.controller_.addObserver(this), this.controller_.refresh());
              }
            }, e4.prototype.unobserve = function(e5) {
              if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
              if ("undefined" != typeof Element && Element instanceof Object) {
                if (!(e5 instanceof p(e5).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var t3 = this.observations_;
                t3.has(e5) && (t3.delete(e5), t3.size || this.controller_.removeObserver(this));
              }
            }, e4.prototype.disconnect = function() {
              this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
            }, e4.prototype.gatherActive = function() {
              var e5 = this;
              this.clearActive(), this.observations_.forEach(function(t3) {
                t3.isActive() && e5.activeObservations_.push(t3);
              });
            }, e4.prototype.broadcastActive = function() {
              if (this.hasActive()) {
                var e5 = this.callbackCtx_, t3 = this.activeObservations_.map(function(e6) {
                  return new w(e6.target, e6.broadcastRect());
                });
                this.callback_.call(e5, t3, e5), this.clearActive();
              }
            }, e4.prototype.clearActive = function() {
              this.activeObservations_.splice(0);
            }, e4.prototype.hasActive = function() {
              return this.activeObservations_.length > 0;
            }, e4;
          }(), O = "undefined" != typeof WeakMap ? /* @__PURE__ */ new WeakMap() : new n3(), T = function e4(t3) {
            if (!(this instanceof e4))
              throw new TypeError("Cannot call a class as a function.");
            if (!arguments.length)
              throw new TypeError("1 argument required, but only 0 present.");
            var n4 = s.getInstance(), r3 = new E(t3, n4, this);
            O.set(this, r3);
          };
          ["observe", "unobserve", "disconnect"].forEach(function(e4) {
            T.prototype[e4] = function() {
              var t3;
              return (t3 = O.get(this))[e4].apply(t3, arguments);
            };
          });
          var S = void 0 !== i2.ResizeObserver ? i2.ResizeObserver : T;
          t2.a = S;
        }).call(this, n2(49));
      }, function(e2, t2, n2) {
        var r2 = n2(3), i2 = n2(52), o2 = r2.WeakMap;
        e2.exports = "function" == typeof o2 && /native code/.test(i2.call(o2));
      }, function(e2, t2, n2) {
        var r2 = n2(29), i2 = Math.max, o2 = Math.min;
        e2.exports = function(e3, t3) {
          var n3 = r2(e3);
          return n3 < 0 ? i2(n3 + t3, 0) : o2(n3, t3);
        };
      }, function(e2, t2, n2) {
        var r2 = n2(4), i2 = /#|\.prototype\./, o2 = function(e3, t3) {
          var n3 = l[a2(e3)];
          return n3 == c || n3 != u && ("function" == typeof t3 ? r2(t3) : !!t3);
        }, a2 = o2.normalize = function(e3) {
          return String(e3).replace(i2, ".").toLowerCase();
        }, l = o2.data = {}, u = o2.NATIVE = "N", c = o2.POLYFILL = "P";
        e2.exports = o2;
      }, function(e2, t2, n2) {
        e2.exports = n2(3);
      }, function(e2, t2, n2) {
        var r2 = n2(18), i2 = n2(30), o2 = n2(22);
        e2.exports = function(e3) {
          var t3 = r2(e3), n3 = i2.f;
          if (n3)
            for (var a2, l = n3(e3), u = o2.f, c = 0; l.length > c; )
              u.call(e3, a2 = l[c++]) && t3.push(a2);
          return t3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(10), o2 = n2(13), a2 = n2(18);
        e2.exports = r2 ? Object.defineProperties : function(e3, t3) {
          o2(e3);
          for (var n3, r3 = a2(t3), l = r3.length, u = 0; l > u; )
            i2.f(e3, n3 = r3[u++], t3[n3]);
          return e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(3).document;
        e2.exports = r2 && r2.documentElement;
      }, function(e2, t2, n2) {
        var r2 = n2(11), i2 = n2(36).f, o2 = {}.toString, a2 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        e2.exports.f = function(e3) {
          return a2 && "[object Window]" == o2.call(e3) ? function(e4) {
            try {
              return i2(e4);
            } catch (e5) {
              return a2.slice();
            }
          }(e3) : i2(r2(e3));
        };
      }, function(e2, t2, n2) {
        var r2 = n2(96);
        e2.exports = function(e3, t3, n3) {
          if (r2(e3), void 0 === t3)
            return e3;
          switch (n3) {
            case 0:
              return function() {
                return e3.call(t3);
              };
            case 1:
              return function(n4) {
                return e3.call(t3, n4);
              };
            case 2:
              return function(n4, r3) {
                return e3.call(t3, n4, r3);
              };
            case 3:
              return function(n4, r3, i2) {
                return e3.call(t3, n4, r3, i2);
              };
          }
          return function() {
            return e3.apply(t3, arguments);
          };
        };
      }, function(e2, t2) {
        e2.exports = function(e3) {
          if ("function" != typeof e3)
            throw TypeError(String(e3) + " is not a function");
          return e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(12), i2 = n2(61), o2 = n2(8)("species");
        e2.exports = function(e3, t3) {
          var n3;
          return i2(e3) && ("function" != typeof (n3 = e3.constructor) || n3 !== Array && !i2(n3.prototype) ? r2(n3) && null === (n3 = n3[o2]) && (n3 = void 0) : n3 = void 0), new (void 0 === n3 ? Array : n3)(0 === t3 ? 0 : t3);
        };
      }, function(e2, t2, n2) {
        var r2 = n2(8), i2 = n2(39), o2 = n2(9), a2 = r2("unscopables"), l = Array.prototype;
        null == l[a2] && o2(l, a2, i2(null)), e2.exports = function(e3) {
          l[a2][e3] = true;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(69).IteratorPrototype, i2 = n2(39), o2 = n2(16), a2 = n2(38), l = n2(43), u = function() {
          return this;
        };
        e2.exports = function(e3, t3, n3) {
          var c = t3 + " Iterator";
          return e3.prototype = i2(r2, { next: o2(1, n3) }), a2(e3, c, false, true), l[c] = u, e3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(4);
        e2.exports = !r2(function() {
          function e3() {
          }
          return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
        });
      }, function(e2, t2, n2) {
        var r2 = n2(102);
        e2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var e3, t3 = false, n3 = {};
          try {
            (e3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n3, []), t3 = n3 instanceof Array;
          } catch (e4) {
          }
          return function(n4, i2) {
            return r2(n4, i2), t3 ? e3.call(n4, i2) : n4.__proto__ = i2, n4;
          };
        }() : void 0);
      }, function(e2, t2, n2) {
        var r2 = n2(12), i2 = n2(13);
        e2.exports = function(e3, t3) {
          if (i2(e3), !r2(t3) && null !== t3)
            throw TypeError("Can't set " + String(t3) + " as a prototype");
        };
      }, function(e2, t2, n2) {
        var r2 = n2(6), i2 = n2(10).f, o2 = Function.prototype, a2 = o2.toString, l = /^\s*function ([^ (]*)/;
        !r2 || "name" in o2 || i2(o2, "name", { configurable: true, get: function() {
          try {
            return a2.call(this).match(l)[1];
          } catch (e3) {
            return "";
          }
        } });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(6), i2 = n2(4), o2 = n2(18), a2 = n2(30), l = n2(22), u = n2(19), c = n2(32), s = Object.assign;
        e2.exports = !s || i2(function() {
          var e3 = {}, t3 = {}, n3 = Symbol();
          return e3[n3] = 7, "abcdefghijklmnopqrst".split("").forEach(function(e4) {
            t3[e4] = e4;
          }), 7 != s({}, e3)[n3] || "abcdefghijklmnopqrst" != o2(s({}, t3)).join("");
        }) ? function(e3, t3) {
          for (var n3 = u(e3), i3 = arguments.length, s2 = 1, f = a2.f, p = l.f; i3 > s2; )
            for (var d, h = c(arguments[s2++]), m = f ? o2(h).concat(f(h)) : o2(h), v = m.length, b = 0; v > b; )
              d = m[b++], r2 && !p.call(h, d) || (n3[d] = h[d]);
          return n3;
        } : s;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(24), i2 = n2(10), o2 = n2(16);
        e2.exports = function(e3, t3, n3) {
          var a2 = r2(t3);
          a2 in e3 ? i2.f(e3, a2, o2(0, n3)) : e3[a2] = n3;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(107), i2 = {};
        i2[n2(8)("toStringTag")] = "z", e2.exports = "[object z]" !== String(i2) ? function() {
          return "[object " + r2(this) + "]";
        } : i2.toString;
      }, function(e2, t2, n2) {
        var r2 = n2(33), i2 = n2(8)("toStringTag"), o2 = "Arguments" == r2(function() {
          return arguments;
        }());
        e2.exports = function(e3) {
          var t3, n3, a2;
          return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (n3 = function(e4, t4) {
            try {
              return e4[t4];
            } catch (e5) {
            }
          }(t3 = Object(e3), i2)) ? n3 : o2 ? r2(t3) : "Object" == (a2 = r2(t3)) && "function" == typeof t3.callee ? "Arguments" : a2;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(13);
        e2.exports = function() {
          var e3 = r2(this), t3 = "";
          return e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.unicode && (t3 += "u"), e3.sticky && (t3 += "y"), t3;
        };
      }, function(e2, t2, n2) {
        var r2 = n2(29), i2 = n2(23);
        e2.exports = function(e3, t3, n3) {
          var o2, a2, l = String(i2(e3)), u = r2(t3), c = l.length;
          return u < 0 || u >= c ? n3 ? "" : void 0 : (o2 = l.charCodeAt(u)) < 55296 || o2 > 56319 || u + 1 === c || (a2 = l.charCodeAt(u + 1)) < 56320 || a2 > 57343 ? n3 ? l.charAt(u) : o2 : n3 ? l.slice(u, u + 2) : a2 - 56320 + (o2 - 55296 << 10) + 65536;
        };
      }, function(e2, t2, n2) {
        n2(5)({ target: "String", proto: true }, { repeat: n2(111) });
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(29), i2 = n2(23);
        e2.exports = "".repeat || function(e3) {
          var t3 = String(i2(this)), n3 = "", o2 = r2(e3);
          if (o2 < 0 || o2 == 1 / 0)
            throw RangeError("Wrong number of repetitions");
          for (; o2 > 0; (o2 >>>= 1) && (t3 += t3))
            1 & o2 && (n3 += t3);
          return n3;
        };
      }, function(e2, t2, n2) {
        e2.exports = function t3(r2) {
          "use strict";
          var i2 = n2(113), o2 = n2(0), a2 = n2(20);
          function l(e3) {
            for (var t4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e3, n3 = 1; n3 < arguments.length; n3++)
              t4 += "&args[]=" + encodeURIComponent(arguments[n3]);
            return "Minified React error #" + e3 + "; visit " + t4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
          }
          var u = o2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          u.hasOwnProperty("ReactCurrentDispatcher") || (u.ReactCurrentDispatcher = { current: null }), u.hasOwnProperty("ReactCurrentBatchConfig") || (u.ReactCurrentBatchConfig = { suspense: null });
          var c = "function" == typeof Symbol && Symbol.for, s = c ? Symbol.for("react.element") : 60103, f = c ? Symbol.for("react.portal") : 60106, p = c ? Symbol.for("react.fragment") : 60107, d = c ? Symbol.for("react.strict_mode") : 60108, h = c ? Symbol.for("react.profiler") : 60114, m = c ? Symbol.for("react.provider") : 60109, v = c ? Symbol.for("react.context") : 60110, b = c ? Symbol.for("react.concurrent_mode") : 60111, y = c ? Symbol.for("react.forward_ref") : 60112, g = c ? Symbol.for("react.suspense") : 60113, x = c ? Symbol.for("react.suspense_list") : 60120, w = c ? Symbol.for("react.memo") : 60115, E = c ? Symbol.for("react.lazy") : 60116;
          c && Symbol.for("react.fundamental"), c && Symbol.for("react.responder"), c && Symbol.for("react.scope");
          var O = "function" == typeof Symbol && Symbol.iterator;
          function T(e3) {
            return null === e3 || "object" != typeof e3 ? null : "function" == typeof (e3 = O && e3[O] || e3["@@iterator"]) ? e3 : null;
          }
          function S(e3) {
            if (null == e3)
              return null;
            if ("function" == typeof e3)
              return e3.displayName || e3.name || null;
            if ("string" == typeof e3)
              return e3;
            switch (e3) {
              case p:
                return "Fragment";
              case f:
                return "Portal";
              case h:
                return "Profiler";
              case d:
                return "StrictMode";
              case g:
                return "Suspense";
              case x:
                return "SuspenseList";
            }
            if ("object" == typeof e3)
              switch (e3.$$typeof) {
                case v:
                  return "Context.Consumer";
                case m:
                  return "Context.Provider";
                case y:
                  var t4 = e3.render;
                  return t4 = t4.displayName || t4.name || "", e3.displayName || ("" !== t4 ? "ForwardRef(" + t4 + ")" : "ForwardRef");
                case w:
                  return S(e3.type);
                case E:
                  if (e3 = 1 === e3._status ? e3._result : null)
                    return S(e3);
              }
            return null;
          }
          function _(e3) {
            var t4 = e3, n3 = e3;
            if (e3.alternate)
              for (; t4.return; )
                t4 = t4.return;
            else {
              e3 = t4;
              do {
                0 != (1026 & (t4 = e3).effectTag) && (n3 = t4.return), e3 = t4.return;
              } while (e3);
            }
            return 3 === t4.tag ? n3 : null;
          }
          function k(e3) {
            if (_(e3) !== e3)
              throw Error(l(188));
          }
          function j(e3) {
            var t4 = e3.alternate;
            if (!t4) {
              if (null === (t4 = _(e3)))
                throw Error(l(188));
              return t4 !== e3 ? null : e3;
            }
            for (var n3 = e3, r3 = t4; ; ) {
              var i3 = n3.return;
              if (null === i3)
                break;
              var o3 = i3.alternate;
              if (null === o3) {
                if (null !== (r3 = i3.return)) {
                  n3 = r3;
                  continue;
                }
                break;
              }
              if (i3.child === o3.child) {
                for (o3 = i3.child; o3; ) {
                  if (o3 === n3)
                    return k(i3), e3;
                  if (o3 === r3)
                    return k(i3), t4;
                  o3 = o3.sibling;
                }
                throw Error(l(188));
              }
              if (n3.return !== r3.return)
                n3 = i3, r3 = o3;
              else {
                for (var a3 = false, u2 = i3.child; u2; ) {
                  if (u2 === n3) {
                    a3 = true, n3 = i3, r3 = o3;
                    break;
                  }
                  if (u2 === r3) {
                    a3 = true, r3 = i3, n3 = o3;
                    break;
                  }
                  u2 = u2.sibling;
                }
                if (!a3) {
                  for (u2 = o3.child; u2; ) {
                    if (u2 === n3) {
                      a3 = true, n3 = o3, r3 = i3;
                      break;
                    }
                    if (u2 === r3) {
                      a3 = true, r3 = o3, n3 = i3;
                      break;
                    }
                    u2 = u2.sibling;
                  }
                  if (!a3)
                    throw Error(l(189));
                }
              }
              if (n3.alternate !== r3)
                throw Error(l(190));
            }
            if (3 !== n3.tag)
              throw Error(l(188));
            return n3.stateNode.current === n3 ? e3 : t4;
          }
          function P(e3) {
            if (!(e3 = j(e3)))
              return null;
            for (var t4 = e3; ; ) {
              if (5 === t4.tag || 6 === t4.tag)
                return t4;
              if (t4.child)
                t4.child.return = t4, t4 = t4.child;
              else {
                if (t4 === e3)
                  break;
                for (; !t4.sibling; ) {
                  if (!t4.return || t4.return === e3)
                    return null;
                  t4 = t4.return;
                }
                t4.sibling.return = t4.return, t4 = t4.sibling;
              }
            }
            return null;
          }
          var C = r2.getPublicInstance, z = r2.getRootHostContext, I = r2.getChildHostContext, M = r2.prepareForCommit, N = r2.resetAfterCommit, L = r2.createInstance, R = r2.appendInitialChild, A = r2.finalizeInitialChildren, U = r2.prepareUpdate, F = r2.shouldSetTextContent, D = r2.shouldDeprioritizeSubtree, W = r2.createTextInstance, B = r2.setTimeout, H = r2.clearTimeout, q = r2.noTimeout, Q = r2.isPrimaryRenderer, V = r2.supportsMutation, G = r2.supportsPersistence, $ = r2.supportsHydration, K = r2.appendChild, X = r2.appendChildToContainer, Y = r2.commitTextUpdate, J = r2.commitMount, Z = r2.commitUpdate, ee = r2.insertBefore, te2 = r2.insertInContainerBefore, ne = r2.removeChild, re = r2.removeChildFromContainer, ie = r2.resetTextContent, oe = r2.hideInstance, ae = r2.hideTextInstance, le = r2.unhideInstance, ue = r2.unhideTextInstance, ce = r2.cloneInstance, se = r2.createContainerChildSet, fe = r2.appendChildToContainerChildSet, pe = r2.finalizeContainerChildren, de = r2.replaceContainerChildren, he = r2.cloneHiddenInstance, me = r2.cloneHiddenTextInstance, ve = r2.canHydrateInstance, be = r2.canHydrateTextInstance, ye = r2.isSuspenseInstancePending, ge = r2.isSuspenseInstanceFallback, xe = r2.getNextHydratableSibling, we = r2.getFirstHydratableChild, Ee = r2.hydrateInstance, Oe = r2.hydrateTextInstance, Te = r2.getNextHydratableInstanceAfterSuspenseInstance, Se = r2.commitHydratedContainer, _e = r2.commitHydratedSuspenseInstance, ke = /^(.*)[\\\/]/;
          function je(e3) {
            var t4 = "";
            do {
              e:
                switch (e3.tag) {
                  case 3:
                  case 4:
                  case 6:
                  case 7:
                  case 10:
                  case 9:
                    var n3 = "";
                    break e;
                  default:
                    var r3 = e3._debugOwner, i3 = e3._debugSource, o3 = S(e3.type);
                    n3 = null, r3 && (n3 = S(r3.type)), r3 = o3, o3 = "", i3 ? o3 = " (at " + i3.fileName.replace(ke, "") + ":" + i3.lineNumber + ")" : n3 && (o3 = " (created by " + n3 + ")"), n3 = "\n    in " + (r3 || "Unknown") + o3;
                }
              t4 += n3, e3 = e3.return;
            } while (e3);
            return t4;
          }
          /* @__PURE__ */ new Set();
          var Pe = [], Ce = -1;
          function ze(e3) {
            0 > Ce || (e3.current = Pe[Ce], Pe[Ce] = null, Ce--);
          }
          function Ie(e3, t4) {
            Pe[++Ce] = e3.current, e3.current = t4;
          }
          var Me = {}, Ne = { current: Me }, Le = { current: false }, Re = Me;
          function Ae(e3, t4) {
            var n3 = e3.type.contextTypes;
            if (!n3)
              return Me;
            var r3 = e3.stateNode;
            if (r3 && r3.__reactInternalMemoizedUnmaskedChildContext === t4)
              return r3.__reactInternalMemoizedMaskedChildContext;
            var i3, o3 = {};
            for (i3 in n3)
              o3[i3] = t4[i3];
            return r3 && ((e3 = e3.stateNode).__reactInternalMemoizedUnmaskedChildContext = t4, e3.__reactInternalMemoizedMaskedChildContext = o3), o3;
          }
          function Ue(e3) {
            return null != (e3 = e3.childContextTypes);
          }
          function Fe(e3) {
            ze(Le), ze(Ne);
          }
          function De(e3) {
            ze(Le), ze(Ne);
          }
          function We(e3, t4, n3) {
            if (Ne.current !== Me)
              throw Error(l(168));
            Ie(Ne, t4), Ie(Le, n3);
          }
          function Be(e3, t4, n3) {
            var r3 = e3.stateNode;
            if (e3 = t4.childContextTypes, "function" != typeof r3.getChildContext)
              return n3;
            for (var o3 in r3 = r3.getChildContext())
              if (!(o3 in e3))
                throw Error(l(108, S(t4) || "Unknown", o3));
            return i2({}, n3, {}, r3);
          }
          function He(e3) {
            var t4 = e3.stateNode;
            return t4 = t4 && t4.__reactInternalMemoizedMergedChildContext || Me, Re = Ne.current, Ie(Ne, t4), Ie(Le, Le.current), true;
          }
          function qe(e3, t4, n3) {
            var r3 = e3.stateNode;
            if (!r3)
              throw Error(l(169));
            n3 ? (t4 = Be(e3, t4, Re), r3.__reactInternalMemoizedMergedChildContext = t4, ze(Le), ze(Ne), Ie(Ne, t4)) : ze(Le), Ie(Le, n3);
          }
          var Qe = a2.unstable_runWithPriority, Ve = a2.unstable_scheduleCallback, Ge = a2.unstable_cancelCallback, $e = a2.unstable_shouldYield, Ke = a2.unstable_requestPaint, Xe = a2.unstable_now, Ye = a2.unstable_getCurrentPriorityLevel, Je = a2.unstable_ImmediatePriority, Ze = a2.unstable_UserBlockingPriority, et2 = a2.unstable_NormalPriority, tt = a2.unstable_LowPriority, nt = a2.unstable_IdlePriority, rt = {}, it = void 0 !== Ke ? Ke : function() {
          }, ot = null, at = null, lt = false, ut = Xe(), ct = 1e4 > ut ? Xe : function() {
            return Xe() - ut;
          };
          function st() {
            switch (Ye()) {
              case Je:
                return 99;
              case Ze:
                return 98;
              case et2:
                return 97;
              case tt:
                return 96;
              case nt:
                return 95;
              default:
                throw Error(l(332));
            }
          }
          function ft(e3) {
            switch (e3) {
              case 99:
                return Je;
              case 98:
                return Ze;
              case 97:
                return et2;
              case 96:
                return tt;
              case 95:
                return nt;
              default:
                throw Error(l(332));
            }
          }
          function pt(e3, t4) {
            return e3 = ft(e3), Qe(e3, t4);
          }
          function dt(e3, t4, n3) {
            return e3 = ft(e3), Ve(e3, t4, n3);
          }
          function ht(e3) {
            return null === ot ? (ot = [e3], at = Ve(Je, vt)) : ot.push(e3), rt;
          }
          function mt() {
            if (null !== at) {
              var e3 = at;
              at = null, Ge(e3);
            }
            vt();
          }
          function vt() {
            if (!lt && null !== ot) {
              lt = true;
              var e3 = 0;
              try {
                var t4 = ot;
                pt(99, function() {
                  for (; e3 < t4.length; e3++) {
                    var n3 = t4[e3];
                    do {
                      n3 = n3(true);
                    } while (null !== n3);
                  }
                }), ot = null;
              } catch (t5) {
                throw null !== ot && (ot = ot.slice(e3 + 1)), Ve(Je, mt), t5;
              } finally {
                lt = false;
              }
            }
          }
          var bt = 3;
          function yt(e3, t4, n3) {
            return 1073741821 - (1 + ((1073741821 - e3 + t4 / 10) / (n3 /= 10) | 0)) * n3;
          }
          var gt = "function" == typeof Object.is ? Object.is : function(e3, t4) {
            return e3 === t4 && (0 !== e3 || 1 / e3 == 1 / t4) || e3 != e3 && t4 != t4;
          }, xt = Object.prototype.hasOwnProperty;
          function wt(e3, t4) {
            if (gt(e3, t4))
              return true;
            if ("object" != typeof e3 || null === e3 || "object" != typeof t4 || null === t4)
              return false;
            var n3 = Object.keys(e3), r3 = Object.keys(t4);
            if (n3.length !== r3.length)
              return false;
            for (r3 = 0; r3 < n3.length; r3++)
              if (!xt.call(t4, n3[r3]) || !gt(e3[n3[r3]], t4[n3[r3]]))
                return false;
            return true;
          }
          function Et(e3, t4) {
            if (e3 && e3.defaultProps)
              for (var n3 in t4 = i2({}, t4), e3 = e3.defaultProps)
                void 0 === t4[n3] && (t4[n3] = e3[n3]);
            return t4;
          }
          var Ot = { current: null }, Tt = null, St = null, _t = null;
          function kt() {
            _t = St = Tt = null;
          }
          function jt(e3, t4) {
            var n3 = e3.type._context;
            Q ? (Ie(Ot, n3._currentValue), n3._currentValue = t4) : (Ie(Ot, n3._currentValue2), n3._currentValue2 = t4);
          }
          function Pt(e3) {
            var t4 = Ot.current;
            ze(Ot), e3 = e3.type._context, Q ? e3._currentValue = t4 : e3._currentValue2 = t4;
          }
          function Ct(e3, t4) {
            for (; null !== e3; ) {
              var n3 = e3.alternate;
              if (e3.childExpirationTime < t4)
                e3.childExpirationTime = t4, null !== n3 && n3.childExpirationTime < t4 && (n3.childExpirationTime = t4);
              else {
                if (!(null !== n3 && n3.childExpirationTime < t4))
                  break;
                n3.childExpirationTime = t4;
              }
              e3 = e3.return;
            }
          }
          function zt(e3, t4) {
            Tt = e3, _t = St = null, null !== (e3 = e3.dependencies) && null !== e3.firstContext && (e3.expirationTime >= t4 && (pr = true), e3.firstContext = null);
          }
          function It(e3, t4) {
            if (_t !== e3 && false !== t4 && 0 !== t4)
              if ("number" == typeof t4 && 1073741823 !== t4 || (_t = e3, t4 = 1073741823), t4 = { context: e3, observedBits: t4, next: null }, null === St) {
                if (null === Tt)
                  throw Error(l(308));
                St = t4, Tt.dependencies = { expirationTime: 0, firstContext: t4, responders: null };
              } else
                St = St.next = t4;
            return Q ? e3._currentValue : e3._currentValue2;
          }
          var Mt = false;
          function Nt(e3) {
            return { baseState: e3, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
          }
          function Lt(e3) {
            return { baseState: e3.baseState, firstUpdate: e3.firstUpdate, lastUpdate: e3.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
          }
          function Rt(e3, t4) {
            return { expirationTime: e3, suspenseConfig: t4, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
          }
          function At(e3, t4) {
            null === e3.lastUpdate ? e3.firstUpdate = e3.lastUpdate = t4 : (e3.lastUpdate.next = t4, e3.lastUpdate = t4);
          }
          function Ut(e3, t4) {
            var n3 = e3.alternate;
            if (null === n3) {
              var r3 = e3.updateQueue, i3 = null;
              null === r3 && (r3 = e3.updateQueue = Nt(e3.memoizedState));
            } else
              r3 = e3.updateQueue, i3 = n3.updateQueue, null === r3 ? null === i3 ? (r3 = e3.updateQueue = Nt(e3.memoizedState), i3 = n3.updateQueue = Nt(n3.memoizedState)) : r3 = e3.updateQueue = Lt(i3) : null === i3 && (i3 = n3.updateQueue = Lt(r3));
            null === i3 || r3 === i3 ? At(r3, t4) : null === r3.lastUpdate || null === i3.lastUpdate ? (At(r3, t4), At(i3, t4)) : (At(r3, t4), i3.lastUpdate = t4);
          }
          function Ft(e3, t4) {
            var n3 = e3.updateQueue;
            null === (n3 = null === n3 ? e3.updateQueue = Nt(e3.memoizedState) : Dt(e3, n3)).lastCapturedUpdate ? n3.firstCapturedUpdate = n3.lastCapturedUpdate = t4 : (n3.lastCapturedUpdate.next = t4, n3.lastCapturedUpdate = t4);
          }
          function Dt(e3, t4) {
            var n3 = e3.alternate;
            return null !== n3 && t4 === n3.updateQueue && (t4 = e3.updateQueue = Lt(t4)), t4;
          }
          function Wt(e3, t4, n3, r3, o3, a3) {
            switch (n3.tag) {
              case 1:
                return "function" == typeof (e3 = n3.payload) ? e3.call(a3, r3, o3) : e3;
              case 3:
                e3.effectTag = -4097 & e3.effectTag | 64;
              case 0:
                if (null == (o3 = "function" == typeof (e3 = n3.payload) ? e3.call(a3, r3, o3) : e3))
                  break;
                return i2({}, r3, o3);
              case 2:
                Mt = true;
            }
            return r3;
          }
          function Bt(e3, t4, n3, r3, i3) {
            Mt = false;
            for (var o3 = (t4 = Dt(e3, t4)).baseState, a3 = null, l2 = 0, u2 = t4.firstUpdate, c2 = o3; null !== u2; ) {
              var s2 = u2.expirationTime;
              s2 < i3 ? (null === a3 && (a3 = u2, o3 = c2), l2 < s2 && (l2 = s2)) : (Ki(s2, u2.suspenseConfig), c2 = Wt(e3, 0, u2, c2, n3, r3), null !== u2.callback && (e3.effectTag |= 32, u2.nextEffect = null, null === t4.lastEffect ? t4.firstEffect = t4.lastEffect = u2 : (t4.lastEffect.nextEffect = u2, t4.lastEffect = u2))), u2 = u2.next;
            }
            for (s2 = null, u2 = t4.firstCapturedUpdate; null !== u2; ) {
              var f2 = u2.expirationTime;
              f2 < i3 ? (null === s2 && (s2 = u2, null === a3 && (o3 = c2)), l2 < f2 && (l2 = f2)) : (c2 = Wt(e3, 0, u2, c2, n3, r3), null !== u2.callback && (e3.effectTag |= 32, u2.nextEffect = null, null === t4.lastCapturedEffect ? t4.firstCapturedEffect = t4.lastCapturedEffect = u2 : (t4.lastCapturedEffect.nextEffect = u2, t4.lastCapturedEffect = u2))), u2 = u2.next;
            }
            null === a3 && (t4.lastUpdate = null), null === s2 ? t4.lastCapturedUpdate = null : e3.effectTag |= 32, null === a3 && null === s2 && (o3 = c2), t4.baseState = o3, t4.firstUpdate = a3, t4.firstCapturedUpdate = s2, Xi(l2), e3.expirationTime = l2, e3.memoizedState = c2;
          }
          function Ht(e3, t4, n3) {
            null !== t4.firstCapturedUpdate && (null !== t4.lastUpdate && (t4.lastUpdate.next = t4.firstCapturedUpdate, t4.lastUpdate = t4.lastCapturedUpdate), t4.firstCapturedUpdate = t4.lastCapturedUpdate = null), qt(t4.firstEffect, n3), t4.firstEffect = t4.lastEffect = null, qt(t4.firstCapturedEffect, n3), t4.firstCapturedEffect = t4.lastCapturedEffect = null;
          }
          function qt(e3, t4) {
            for (; null !== e3; ) {
              var n3 = e3.callback;
              if (null !== n3) {
                e3.callback = null;
                var r3 = t4;
                if ("function" != typeof n3)
                  throw Error(l(191, n3));
                n3.call(r3);
              }
              e3 = e3.nextEffect;
            }
          }
          var Qt = u.ReactCurrentBatchConfig, Vt = new o2.Component().refs;
          function Gt(e3, t4, n3, r3) {
            n3 = null == (n3 = n3(r3, t4 = e3.memoizedState)) ? t4 : i2({}, t4, n3), e3.memoizedState = n3, null !== (r3 = e3.updateQueue) && 0 === e3.expirationTime && (r3.baseState = n3);
          }
          var $t = { isMounted: function(e3) {
            return !!(e3 = e3._reactInternalFiber) && _(e3) === e3;
          }, enqueueSetState: function(e3, t4, n3) {
            e3 = e3._reactInternalFiber;
            var r3 = Ui(), i3 = Qt.suspense;
            (i3 = Rt(r3 = Fi(r3, e3, i3), i3)).payload = t4, null != n3 && (i3.callback = n3), Ut(e3, i3), Di(e3, r3);
          }, enqueueReplaceState: function(e3, t4, n3) {
            e3 = e3._reactInternalFiber;
            var r3 = Ui(), i3 = Qt.suspense;
            (i3 = Rt(r3 = Fi(r3, e3, i3), i3)).tag = 1, i3.payload = t4, null != n3 && (i3.callback = n3), Ut(e3, i3), Di(e3, r3);
          }, enqueueForceUpdate: function(e3, t4) {
            e3 = e3._reactInternalFiber;
            var n3 = Ui(), r3 = Qt.suspense;
            (r3 = Rt(n3 = Fi(n3, e3, r3), r3)).tag = 2, null != t4 && (r3.callback = t4), Ut(e3, r3), Di(e3, n3);
          } };
          function Kt(e3, t4, n3, r3, i3, o3, a3) {
            return "function" == typeof (e3 = e3.stateNode).shouldComponentUpdate ? e3.shouldComponentUpdate(r3, o3, a3) : !t4.prototype || !t4.prototype.isPureReactComponent || (!wt(n3, r3) || !wt(i3, o3));
          }
          function Xt(e3, t4, n3) {
            var r3 = false, i3 = Me, o3 = t4.contextType;
            return "object" == typeof o3 && null !== o3 ? o3 = It(o3) : (i3 = Ue(t4) ? Re : Ne.current, o3 = (r3 = null != (r3 = t4.contextTypes)) ? Ae(e3, i3) : Me), t4 = new t4(n3, o3), e3.memoizedState = null !== t4.state && void 0 !== t4.state ? t4.state : null, t4.updater = $t, e3.stateNode = t4, t4._reactInternalFiber = e3, r3 && ((e3 = e3.stateNode).__reactInternalMemoizedUnmaskedChildContext = i3, e3.__reactInternalMemoizedMaskedChildContext = o3), t4;
          }
          function Yt(e3, t4, n3, r3) {
            e3 = t4.state, "function" == typeof t4.componentWillReceiveProps && t4.componentWillReceiveProps(n3, r3), "function" == typeof t4.UNSAFE_componentWillReceiveProps && t4.UNSAFE_componentWillReceiveProps(n3, r3), t4.state !== e3 && $t.enqueueReplaceState(t4, t4.state, null);
          }
          function Jt(e3, t4, n3, r3) {
            var i3 = e3.stateNode;
            i3.props = n3, i3.state = e3.memoizedState, i3.refs = Vt;
            var o3 = t4.contextType;
            "object" == typeof o3 && null !== o3 ? i3.context = It(o3) : (o3 = Ue(t4) ? Re : Ne.current, i3.context = Ae(e3, o3)), null !== (o3 = e3.updateQueue) && (Bt(e3, o3, n3, i3, r3), i3.state = e3.memoizedState), "function" == typeof (o3 = t4.getDerivedStateFromProps) && (Gt(e3, t4, o3, n3), i3.state = e3.memoizedState), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof i3.getSnapshotBeforeUpdate || "function" != typeof i3.UNSAFE_componentWillMount && "function" != typeof i3.componentWillMount || (t4 = i3.state, "function" == typeof i3.componentWillMount && i3.componentWillMount(), "function" == typeof i3.UNSAFE_componentWillMount && i3.UNSAFE_componentWillMount(), t4 !== i3.state && $t.enqueueReplaceState(i3, i3.state, null), null !== (o3 = e3.updateQueue) && (Bt(e3, o3, n3, i3, r3), i3.state = e3.memoizedState)), "function" == typeof i3.componentDidMount && (e3.effectTag |= 4);
          }
          var Zt = Array.isArray;
          function en(e3, t4, n3) {
            if (null !== (e3 = n3.ref) && "function" != typeof e3 && "object" != typeof e3) {
              if (n3._owner) {
                if (n3 = n3._owner) {
                  if (1 !== n3.tag)
                    throw Error(l(309));
                  var r3 = n3.stateNode;
                }
                if (!r3)
                  throw Error(l(147, e3));
                var i3 = "" + e3;
                return null !== t4 && null !== t4.ref && "function" == typeof t4.ref && t4.ref._stringRef === i3 ? t4.ref : ((t4 = function(e4) {
                  var t5 = r3.refs;
                  t5 === Vt && (t5 = r3.refs = {}), null === e4 ? delete t5[i3] : t5[i3] = e4;
                })._stringRef = i3, t4);
              }
              if ("string" != typeof e3)
                throw Error(l(284));
              if (!n3._owner)
                throw Error(l(290, e3));
            }
            return e3;
          }
          function tn(e3, t4) {
            if ("textarea" !== e3.type)
              throw Error(l(31, "[object Object]" === Object.prototype.toString.call(t4) ? "object with keys {" + Object.keys(t4).join(", ") + "}" : t4, ""));
          }
          function nn(e3) {
            function t4(t5, n4) {
              if (e3) {
                var r4 = t5.lastEffect;
                null !== r4 ? (r4.nextEffect = n4, t5.lastEffect = n4) : t5.firstEffect = t5.lastEffect = n4, n4.nextEffect = null, n4.effectTag = 8;
              }
            }
            function n3(n4, r4) {
              if (!e3)
                return null;
              for (; null !== r4; )
                t4(n4, r4), r4 = r4.sibling;
              return null;
            }
            function r3(e4, t5) {
              for (e4 = /* @__PURE__ */ new Map(); null !== t5; )
                null !== t5.key ? e4.set(t5.key, t5) : e4.set(t5.index, t5), t5 = t5.sibling;
              return e4;
            }
            function i3(e4, t5, n4) {
              return (e4 = mo(e4, t5)).index = 0, e4.sibling = null, e4;
            }
            function o3(t5, n4, r4) {
              return t5.index = r4, e3 ? null !== (r4 = t5.alternate) ? (r4 = r4.index) < n4 ? (t5.effectTag = 2, n4) : r4 : (t5.effectTag = 2, n4) : n4;
            }
            function a3(t5) {
              return e3 && null === t5.alternate && (t5.effectTag = 2), t5;
            }
            function u2(e4, t5, n4, r4) {
              return null === t5 || 6 !== t5.tag ? ((t5 = yo(n4, e4.mode, r4)).return = e4, t5) : ((t5 = i3(t5, n4)).return = e4, t5);
            }
            function c2(e4, t5, n4, r4) {
              return null !== t5 && t5.elementType === n4.type ? ((r4 = i3(t5, n4.props)).ref = en(e4, t5, n4), r4.return = e4, r4) : ((r4 = vo(n4.type, n4.key, n4.props, null, e4.mode, r4)).ref = en(e4, t5, n4), r4.return = e4, r4);
            }
            function d2(e4, t5, n4, r4) {
              return null === t5 || 4 !== t5.tag || t5.stateNode.containerInfo !== n4.containerInfo || t5.stateNode.implementation !== n4.implementation ? ((t5 = go(n4, e4.mode, r4)).return = e4, t5) : ((t5 = i3(t5, n4.children || [])).return = e4, t5);
            }
            function h2(e4, t5, n4, r4, o4) {
              return null === t5 || 7 !== t5.tag ? ((t5 = bo(n4, e4.mode, r4, o4)).return = e4, t5) : ((t5 = i3(t5, n4)).return = e4, t5);
            }
            function m2(e4, t5, n4) {
              if ("string" == typeof t5 || "number" == typeof t5)
                return (t5 = yo("" + t5, e4.mode, n4)).return = e4, t5;
              if ("object" == typeof t5 && null !== t5) {
                switch (t5.$$typeof) {
                  case s:
                    return (n4 = vo(t5.type, t5.key, t5.props, null, e4.mode, n4)).ref = en(e4, null, t5), n4.return = e4, n4;
                  case f:
                    return (t5 = go(t5, e4.mode, n4)).return = e4, t5;
                }
                if (Zt(t5) || T(t5))
                  return (t5 = bo(t5, e4.mode, n4, null)).return = e4, t5;
                tn(e4, t5);
              }
              return null;
            }
            function v2(e4, t5, n4, r4) {
              var i4 = null !== t5 ? t5.key : null;
              if ("string" == typeof n4 || "number" == typeof n4)
                return null !== i4 ? null : u2(e4, t5, "" + n4, r4);
              if ("object" == typeof n4 && null !== n4) {
                switch (n4.$$typeof) {
                  case s:
                    return n4.key === i4 ? n4.type === p ? h2(e4, t5, n4.props.children, r4, i4) : c2(e4, t5, n4, r4) : null;
                  case f:
                    return n4.key === i4 ? d2(e4, t5, n4, r4) : null;
                }
                if (Zt(n4) || T(n4))
                  return null !== i4 ? null : h2(e4, t5, n4, r4, null);
                tn(e4, n4);
              }
              return null;
            }
            function b3(e4, t5, n4, r4, i4) {
              if ("string" == typeof r4 || "number" == typeof r4)
                return u2(t5, e4 = e4.get(n4) || null, "" + r4, i4);
              if ("object" == typeof r4 && null !== r4) {
                switch (r4.$$typeof) {
                  case s:
                    return e4 = e4.get(null === r4.key ? n4 : r4.key) || null, r4.type === p ? h2(t5, e4, r4.props.children, i4, r4.key) : c2(t5, e4, r4, i4);
                  case f:
                    return d2(t5, e4 = e4.get(null === r4.key ? n4 : r4.key) || null, r4, i4);
                }
                if (Zt(r4) || T(r4))
                  return h2(t5, e4 = e4.get(n4) || null, r4, i4, null);
                tn(t5, r4);
              }
              return null;
            }
            function y2(i4, a4, l2, u3) {
              for (var c3 = null, s2 = null, f2 = a4, p2 = a4 = 0, d3 = null; null !== f2 && p2 < l2.length; p2++) {
                f2.index > p2 ? (d3 = f2, f2 = null) : d3 = f2.sibling;
                var h3 = v2(i4, f2, l2[p2], u3);
                if (null === h3) {
                  null === f2 && (f2 = d3);
                  break;
                }
                e3 && f2 && null === h3.alternate && t4(i4, f2), a4 = o3(h3, a4, p2), null === s2 ? c3 = h3 : s2.sibling = h3, s2 = h3, f2 = d3;
              }
              if (p2 === l2.length)
                return n3(i4, f2), c3;
              if (null === f2) {
                for (; p2 < l2.length; p2++)
                  null !== (f2 = m2(i4, l2[p2], u3)) && (a4 = o3(f2, a4, p2), null === s2 ? c3 = f2 : s2.sibling = f2, s2 = f2);
                return c3;
              }
              for (f2 = r3(i4, f2); p2 < l2.length; p2++)
                null !== (d3 = b3(f2, i4, p2, l2[p2], u3)) && (e3 && null !== d3.alternate && f2.delete(null === d3.key ? p2 : d3.key), a4 = o3(d3, a4, p2), null === s2 ? c3 = d3 : s2.sibling = d3, s2 = d3);
              return e3 && f2.forEach(function(e4) {
                return t4(i4, e4);
              }), c3;
            }
            function g2(i4, a4, u3, c3) {
              var s2 = T(u3);
              if ("function" != typeof s2)
                throw Error(l(150));
              if (null == (u3 = s2.call(u3)))
                throw Error(l(151));
              for (var f2 = s2 = null, p2 = a4, d3 = a4 = 0, h3 = null, y3 = u3.next(); null !== p2 && !y3.done; d3++, y3 = u3.next()) {
                p2.index > d3 ? (h3 = p2, p2 = null) : h3 = p2.sibling;
                var g3 = v2(i4, p2, y3.value, c3);
                if (null === g3) {
                  null === p2 && (p2 = h3);
                  break;
                }
                e3 && p2 && null === g3.alternate && t4(i4, p2), a4 = o3(g3, a4, d3), null === f2 ? s2 = g3 : f2.sibling = g3, f2 = g3, p2 = h3;
              }
              if (y3.done)
                return n3(i4, p2), s2;
              if (null === p2) {
                for (; !y3.done; d3++, y3 = u3.next())
                  null !== (y3 = m2(i4, y3.value, c3)) && (a4 = o3(y3, a4, d3), null === f2 ? s2 = y3 : f2.sibling = y3, f2 = y3);
                return s2;
              }
              for (p2 = r3(i4, p2); !y3.done; d3++, y3 = u3.next())
                null !== (y3 = b3(p2, i4, d3, y3.value, c3)) && (e3 && null !== y3.alternate && p2.delete(null === y3.key ? d3 : y3.key), a4 = o3(y3, a4, d3), null === f2 ? s2 = y3 : f2.sibling = y3, f2 = y3);
              return e3 && p2.forEach(function(e4) {
                return t4(i4, e4);
              }), s2;
            }
            return function(e4, r4, o4, u3) {
              var c3 = "object" == typeof o4 && null !== o4 && o4.type === p && null === o4.key;
              c3 && (o4 = o4.props.children);
              var d3 = "object" == typeof o4 && null !== o4;
              if (d3)
                switch (o4.$$typeof) {
                  case s:
                    e: {
                      for (d3 = o4.key, c3 = r4; null !== c3; ) {
                        if (c3.key === d3) {
                          if (7 === c3.tag ? o4.type === p : c3.elementType === o4.type) {
                            n3(e4, c3.sibling), (r4 = i3(c3, o4.type === p ? o4.props.children : o4.props)).ref = en(e4, c3, o4), r4.return = e4, e4 = r4;
                            break e;
                          }
                          n3(e4, c3);
                          break;
                        }
                        t4(e4, c3), c3 = c3.sibling;
                      }
                      o4.type === p ? ((r4 = bo(o4.props.children, e4.mode, u3, o4.key)).return = e4, e4 = r4) : ((u3 = vo(o4.type, o4.key, o4.props, null, e4.mode, u3)).ref = en(e4, r4, o4), u3.return = e4, e4 = u3);
                    }
                    return a3(e4);
                  case f:
                    e: {
                      for (c3 = o4.key; null !== r4; ) {
                        if (r4.key === c3) {
                          if (4 === r4.tag && r4.stateNode.containerInfo === o4.containerInfo && r4.stateNode.implementation === o4.implementation) {
                            n3(e4, r4.sibling), (r4 = i3(r4, o4.children || [])).return = e4, e4 = r4;
                            break e;
                          }
                          n3(e4, r4);
                          break;
                        }
                        t4(e4, r4), r4 = r4.sibling;
                      }
                      (r4 = go(o4, e4.mode, u3)).return = e4, e4 = r4;
                    }
                    return a3(e4);
                }
              if ("string" == typeof o4 || "number" == typeof o4)
                return o4 = "" + o4, null !== r4 && 6 === r4.tag ? (n3(e4, r4.sibling), (r4 = i3(r4, o4)).return = e4, e4 = r4) : (n3(e4, r4), (r4 = yo(o4, e4.mode, u3)).return = e4, e4 = r4), a3(e4);
              if (Zt(o4))
                return y2(e4, r4, o4, u3);
              if (T(o4))
                return g2(e4, r4, o4, u3);
              if (d3 && tn(e4, o4), void 0 === o4 && !c3)
                switch (e4.tag) {
                  case 1:
                  case 0:
                    throw e4 = e4.type, Error(l(152, e4.displayName || e4.name || "Component"));
                }
              return n3(e4, r4);
            };
          }
          var rn = nn(true), on = nn(false), an = {}, ln2 = { current: an }, un = { current: an }, cn = { current: an };
          function sn(e3) {
            if (e3 === an)
              throw Error(l(174));
            return e3;
          }
          function fn(e3, t4) {
            Ie(cn, t4), Ie(un, e3), Ie(ln2, an), t4 = z(t4), ze(ln2), Ie(ln2, t4);
          }
          function pn(e3) {
            ze(ln2), ze(un), ze(cn);
          }
          function dn(e3) {
            var t4 = sn(cn.current), n3 = sn(ln2.current);
            n3 !== (t4 = I(n3, e3.type, t4)) && (Ie(un, e3), Ie(ln2, t4));
          }
          function hn(e3) {
            un.current === e3 && (ze(ln2), ze(un));
          }
          var mn = { current: 0 };
          function vn(e3) {
            for (var t4 = e3; null !== t4; ) {
              if (13 === t4.tag) {
                var n3 = t4.memoizedState;
                if (null !== n3 && (null === (n3 = n3.dehydrated) || ye(n3) || ge(n3)))
                  return t4;
              } else if (19 === t4.tag && void 0 !== t4.memoizedProps.revealOrder) {
                if (0 != (64 & t4.effectTag))
                  return t4;
              } else if (null !== t4.child) {
                t4.child.return = t4, t4 = t4.child;
                continue;
              }
              if (t4 === e3)
                break;
              for (; null === t4.sibling; ) {
                if (null === t4.return || t4.return === e3)
                  return null;
                t4 = t4.return;
              }
              t4.sibling.return = t4.return, t4 = t4.sibling;
            }
            return null;
          }
          function bn(e3, t4) {
            return { responder: e3, props: t4 };
          }
          var yn = u.ReactCurrentDispatcher, gn = u.ReactCurrentBatchConfig, xn = 0, wn = null, En = null, On = null, Tn = null, Sn = null, _n = null, kn = 0, jn = null, Pn = 0, Cn = false, zn = null, In = 0;
          function Mn() {
            throw Error(l(321));
          }
          function Nn(e3, t4) {
            if (null === t4)
              return false;
            for (var n3 = 0; n3 < t4.length && n3 < e3.length; n3++)
              if (!gt(e3[n3], t4[n3]))
                return false;
            return true;
          }
          function Ln(e3, t4, n3, r3, i3, o3) {
            if (xn = o3, wn = t4, On = null !== e3 ? e3.memoizedState : null, yn.current = null === On ? er : tr, t4 = n3(r3, i3), Cn) {
              do {
                Cn = false, In += 1, On = null !== e3 ? e3.memoizedState : null, _n = Tn, jn = Sn = En = null, yn.current = tr, t4 = n3(r3, i3);
              } while (Cn);
              zn = null, In = 0;
            }
            if (yn.current = Zn, (e3 = wn).memoizedState = Tn, e3.expirationTime = kn, e3.updateQueue = jn, e3.effectTag |= Pn, e3 = null !== En && null !== En.next, xn = 0, _n = Sn = Tn = On = En = wn = null, kn = 0, jn = null, Pn = 0, e3)
              throw Error(l(300));
            return t4;
          }
          function Rn() {
            yn.current = Zn, xn = 0, _n = Sn = Tn = On = En = wn = null, kn = 0, jn = null, Pn = 0, Cn = false, zn = null, In = 0;
          }
          function An() {
            var e3 = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
            return null === Sn ? Tn = Sn = e3 : Sn = Sn.next = e3, Sn;
          }
          function Un() {
            if (null !== _n)
              _n = (Sn = _n).next, On = null !== (En = On) ? En.next : null;
            else {
              if (null === On)
                throw Error(l(310));
              var e3 = { memoizedState: (En = On).memoizedState, baseState: En.baseState, queue: En.queue, baseUpdate: En.baseUpdate, next: null };
              Sn = null === Sn ? Tn = e3 : Sn.next = e3, On = En.next;
            }
            return Sn;
          }
          function Fn(e3, t4) {
            return "function" == typeof t4 ? t4(e3) : t4;
          }
          function Dn(e3) {
            var t4 = Un(), n3 = t4.queue;
            if (null === n3)
              throw Error(l(311));
            if (n3.lastRenderedReducer = e3, 0 < In) {
              var r3 = n3.dispatch;
              if (null !== zn) {
                var i3 = zn.get(n3);
                if (void 0 !== i3) {
                  zn.delete(n3);
                  var o3 = t4.memoizedState;
                  do {
                    o3 = e3(o3, i3.action), i3 = i3.next;
                  } while (null !== i3);
                  return gt(o3, t4.memoizedState) || (pr = true), t4.memoizedState = o3, t4.baseUpdate === n3.last && (t4.baseState = o3), n3.lastRenderedState = o3, [o3, r3];
                }
              }
              return [t4.memoizedState, r3];
            }
            r3 = n3.last;
            var a3 = t4.baseUpdate;
            if (o3 = t4.baseState, null !== a3 ? (null !== r3 && (r3.next = null), r3 = a3.next) : r3 = null !== r3 ? r3.next : null, null !== r3) {
              var u2 = i3 = null, c2 = r3, s2 = false;
              do {
                var f2 = c2.expirationTime;
                f2 < xn ? (s2 || (s2 = true, u2 = a3, i3 = o3), f2 > kn && Xi(kn = f2)) : (Ki(f2, c2.suspenseConfig), o3 = c2.eagerReducer === e3 ? c2.eagerState : e3(o3, c2.action)), a3 = c2, c2 = c2.next;
              } while (null !== c2 && c2 !== r3);
              s2 || (u2 = a3, i3 = o3), gt(o3, t4.memoizedState) || (pr = true), t4.memoizedState = o3, t4.baseUpdate = u2, t4.baseState = i3, n3.lastRenderedState = o3;
            }
            return [t4.memoizedState, n3.dispatch];
          }
          function Wn(e3) {
            var t4 = An();
            return "function" == typeof e3 && (e3 = e3()), t4.memoizedState = t4.baseState = e3, e3 = (e3 = t4.queue = { last: null, dispatch: null, lastRenderedReducer: Fn, lastRenderedState: e3 }).dispatch = Jn.bind(null, wn, e3), [t4.memoizedState, e3];
          }
          function Bn(e3) {
            return Dn(Fn);
          }
          function Hn(e3, t4, n3, r3) {
            return e3 = { tag: e3, create: t4, destroy: n3, deps: r3, next: null }, null === jn ? (jn = { lastEffect: null }).lastEffect = e3.next = e3 : null === (t4 = jn.lastEffect) ? jn.lastEffect = e3.next = e3 : (n3 = t4.next, t4.next = e3, e3.next = n3, jn.lastEffect = e3), e3;
          }
          function qn(e3, t4, n3, r3) {
            var i3 = An();
            Pn |= e3, i3.memoizedState = Hn(t4, n3, void 0, void 0 === r3 ? null : r3);
          }
          function Qn(e3, t4, n3, r3) {
            var i3 = Un();
            r3 = void 0 === r3 ? null : r3;
            var o3 = void 0;
            if (null !== En) {
              var a3 = En.memoizedState;
              if (o3 = a3.destroy, null !== r3 && Nn(r3, a3.deps))
                return void Hn(0, n3, o3, r3);
            }
            Pn |= e3, i3.memoizedState = Hn(t4, n3, o3, r3);
          }
          function Vn(e3, t4) {
            return qn(516, 192, e3, t4);
          }
          function Gn(e3, t4) {
            return Qn(516, 192, e3, t4);
          }
          function $n(e3, t4) {
            return "function" == typeof t4 ? (e3 = e3(), t4(e3), function() {
              t4(null);
            }) : null != t4 ? (e3 = e3(), t4.current = e3, function() {
              t4.current = null;
            }) : void 0;
          }
          function Kn() {
          }
          function Xn(e3, t4) {
            return An().memoizedState = [e3, void 0 === t4 ? null : t4], e3;
          }
          function Yn(e3, t4) {
            var n3 = Un();
            t4 = void 0 === t4 ? null : t4;
            var r3 = n3.memoizedState;
            return null !== r3 && null !== t4 && Nn(t4, r3[1]) ? r3[0] : (n3.memoizedState = [e3, t4], e3);
          }
          function Jn(e3, t4, n3) {
            if (!(25 > In))
              throw Error(l(301));
            var r3 = e3.alternate;
            if (e3 === wn || null !== r3 && r3 === wn)
              if (Cn = true, e3 = { expirationTime: xn, suspenseConfig: null, action: n3, eagerReducer: null, eagerState: null, next: null }, null === zn && (zn = /* @__PURE__ */ new Map()), void 0 === (n3 = zn.get(t4)))
                zn.set(t4, e3);
              else {
                for (t4 = n3; null !== t4.next; )
                  t4 = t4.next;
                t4.next = e3;
              }
            else {
              var i3 = Ui(), o3 = Qt.suspense;
              o3 = { expirationTime: i3 = Fi(i3, e3, o3), suspenseConfig: o3, action: n3, eagerReducer: null, eagerState: null, next: null };
              var a3 = t4.last;
              if (null === a3)
                o3.next = o3;
              else {
                var u2 = a3.next;
                null !== u2 && (o3.next = u2), a3.next = o3;
              }
              if (t4.last = o3, 0 === e3.expirationTime && (null === r3 || 0 === r3.expirationTime) && null !== (r3 = t4.lastRenderedReducer))
                try {
                  var c2 = t4.lastRenderedState, s2 = r3(c2, n3);
                  if (o3.eagerReducer = r3, o3.eagerState = s2, gt(s2, c2))
                    return;
                } catch (e4) {
                }
              Di(e3, i3);
            }
          }
          var Zn = { readContext: It, useCallback: Mn, useContext: Mn, useEffect: Mn, useImperativeHandle: Mn, useLayoutEffect: Mn, useMemo: Mn, useReducer: Mn, useRef: Mn, useState: Mn, useDebugValue: Mn, useResponder: Mn, useDeferredValue: Mn, useTransition: Mn }, er = { readContext: It, useCallback: Xn, useContext: It, useEffect: Vn, useImperativeHandle: function(e3, t4, n3) {
            return n3 = null != n3 ? n3.concat([e3]) : null, qn(4, 36, $n.bind(null, t4, e3), n3);
          }, useLayoutEffect: function(e3, t4) {
            return qn(4, 36, e3, t4);
          }, useMemo: function(e3, t4) {
            var n3 = An();
            return t4 = void 0 === t4 ? null : t4, e3 = e3(), n3.memoizedState = [e3, t4], e3;
          }, useReducer: function(e3, t4, n3) {
            var r3 = An();
            return t4 = void 0 !== n3 ? n3(t4) : t4, r3.memoizedState = r3.baseState = t4, e3 = (e3 = r3.queue = { last: null, dispatch: null, lastRenderedReducer: e3, lastRenderedState: t4 }).dispatch = Jn.bind(null, wn, e3), [r3.memoizedState, e3];
          }, useRef: function(e3) {
            return e3 = { current: e3 }, An().memoizedState = e3;
          }, useState: Wn, useDebugValue: Kn, useResponder: bn, useDeferredValue: function(e3, t4) {
            var n3 = Wn(e3), r3 = n3[0], i3 = n3[1];
            return Vn(function() {
              a2.unstable_next(function() {
                var n4 = gn.suspense;
                gn.suspense = void 0 === t4 ? null : t4;
                try {
                  i3(e3);
                } finally {
                  gn.suspense = n4;
                }
              });
            }, [e3, t4]), r3;
          }, useTransition: function(e3) {
            var t4 = Wn(false), n3 = t4[0], r3 = t4[1];
            return [Xn(function(t5) {
              r3(true), a2.unstable_next(function() {
                var n4 = gn.suspense;
                gn.suspense = void 0 === e3 ? null : e3;
                try {
                  r3(false), t5();
                } finally {
                  gn.suspense = n4;
                }
              });
            }, [e3, n3]), n3];
          } }, tr = { readContext: It, useCallback: Yn, useContext: It, useEffect: Gn, useImperativeHandle: function(e3, t4, n3) {
            return n3 = null != n3 ? n3.concat([e3]) : null, Qn(4, 36, $n.bind(null, t4, e3), n3);
          }, useLayoutEffect: function(e3, t4) {
            return Qn(4, 36, e3, t4);
          }, useMemo: function(e3, t4) {
            var n3 = Un();
            t4 = void 0 === t4 ? null : t4;
            var r3 = n3.memoizedState;
            return null !== r3 && null !== t4 && Nn(t4, r3[1]) ? r3[0] : (e3 = e3(), n3.memoizedState = [e3, t4], e3);
          }, useReducer: Dn, useRef: function() {
            return Un().memoizedState;
          }, useState: Bn, useDebugValue: Kn, useResponder: bn, useDeferredValue: function(e3, t4) {
            var n3 = Bn(), r3 = n3[0], i3 = n3[1];
            return Gn(function() {
              a2.unstable_next(function() {
                var n4 = gn.suspense;
                gn.suspense = void 0 === t4 ? null : t4;
                try {
                  i3(e3);
                } finally {
                  gn.suspense = n4;
                }
              });
            }, [e3, t4]), r3;
          }, useTransition: function(e3) {
            var t4 = Bn(), n3 = t4[0], r3 = t4[1];
            return [Yn(function(t5) {
              r3(true), a2.unstable_next(function() {
                var n4 = gn.suspense;
                gn.suspense = void 0 === e3 ? null : e3;
                try {
                  r3(false), t5();
                } finally {
                  gn.suspense = n4;
                }
              });
            }, [e3, n3]), n3];
          } }, nr = null, rr = null, ir = false;
          function or(e3, t4) {
            var n3 = po(5, null, null, 0);
            n3.elementType = "DELETED", n3.type = "DELETED", n3.stateNode = t4, n3.return = e3, n3.effectTag = 8, null !== e3.lastEffect ? (e3.lastEffect.nextEffect = n3, e3.lastEffect = n3) : e3.firstEffect = e3.lastEffect = n3;
          }
          function ar(e3, t4) {
            switch (e3.tag) {
              case 5:
                return null !== (t4 = ve(t4, e3.type, e3.pendingProps)) && (e3.stateNode = t4, true);
              case 6:
                return null !== (t4 = be(t4, e3.pendingProps)) && (e3.stateNode = t4, true);
              case 13:
              default:
                return false;
            }
          }
          function lr(e3) {
            if (ir) {
              var t4 = rr;
              if (t4) {
                var n3 = t4;
                if (!ar(e3, t4)) {
                  if (!(t4 = xe(n3)) || !ar(e3, t4))
                    return e3.effectTag = -1025 & e3.effectTag | 2, ir = false, void (nr = e3);
                  or(nr, n3);
                }
                nr = e3, rr = we(t4);
              } else
                e3.effectTag = -1025 & e3.effectTag | 2, ir = false, nr = e3;
            }
          }
          function ur(e3) {
            for (e3 = e3.return; null !== e3 && 5 !== e3.tag && 3 !== e3.tag && 13 !== e3.tag; )
              e3 = e3.return;
            nr = e3;
          }
          function cr(e3) {
            if (!$ || e3 !== nr)
              return false;
            if (!ir)
              return ur(e3), ir = true, false;
            var t4 = e3.type;
            if (5 !== e3.tag || "head" !== t4 && "body" !== t4 && !F(t4, e3.memoizedProps))
              for (t4 = rr; t4; )
                or(e3, t4), t4 = xe(t4);
            if (ur(e3), 13 === e3.tag) {
              if (!$)
                throw Error(l(316));
              if (!(e3 = null !== (e3 = e3.memoizedState) ? e3.dehydrated : null))
                throw Error(l(317));
              rr = Te(e3);
            } else
              rr = nr ? xe(e3.stateNode) : null;
            return true;
          }
          function sr() {
            $ && (rr = nr = null, ir = false);
          }
          var fr = u.ReactCurrentOwner, pr = false;
          function dr(e3, t4, n3, r3) {
            t4.child = null === e3 ? on(t4, null, n3, r3) : rn(t4, e3.child, n3, r3);
          }
          function hr(e3, t4, n3, r3, i3) {
            n3 = n3.render;
            var o3 = t4.ref;
            return zt(t4, i3), r3 = Ln(e3, t4, n3, r3, o3, i3), null === e3 || pr ? (t4.effectTag |= 1, dr(e3, t4, r3, i3), t4.child) : (t4.updateQueue = e3.updateQueue, t4.effectTag &= -517, e3.expirationTime <= i3 && (e3.expirationTime = 0), zr(e3, t4, i3));
          }
          function mr(e3, t4, n3, r3, i3, o3) {
            if (null === e3) {
              var a3 = n3.type;
              return "function" != typeof a3 || ho(a3) || void 0 !== a3.defaultProps || null !== n3.compare || void 0 !== n3.defaultProps ? ((e3 = vo(n3.type, null, r3, null, t4.mode, o3)).ref = t4.ref, e3.return = t4, t4.child = e3) : (t4.tag = 15, t4.type = a3, vr(e3, t4, a3, r3, i3, o3));
            }
            return a3 = e3.child, i3 < o3 && (i3 = a3.memoizedProps, (n3 = null !== (n3 = n3.compare) ? n3 : wt)(i3, r3) && e3.ref === t4.ref) ? zr(e3, t4, o3) : (t4.effectTag |= 1, (e3 = mo(a3, r3)).ref = t4.ref, e3.return = t4, t4.child = e3);
          }
          function vr(e3, t4, n3, r3, i3, o3) {
            return null !== e3 && wt(e3.memoizedProps, r3) && e3.ref === t4.ref && (pr = false, i3 < o3) ? zr(e3, t4, o3) : yr(e3, t4, n3, r3, o3);
          }
          function br(e3, t4) {
            var n3 = t4.ref;
            (null === e3 && null !== n3 || null !== e3 && e3.ref !== n3) && (t4.effectTag |= 128);
          }
          function yr(e3, t4, n3, r3, i3) {
            var o3 = Ue(n3) ? Re : Ne.current;
            return o3 = Ae(t4, o3), zt(t4, i3), n3 = Ln(e3, t4, n3, r3, o3, i3), null === e3 || pr ? (t4.effectTag |= 1, dr(e3, t4, n3, i3), t4.child) : (t4.updateQueue = e3.updateQueue, t4.effectTag &= -517, e3.expirationTime <= i3 && (e3.expirationTime = 0), zr(e3, t4, i3));
          }
          function gr(e3, t4, n3, r3, i3) {
            if (Ue(n3)) {
              var o3 = true;
              He(t4);
            } else
              o3 = false;
            if (zt(t4, i3), null === t4.stateNode)
              null !== e3 && (e3.alternate = null, t4.alternate = null, t4.effectTag |= 2), Xt(t4, n3, r3), Jt(t4, n3, r3, i3), r3 = true;
            else if (null === e3) {
              var a3 = t4.stateNode, l2 = t4.memoizedProps;
              a3.props = l2;
              var u2 = a3.context, c2 = n3.contextType;
              "object" == typeof c2 && null !== c2 ? c2 = It(c2) : c2 = Ae(t4, c2 = Ue(n3) ? Re : Ne.current);
              var s2 = n3.getDerivedStateFromProps, f2 = "function" == typeof s2 || "function" == typeof a3.getSnapshotBeforeUpdate;
              f2 || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (l2 !== r3 || u2 !== c2) && Yt(t4, a3, r3, c2), Mt = false;
              var p2 = t4.memoizedState;
              u2 = a3.state = p2;
              var d2 = t4.updateQueue;
              null !== d2 && (Bt(t4, d2, r3, a3, i3), u2 = t4.memoizedState), l2 !== r3 || p2 !== u2 || Le.current || Mt ? ("function" == typeof s2 && (Gt(t4, n3, s2, r3), u2 = t4.memoizedState), (l2 = Mt || Kt(t4, n3, l2, r3, p2, u2, c2)) ? (f2 || "function" != typeof a3.UNSAFE_componentWillMount && "function" != typeof a3.componentWillMount || ("function" == typeof a3.componentWillMount && a3.componentWillMount(), "function" == typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount()), "function" == typeof a3.componentDidMount && (t4.effectTag |= 4)) : ("function" == typeof a3.componentDidMount && (t4.effectTag |= 4), t4.memoizedProps = r3, t4.memoizedState = u2), a3.props = r3, a3.state = u2, a3.context = c2, r3 = l2) : ("function" == typeof a3.componentDidMount && (t4.effectTag |= 4), r3 = false);
            } else
              a3 = t4.stateNode, l2 = t4.memoizedProps, a3.props = t4.type === t4.elementType ? l2 : Et(t4.type, l2), u2 = a3.context, "object" == typeof (c2 = n3.contextType) && null !== c2 ? c2 = It(c2) : c2 = Ae(t4, c2 = Ue(n3) ? Re : Ne.current), (f2 = "function" == typeof (s2 = n3.getDerivedStateFromProps) || "function" == typeof a3.getSnapshotBeforeUpdate) || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (l2 !== r3 || u2 !== c2) && Yt(t4, a3, r3, c2), Mt = false, u2 = t4.memoizedState, p2 = a3.state = u2, null !== (d2 = t4.updateQueue) && (Bt(t4, d2, r3, a3, i3), p2 = t4.memoizedState), l2 !== r3 || u2 !== p2 || Le.current || Mt ? ("function" == typeof s2 && (Gt(t4, n3, s2, r3), p2 = t4.memoizedState), (s2 = Mt || Kt(t4, n3, l2, r3, u2, p2, c2)) ? (f2 || "function" != typeof a3.UNSAFE_componentWillUpdate && "function" != typeof a3.componentWillUpdate || ("function" == typeof a3.componentWillUpdate && a3.componentWillUpdate(r3, p2, c2), "function" == typeof a3.UNSAFE_componentWillUpdate && a3.UNSAFE_componentWillUpdate(r3, p2, c2)), "function" == typeof a3.componentDidUpdate && (t4.effectTag |= 4), "function" == typeof a3.getSnapshotBeforeUpdate && (t4.effectTag |= 256)) : ("function" != typeof a3.componentDidUpdate || l2 === e3.memoizedProps && u2 === e3.memoizedState || (t4.effectTag |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || l2 === e3.memoizedProps && u2 === e3.memoizedState || (t4.effectTag |= 256), t4.memoizedProps = r3, t4.memoizedState = p2), a3.props = r3, a3.state = p2, a3.context = c2, r3 = s2) : ("function" != typeof a3.componentDidUpdate || l2 === e3.memoizedProps && u2 === e3.memoizedState || (t4.effectTag |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || l2 === e3.memoizedProps && u2 === e3.memoizedState || (t4.effectTag |= 256), r3 = false);
            return xr(e3, t4, n3, r3, o3, i3);
          }
          function xr(e3, t4, n3, r3, i3, o3) {
            br(e3, t4);
            var a3 = 0 != (64 & t4.effectTag);
            if (!r3 && !a3)
              return i3 && qe(t4, n3, false), zr(e3, t4, o3);
            r3 = t4.stateNode, fr.current = t4;
            var l2 = a3 && "function" != typeof n3.getDerivedStateFromError ? null : r3.render();
            return t4.effectTag |= 1, null !== e3 && a3 ? (t4.child = rn(t4, e3.child, null, o3), t4.child = rn(t4, null, l2, o3)) : dr(e3, t4, l2, o3), t4.memoizedState = r3.state, i3 && qe(t4, n3, true), t4.child;
          }
          function wr(e3) {
            var t4 = e3.stateNode;
            t4.pendingContext ? We(0, t4.pendingContext, t4.pendingContext !== t4.context) : t4.context && We(0, t4.context, false), fn(e3, t4.containerInfo);
          }
          var Er, Or, Tr, Sr, _r = { dehydrated: null, retryTime: 0 };
          function kr(e3, t4, n3) {
            var r3, i3 = t4.mode, o3 = t4.pendingProps, a3 = mn.current, l2 = false;
            if ((r3 = 0 != (64 & t4.effectTag)) || (r3 = 0 != (2 & a3) && (null === e3 || null !== e3.memoizedState)), r3 ? (l2 = true, t4.effectTag &= -65) : null !== e3 && null === e3.memoizedState || void 0 === o3.fallback || true === o3.unstable_avoidThisFallback || (a3 |= 1), Ie(mn, 1 & a3), null === e3) {
              if (void 0 !== o3.fallback && lr(t4), l2) {
                if (l2 = o3.fallback, (o3 = bo(null, i3, 0, null)).return = t4, 0 == (2 & t4.mode))
                  for (e3 = null !== t4.memoizedState ? t4.child.child : t4.child, o3.child = e3; null !== e3; )
                    e3.return = o3, e3 = e3.sibling;
                return (n3 = bo(l2, i3, n3, null)).return = t4, o3.sibling = n3, t4.memoizedState = _r, t4.child = o3, n3;
              }
              return i3 = o3.children, t4.memoizedState = null, t4.child = on(t4, null, i3, n3);
            }
            if (null !== e3.memoizedState) {
              if (i3 = (e3 = e3.child).sibling, l2) {
                if (o3 = o3.fallback, (n3 = mo(e3, e3.pendingProps)).return = t4, 0 == (2 & t4.mode) && (l2 = null !== t4.memoizedState ? t4.child.child : t4.child) !== e3.child)
                  for (n3.child = l2; null !== l2; )
                    l2.return = n3, l2 = l2.sibling;
                return (i3 = mo(i3, o3, i3.expirationTime)).return = t4, n3.sibling = i3, n3.childExpirationTime = 0, t4.memoizedState = _r, t4.child = n3, i3;
              }
              return n3 = rn(t4, e3.child, o3.children, n3), t4.memoizedState = null, t4.child = n3;
            }
            if (e3 = e3.child, l2) {
              if (l2 = o3.fallback, (o3 = bo(null, i3, 0, null)).return = t4, o3.child = e3, null !== e3 && (e3.return = o3), 0 == (2 & t4.mode))
                for (e3 = null !== t4.memoizedState ? t4.child.child : t4.child, o3.child = e3; null !== e3; )
                  e3.return = o3, e3 = e3.sibling;
              return (n3 = bo(l2, i3, n3, null)).return = t4, o3.sibling = n3, n3.effectTag |= 2, o3.childExpirationTime = 0, t4.memoizedState = _r, t4.child = o3, n3;
            }
            return t4.memoizedState = null, t4.child = rn(t4, e3, o3.children, n3);
          }
          function jr(e3, t4) {
            e3.expirationTime < t4 && (e3.expirationTime = t4);
            var n3 = e3.alternate;
            null !== n3 && n3.expirationTime < t4 && (n3.expirationTime = t4), Ct(e3.return, t4);
          }
          function Pr(e3, t4, n3, r3, i3, o3) {
            var a3 = e3.memoizedState;
            null === a3 ? e3.memoizedState = { isBackwards: t4, rendering: null, last: r3, tail: n3, tailExpiration: 0, tailMode: i3, lastEffect: o3 } : (a3.isBackwards = t4, a3.rendering = null, a3.last = r3, a3.tail = n3, a3.tailExpiration = 0, a3.tailMode = i3, a3.lastEffect = o3);
          }
          function Cr(e3, t4, n3) {
            var r3 = t4.pendingProps, i3 = r3.revealOrder, o3 = r3.tail;
            if (dr(e3, t4, r3.children, n3), 0 != (2 & (r3 = mn.current)))
              r3 = 1 & r3 | 2, t4.effectTag |= 64;
            else {
              if (null !== e3 && 0 != (64 & e3.effectTag))
                e:
                  for (e3 = t4.child; null !== e3; ) {
                    if (13 === e3.tag)
                      null !== e3.memoizedState && jr(e3, n3);
                    else if (19 === e3.tag)
                      jr(e3, n3);
                    else if (null !== e3.child) {
                      e3.child.return = e3, e3 = e3.child;
                      continue;
                    }
                    if (e3 === t4)
                      break e;
                    for (; null === e3.sibling; ) {
                      if (null === e3.return || e3.return === t4)
                        break e;
                      e3 = e3.return;
                    }
                    e3.sibling.return = e3.return, e3 = e3.sibling;
                  }
              r3 &= 1;
            }
            if (Ie(mn, r3), 0 == (2 & t4.mode))
              t4.memoizedState = null;
            else
              switch (i3) {
                case "forwards":
                  for (n3 = t4.child, i3 = null; null !== n3; )
                    null !== (e3 = n3.alternate) && null === vn(e3) && (i3 = n3), n3 = n3.sibling;
                  null === (n3 = i3) ? (i3 = t4.child, t4.child = null) : (i3 = n3.sibling, n3.sibling = null), Pr(t4, false, i3, n3, o3, t4.lastEffect);
                  break;
                case "backwards":
                  for (n3 = null, i3 = t4.child, t4.child = null; null !== i3; ) {
                    if (null !== (e3 = i3.alternate) && null === vn(e3)) {
                      t4.child = i3;
                      break;
                    }
                    e3 = i3.sibling, i3.sibling = n3, n3 = i3, i3 = e3;
                  }
                  Pr(t4, true, n3, null, o3, t4.lastEffect);
                  break;
                case "together":
                  Pr(t4, false, null, null, void 0, t4.lastEffect);
                  break;
                default:
                  t4.memoizedState = null;
              }
            return t4.child;
          }
          function zr(e3, t4, n3) {
            null !== e3 && (t4.dependencies = e3.dependencies);
            var r3 = t4.expirationTime;
            if (0 !== r3 && Xi(r3), t4.childExpirationTime < n3)
              return null;
            if (null !== e3 && t4.child !== e3.child)
              throw Error(l(153));
            if (null !== t4.child) {
              for (n3 = mo(e3 = t4.child, e3.pendingProps, e3.expirationTime), t4.child = n3, n3.return = t4; null !== e3.sibling; )
                e3 = e3.sibling, (n3 = n3.sibling = mo(e3, e3.pendingProps, e3.expirationTime)).return = t4;
              n3.sibling = null;
            }
            return t4.child;
          }
          function Ir(e3) {
            e3.effectTag |= 4;
          }
          if (V)
            Er = function(e3, t4) {
              for (var n3 = t4.child; null !== n3; ) {
                if (5 === n3.tag || 6 === n3.tag)
                  R(e3, n3.stateNode);
                else if (4 !== n3.tag && null !== n3.child) {
                  n3.child.return = n3, n3 = n3.child;
                  continue;
                }
                if (n3 === t4)
                  break;
                for (; null === n3.sibling; ) {
                  if (null === n3.return || n3.return === t4)
                    return;
                  n3 = n3.return;
                }
                n3.sibling.return = n3.return, n3 = n3.sibling;
              }
            }, Or = function() {
            }, Tr = function(e3, t4, n3, r3, i3) {
              if ((e3 = e3.memoizedProps) !== r3) {
                var o3 = t4.stateNode, a3 = sn(ln2.current);
                n3 = U(o3, n3, e3, r3, i3, a3), (t4.updateQueue = n3) && Ir(t4);
              }
            }, Sr = function(e3, t4, n3, r3) {
              n3 !== r3 && Ir(t4);
            };
          else if (G) {
            Er = function(e3, t4, n3, r3) {
              for (var i3 = t4.child; null !== i3; ) {
                if (5 === i3.tag) {
                  var o3 = i3.stateNode;
                  n3 && r3 && (o3 = he(o3, i3.type, i3.memoizedProps, i3)), R(e3, o3);
                } else if (6 === i3.tag)
                  o3 = i3.stateNode, n3 && r3 && (o3 = me(o3, i3.memoizedProps, i3)), R(e3, o3);
                else if (4 !== i3.tag) {
                  if (13 === i3.tag && 0 != (4 & i3.effectTag) && (o3 = null !== i3.memoizedState)) {
                    var a3 = i3.child;
                    if (null !== a3 && (null !== a3.child && (a3.child.return = a3, Er(e3, a3, true, o3)), null !== (o3 = a3.sibling))) {
                      o3.return = i3, i3 = o3;
                      continue;
                    }
                  }
                  if (null !== i3.child) {
                    i3.child.return = i3, i3 = i3.child;
                    continue;
                  }
                }
                if (i3 === t4)
                  break;
                for (; null === i3.sibling; ) {
                  if (null === i3.return || i3.return === t4)
                    return;
                  i3 = i3.return;
                }
                i3.sibling.return = i3.return, i3 = i3.sibling;
              }
            };
            var Mr = function(e3, t4, n3, r3) {
              for (var i3 = t4.child; null !== i3; ) {
                if (5 === i3.tag) {
                  var o3 = i3.stateNode;
                  n3 && r3 && (o3 = he(o3, i3.type, i3.memoizedProps, i3)), fe(e3, o3);
                } else if (6 === i3.tag)
                  o3 = i3.stateNode, n3 && r3 && (o3 = me(o3, i3.memoizedProps, i3)), fe(e3, o3);
                else if (4 !== i3.tag) {
                  if (13 === i3.tag && 0 != (4 & i3.effectTag) && (o3 = null !== i3.memoizedState)) {
                    var a3 = i3.child;
                    if (null !== a3 && (null !== a3.child && (a3.child.return = a3, Mr(e3, a3, true, o3)), null !== (o3 = a3.sibling))) {
                      o3.return = i3, i3 = o3;
                      continue;
                    }
                  }
                  if (null !== i3.child) {
                    i3.child.return = i3, i3 = i3.child;
                    continue;
                  }
                }
                if (i3 === t4)
                  break;
                for (; null === i3.sibling; ) {
                  if (null === i3.return || i3.return === t4)
                    return;
                  i3 = i3.return;
                }
                i3.sibling.return = i3.return, i3 = i3.sibling;
              }
            };
            Or = function(e3) {
              var t4 = e3.stateNode;
              if (null !== e3.firstEffect) {
                var n3 = t4.containerInfo, r3 = se(n3);
                Mr(r3, e3, false, false), t4.pendingChildren = r3, Ir(e3), pe(n3, r3);
              }
            }, Tr = function(e3, t4, n3, r3, i3) {
              var o3 = e3.stateNode, a3 = e3.memoizedProps;
              if ((e3 = null === t4.firstEffect) && a3 === r3)
                t4.stateNode = o3;
              else {
                var l2 = t4.stateNode, u2 = sn(ln2.current), c2 = null;
                a3 !== r3 && (c2 = U(l2, n3, a3, r3, i3, u2)), e3 && null === c2 ? t4.stateNode = o3 : (o3 = ce(o3, c2, n3, a3, r3, t4, e3, l2), A(o3, n3, r3, i3, u2) && Ir(t4), t4.stateNode = o3, e3 ? Ir(t4) : Er(o3, t4, false, false));
              }
            }, Sr = function(e3, t4, n3, r3) {
              n3 !== r3 && (e3 = sn(cn.current), n3 = sn(ln2.current), t4.stateNode = W(r3, e3, n3, t4), Ir(t4));
            };
          } else
            Or = function() {
            }, Tr = function() {
            }, Sr = function() {
            };
          function Nr(e3, t4) {
            switch (e3.tailMode) {
              case "hidden":
                t4 = e3.tail;
                for (var n3 = null; null !== t4; )
                  null !== t4.alternate && (n3 = t4), t4 = t4.sibling;
                null === n3 ? e3.tail = null : n3.sibling = null;
                break;
              case "collapsed":
                n3 = e3.tail;
                for (var r3 = null; null !== n3; )
                  null !== n3.alternate && (r3 = n3), n3 = n3.sibling;
                null === r3 ? t4 || null === e3.tail ? e3.tail = null : e3.tail.sibling = null : r3.sibling = null;
            }
          }
          function Lr(e3) {
            switch (e3.tag) {
              case 1:
                Ue(e3.type) && Fe();
                var t4 = e3.effectTag;
                return 4096 & t4 ? (e3.effectTag = -4097 & t4 | 64, e3) : null;
              case 3:
                if (pn(), De(), 0 != (64 & (t4 = e3.effectTag)))
                  throw Error(l(285));
                return e3.effectTag = -4097 & t4 | 64, e3;
              case 5:
                return hn(e3), null;
              case 13:
                return ze(mn), 4096 & (t4 = e3.effectTag) ? (e3.effectTag = -4097 & t4 | 64, e3) : null;
              case 19:
                return ze(mn), null;
              case 4:
                return pn(), null;
              case 10:
                return Pt(e3), null;
              default:
                return null;
            }
          }
          function Rr(e3, t4) {
            return { value: e3, source: t4, stack: je(t4) };
          }
          var Ar = "function" == typeof WeakSet ? WeakSet : Set;
          function Ur(e3, t4) {
            var n3 = t4.source, r3 = t4.stack;
            null === r3 && null !== n3 && (r3 = je(n3)), null !== n3 && S(n3.type), t4 = t4.value, null !== e3 && 1 === e3.tag && S(e3.type);
            try {
              console.error(t4);
            } catch (e4) {
              setTimeout(function() {
                throw e4;
              });
            }
          }
          function Fr(e3) {
            var t4 = e3.ref;
            if (null !== t4)
              if ("function" == typeof t4)
                try {
                  t4(null);
                } catch (t5) {
                  lo(e3, t5);
                }
              else
                t4.current = null;
          }
          function Dr(e3, t4) {
            switch (t4.tag) {
              case 0:
              case 11:
              case 15:
                Wr(2, 0, t4);
                break;
              case 1:
                if (256 & t4.effectTag && null !== e3) {
                  var n3 = e3.memoizedProps, r3 = e3.memoizedState;
                  t4 = (e3 = t4.stateNode).getSnapshotBeforeUpdate(t4.elementType === t4.type ? n3 : Et(t4.type, n3), r3), e3.__reactInternalSnapshotBeforeUpdate = t4;
                }
                break;
              case 3:
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(l(163));
            }
          }
          function Wr(e3, t4, n3) {
            if (null !== (n3 = null !== (n3 = n3.updateQueue) ? n3.lastEffect : null)) {
              var r3 = n3 = n3.next;
              do {
                if (0 != (r3.tag & e3)) {
                  var i3 = r3.destroy;
                  r3.destroy = void 0, void 0 !== i3 && i3();
                }
                0 != (r3.tag & t4) && (i3 = r3.create, r3.destroy = i3()), r3 = r3.next;
              } while (r3 !== n3);
            }
          }
          function Br(e3, t4, n3) {
            switch ("function" == typeof so && so(t4), t4.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                if (null !== (e3 = t4.updateQueue) && null !== (e3 = e3.lastEffect)) {
                  var r3 = e3.next;
                  pt(97 < n3 ? 97 : n3, function() {
                    var e4 = r3;
                    do {
                      var n4 = e4.destroy;
                      if (void 0 !== n4) {
                        var i3 = t4;
                        try {
                          n4();
                        } catch (e5) {
                          lo(i3, e5);
                        }
                      }
                      e4 = e4.next;
                    } while (e4 !== r3);
                  });
                }
                break;
              case 1:
                Fr(t4), "function" == typeof (n3 = t4.stateNode).componentWillUnmount && function(e4, t5) {
                  try {
                    t5.props = e4.memoizedProps, t5.state = e4.memoizedState, t5.componentWillUnmount();
                  } catch (t6) {
                    lo(e4, t6);
                  }
                }(t4, n3);
                break;
              case 5:
                Fr(t4);
                break;
              case 4:
                V ? Gr(e3, t4, n3) : G && function(e4) {
                  if (G) {
                    e4 = e4.stateNode.containerInfo;
                    var t5 = se(e4);
                    de(e4, t5);
                  }
                }(t4);
            }
          }
          function Hr(e3, t4, n3) {
            for (var r3 = t4; ; )
              if (Br(e3, r3, n3), null === r3.child || V && 4 === r3.tag) {
                if (r3 === t4)
                  break;
                for (; null === r3.sibling; ) {
                  if (null === r3.return || r3.return === t4)
                    return;
                  r3 = r3.return;
                }
                r3.sibling.return = r3.return, r3 = r3.sibling;
              } else
                r3.child.return = r3, r3 = r3.child;
          }
          function qr(e3) {
            var t4 = e3.alternate;
            e3.return = null, e3.child = null, e3.memoizedState = null, e3.updateQueue = null, e3.dependencies = null, e3.alternate = null, e3.firstEffect = null, e3.lastEffect = null, e3.pendingProps = null, e3.memoizedProps = null, null !== t4 && qr(t4);
          }
          function Qr(e3) {
            return 5 === e3.tag || 3 === e3.tag || 4 === e3.tag;
          }
          function Vr(e3) {
            if (V) {
              e: {
                for (var t4 = e3.return; null !== t4; ) {
                  if (Qr(t4)) {
                    var n3 = t4;
                    break e;
                  }
                  t4 = t4.return;
                }
                throw Error(l(160));
              }
              switch (t4 = n3.stateNode, n3.tag) {
                case 5:
                  var r3 = false;
                  break;
                case 3:
                case 4:
                  t4 = t4.containerInfo, r3 = true;
                  break;
                default:
                  throw Error(l(161));
              }
              16 & n3.effectTag && (ie(t4), n3.effectTag &= -17);
              e:
                t:
                  for (n3 = e3; ; ) {
                    for (; null === n3.sibling; ) {
                      if (null === n3.return || Qr(n3.return)) {
                        n3 = null;
                        break e;
                      }
                      n3 = n3.return;
                    }
                    for (n3.sibling.return = n3.return, n3 = n3.sibling; 5 !== n3.tag && 6 !== n3.tag && 18 !== n3.tag; ) {
                      if (2 & n3.effectTag)
                        continue t;
                      if (null === n3.child || 4 === n3.tag)
                        continue t;
                      n3.child.return = n3, n3 = n3.child;
                    }
                    if (!(2 & n3.effectTag)) {
                      n3 = n3.stateNode;
                      break e;
                    }
                  }
              for (var i3 = e3; ; ) {
                var o3 = 5 === i3.tag || 6 === i3.tag;
                if (o3)
                  o3 = o3 ? i3.stateNode : i3.stateNode.instance, n3 ? r3 ? te2(t4, o3, n3) : ee(t4, o3, n3) : r3 ? X(t4, o3) : K(t4, o3);
                else if (4 !== i3.tag && null !== i3.child) {
                  i3.child.return = i3, i3 = i3.child;
                  continue;
                }
                if (i3 === e3)
                  break;
                for (; null === i3.sibling; ) {
                  if (null === i3.return || i3.return === e3)
                    return;
                  i3 = i3.return;
                }
                i3.sibling.return = i3.return, i3 = i3.sibling;
              }
            }
          }
          function Gr(e3, t4, n3) {
            for (var r3, i3, o3 = t4, a3 = false; ; ) {
              if (!a3) {
                a3 = o3.return;
                e:
                  for (; ; ) {
                    if (null === a3)
                      throw Error(l(160));
                    switch (r3 = a3.stateNode, a3.tag) {
                      case 5:
                        i3 = false;
                        break e;
                      case 3:
                      case 4:
                        r3 = r3.containerInfo, i3 = true;
                        break e;
                    }
                    a3 = a3.return;
                  }
                a3 = true;
              }
              if (5 === o3.tag || 6 === o3.tag)
                Hr(e3, o3, n3), i3 ? re(r3, o3.stateNode) : ne(r3, o3.stateNode);
              else if (4 === o3.tag) {
                if (null !== o3.child) {
                  r3 = o3.stateNode.containerInfo, i3 = true, o3.child.return = o3, o3 = o3.child;
                  continue;
                }
              } else if (Br(e3, o3, n3), null !== o3.child) {
                o3.child.return = o3, o3 = o3.child;
                continue;
              }
              if (o3 === t4)
                break;
              for (; null === o3.sibling; ) {
                if (null === o3.return || o3.return === t4)
                  return;
                4 === (o3 = o3.return).tag && (a3 = false);
              }
              o3.sibling.return = o3.return, o3 = o3.sibling;
            }
          }
          function $r(e3, t4) {
            if (V)
              switch (t4.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Wr(4, 8, t4);
                  break;
                case 1:
                  break;
                case 5:
                  var n3 = t4.stateNode;
                  if (null != n3) {
                    var r3 = t4.memoizedProps;
                    e3 = null !== e3 ? e3.memoizedProps : r3;
                    var i3 = t4.type, o3 = t4.updateQueue;
                    t4.updateQueue = null, null !== o3 && Z(n3, o3, i3, e3, r3, t4);
                  }
                  break;
                case 6:
                  if (null === t4.stateNode)
                    throw Error(l(162));
                  n3 = t4.memoizedProps, Y(t4.stateNode, null !== e3 ? e3.memoizedProps : n3, n3);
                  break;
                case 3:
                  $ && ((t4 = t4.stateNode).hydrate && (t4.hydrate = false, Se(t4.containerInfo)));
                  break;
                case 12:
                  break;
                case 13:
                  Kr(t4), Xr(t4);
                  break;
                case 19:
                  Xr(t4);
                  break;
                case 17:
                case 20:
                case 21:
                  break;
                default:
                  throw Error(l(163));
              }
            else {
              switch (t4.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  return void Wr(4, 8, t4);
                case 12:
                  return;
                case 13:
                  return Kr(t4), void Xr(t4);
                case 19:
                  return void Xr(t4);
                case 3:
                  $ && ((n3 = t4.stateNode).hydrate && (n3.hydrate = false, Se(n3.containerInfo)));
              }
              e:
                if (G)
                  switch (t4.tag) {
                    case 1:
                    case 5:
                    case 6:
                    case 20:
                      break e;
                    case 3:
                    case 4:
                      t4 = t4.stateNode, de(t4.containerInfo, t4.pendingChildren);
                      break e;
                    default:
                      throw Error(l(163));
                  }
            }
          }
          function Kr(e3) {
            var t4 = e3;
            if (null === e3.memoizedState)
              var n3 = false;
            else
              n3 = true, t4 = e3.child, Si = ct();
            if (V && null !== t4) {
              e:
                if (e3 = t4, V)
                  for (t4 = e3; ; ) {
                    if (5 === t4.tag) {
                      var r3 = t4.stateNode;
                      n3 ? oe(r3) : le(t4.stateNode, t4.memoizedProps);
                    } else if (6 === t4.tag)
                      r3 = t4.stateNode, n3 ? ae(r3) : ue(r3, t4.memoizedProps);
                    else {
                      if (13 === t4.tag && null !== t4.memoizedState && null === t4.memoizedState.dehydrated) {
                        (r3 = t4.child.sibling).return = t4, t4 = r3;
                        continue;
                      }
                      if (null !== t4.child) {
                        t4.child.return = t4, t4 = t4.child;
                        continue;
                      }
                    }
                    if (t4 === e3)
                      break e;
                    for (; null === t4.sibling; ) {
                      if (null === t4.return || t4.return === e3)
                        break e;
                      t4 = t4.return;
                    }
                    t4.sibling.return = t4.return, t4 = t4.sibling;
                  }
            }
          }
          function Xr(e3) {
            var t4 = e3.updateQueue;
            if (null !== t4) {
              e3.updateQueue = null;
              var n3 = e3.stateNode;
              null === n3 && (n3 = e3.stateNode = new Ar()), t4.forEach(function(t5) {
                var r3 = function(e4, t6) {
                  var n4 = e4.stateNode;
                  null !== n4 && n4.delete(t6), 0 == (t6 = 0) && (t6 = Fi(t6 = Ui(), e4, null)), null !== (e4 = Wi(e4, t6)) && Hi(e4);
                }.bind(null, e3, t5);
                n3.has(t5) || (n3.add(t5), t5.then(r3, r3));
              });
            }
          }
          var Yr = "function" == typeof WeakMap ? WeakMap : Map;
          function Jr(e3, t4, n3) {
            (n3 = Rt(n3, null)).tag = 3, n3.payload = { element: null };
            var r3 = t4.value;
            return n3.callback = function() {
              ji || (ji = true, Pi = r3), Ur(e3, t4);
            }, n3;
          }
          function Zr(e3, t4, n3) {
            (n3 = Rt(n3, null)).tag = 3;
            var r3 = e3.type.getDerivedStateFromError;
            if ("function" == typeof r3) {
              var i3 = t4.value;
              n3.payload = function() {
                return Ur(e3, t4), r3(i3);
              };
            }
            var o3 = e3.stateNode;
            return null !== o3 && "function" == typeof o3.componentDidCatch && (n3.callback = function() {
              "function" != typeof r3 && (null === Ci ? Ci = /* @__PURE__ */ new Set([this]) : Ci.add(this), Ur(e3, t4));
              var n4 = t4.stack;
              this.componentDidCatch(t4.value, { componentStack: null !== n4 ? n4 : "" });
            }), n3;
          }
          var ei, ti = Math.ceil, ni = u.ReactCurrentDispatcher, ri = u.ReactCurrentOwner, ii = 0, oi = 8, ai = 16, li = 32, ui = 0, ci = 1, si = 2, fi = 3, pi = 4, di = 5, hi = ii, mi = null, vi = null, bi = 0, yi = ui, gi = null, xi = 1073741823, wi = 1073741823, Ei = null, Oi = 0, Ti = false, Si = 0, _i = 500, ki = null, ji = false, Pi = null, Ci = null, zi = false, Ii = null, Mi = 90, Ni = null, Li = 0, Ri = null, Ai = 0;
          function Ui() {
            return (hi & (ai | li)) !== ii ? 1073741821 - (ct() / 10 | 0) : 0 !== Ai ? Ai : Ai = 1073741821 - (ct() / 10 | 0);
          }
          function Fi(e3, t4, n3) {
            if (0 == (2 & (t4 = t4.mode)))
              return 1073741823;
            var r3 = st();
            if (0 == (4 & t4))
              return 99 === r3 ? 1073741823 : 1073741822;
            if ((hi & ai) !== ii)
              return bi;
            if (null !== n3)
              e3 = yt(e3, 0 | n3.timeoutMs || 5e3, 250);
            else
              switch (r3) {
                case 99:
                  e3 = 1073741823;
                  break;
                case 98:
                  e3 = yt(e3, 150, 100);
                  break;
                case 97:
                case 96:
                  e3 = yt(e3, 5e3, 250);
                  break;
                case 95:
                  e3 = 2;
                  break;
                default:
                  throw Error(l(326));
              }
            return null !== mi && e3 === bi && --e3, e3;
          }
          function Di(e3, t4) {
            if (50 < Li)
              throw Li = 0, Ri = null, Error(l(185));
            if (null !== (e3 = Wi(e3, t4))) {
              var n3 = st();
              1073741823 === t4 ? (hi & oi) !== ii && (hi & (ai | li)) === ii ? qi(e3) : (Hi(e3), hi === ii && mt()) : Hi(e3), (4 & hi) === ii || 98 !== n3 && 99 !== n3 || (null === Ni ? Ni = /* @__PURE__ */ new Map([[e3, t4]]) : (void 0 === (n3 = Ni.get(e3)) || n3 > t4) && Ni.set(e3, t4));
            }
          }
          function Wi(e3, t4) {
            e3.expirationTime < t4 && (e3.expirationTime = t4);
            var n3 = e3.alternate;
            null !== n3 && n3.expirationTime < t4 && (n3.expirationTime = t4);
            var r3 = e3.return, i3 = null;
            if (null === r3 && 3 === e3.tag)
              i3 = e3.stateNode;
            else
              for (; null !== r3; ) {
                if (n3 = r3.alternate, r3.childExpirationTime < t4 && (r3.childExpirationTime = t4), null !== n3 && n3.childExpirationTime < t4 && (n3.childExpirationTime = t4), null === r3.return && 3 === r3.tag) {
                  i3 = r3.stateNode;
                  break;
                }
                r3 = r3.return;
              }
            return null !== i3 && (mi === i3 && (Xi(t4), yi === pi && Eo(i3, bi)), Oo(i3, t4)), i3;
          }
          function Bi(e3) {
            var t4 = e3.lastExpiredTime;
            return 0 !== t4 ? t4 : wo(e3, t4 = e3.firstPendingTime) ? (t4 = e3.lastPingedTime) > (e3 = e3.nextKnownPendingLevel) ? t4 : e3 : t4;
          }
          function Hi(e3) {
            if (0 !== e3.lastExpiredTime)
              e3.callbackExpirationTime = 1073741823, e3.callbackPriority = 99, e3.callbackNode = ht(qi.bind(null, e3));
            else {
              var t4 = Bi(e3), n3 = e3.callbackNode;
              if (0 === t4)
                null !== n3 && (e3.callbackNode = null, e3.callbackExpirationTime = 0, e3.callbackPriority = 90);
              else {
                var r3 = Ui();
                if (1073741823 === t4 ? r3 = 99 : 1 === t4 || 2 === t4 ? r3 = 95 : r3 = 0 >= (r3 = 10 * (1073741821 - t4) - 10 * (1073741821 - r3)) ? 99 : 250 >= r3 ? 98 : 5250 >= r3 ? 97 : 95, null !== n3) {
                  var i3 = e3.callbackPriority;
                  if (e3.callbackExpirationTime === t4 && i3 >= r3)
                    return;
                  n3 !== rt && Ge(n3);
                }
                e3.callbackExpirationTime = t4, e3.callbackPriority = r3, t4 = 1073741823 === t4 ? ht(qi.bind(null, e3)) : dt(r3, function e4(t5, n4) {
                  Ai = 0;
                  if (n4)
                    return n4 = Ui(), To(t5, n4), Hi(t5), null;
                  var r4 = Bi(t5);
                  if (0 !== r4) {
                    if (n4 = t5.callbackNode, (hi & (ai | li)) !== ii)
                      throw Error(l(327));
                    if (io(), t5 === mi && r4 === bi || Vi(t5, r4), null !== vi) {
                      var i4 = hi;
                      hi |= ai;
                      for (var o3 = $i(); ; )
                        try {
                          Ji();
                          break;
                        } catch (e5) {
                          Gi(t5, e5);
                        }
                      if (kt(), hi = i4, ni.current = o3, yi === ci)
                        throw n4 = gi, Vi(t5, r4), Eo(t5, r4), Hi(t5), n4;
                      if (null === vi)
                        switch (o3 = t5.finishedWork = t5.current.alternate, t5.finishedExpirationTime = r4, i4 = yi, mi = null, i4) {
                          case ui:
                          case ci:
                            throw Error(l(345));
                          case si:
                            To(t5, 2 < r4 ? 2 : r4);
                            break;
                          case fi:
                            if (Eo(t5, r4), i4 = t5.lastSuspendedTime, r4 === i4 && (t5.nextKnownPendingLevel = to(o3)), 1073741823 === xi && 10 < (o3 = Si + _i - ct())) {
                              if (Ti) {
                                var a3 = t5.lastPingedTime;
                                if (0 === a3 || a3 >= r4) {
                                  t5.lastPingedTime = r4, Vi(t5, r4);
                                  break;
                                }
                              }
                              if (0 !== (a3 = Bi(t5)) && a3 !== r4)
                                break;
                              if (0 !== i4 && i4 !== r4) {
                                t5.lastPingedTime = i4;
                                break;
                              }
                              t5.timeoutHandle = B(no.bind(null, t5), o3);
                              break;
                            }
                            no(t5);
                            break;
                          case pi:
                            if (Eo(t5, r4), i4 = t5.lastSuspendedTime, r4 === i4 && (t5.nextKnownPendingLevel = to(o3)), Ti && (0 === (o3 = t5.lastPingedTime) || o3 >= r4)) {
                              t5.lastPingedTime = r4, Vi(t5, r4);
                              break;
                            }
                            if (0 !== (o3 = Bi(t5)) && o3 !== r4)
                              break;
                            if (0 !== i4 && i4 !== r4) {
                              t5.lastPingedTime = i4;
                              break;
                            }
                            if (1073741823 !== wi ? i4 = 10 * (1073741821 - wi) - ct() : 1073741823 === xi ? i4 = 0 : (i4 = 10 * (1073741821 - xi) - 5e3, o3 = ct(), r4 = 10 * (1073741821 - r4) - o3, 0 > (i4 = o3 - i4) && (i4 = 0), i4 = (120 > i4 ? 120 : 480 > i4 ? 480 : 1080 > i4 ? 1080 : 1920 > i4 ? 1920 : 3e3 > i4 ? 3e3 : 4320 > i4 ? 4320 : 1960 * ti(i4 / 1960)) - i4, r4 < i4 && (i4 = r4)), 10 < i4) {
                              t5.timeoutHandle = B(no.bind(null, t5), i4);
                              break;
                            }
                            no(t5);
                            break;
                          case di:
                            if (1073741823 !== xi && null !== Ei) {
                              a3 = xi;
                              var u2 = Ei;
                              if (0 >= (i4 = 0 | u2.busyMinDurationMs) ? i4 = 0 : (o3 = 0 | u2.busyDelayMs, a3 = ct() - (10 * (1073741821 - a3) - (0 | u2.timeoutMs || 5e3)), i4 = a3 <= o3 ? 0 : o3 + i4 - a3), 10 < i4) {
                                Eo(t5, r4), t5.timeoutHandle = B(no.bind(null, t5), i4);
                                break;
                              }
                            }
                            no(t5);
                            break;
                          default:
                            throw Error(l(329));
                        }
                      if (Hi(t5), t5.callbackNode === n4)
                        return e4.bind(null, t5);
                    }
                  }
                  return null;
                }.bind(null, e3), { timeout: 10 * (1073741821 - t4) - ct() }), e3.callbackNode = t4;
              }
            }
          }
          function qi(e3) {
            var t4 = e3.lastExpiredTime;
            if (t4 = 0 !== t4 ? t4 : 1073741823, e3.finishedExpirationTime === t4)
              no(e3);
            else {
              if ((hi & (ai | li)) !== ii)
                throw Error(l(327));
              if (io(), e3 === mi && t4 === bi || Vi(e3, t4), null !== vi) {
                var n3 = hi;
                hi |= ai;
                for (var r3 = $i(); ; )
                  try {
                    Yi();
                    break;
                  } catch (t5) {
                    Gi(e3, t5);
                  }
                if (kt(), hi = n3, ni.current = r3, yi === ci)
                  throw n3 = gi, Vi(e3, t4), Eo(e3, t4), Hi(e3), n3;
                if (null !== vi)
                  throw Error(l(261));
                e3.finishedWork = e3.current.alternate, e3.finishedExpirationTime = t4, mi = null, no(e3), Hi(e3);
              }
            }
            return null;
          }
          function Qi(e3, t4) {
            if ((hi & (ai | li)) !== ii)
              throw Error(l(187));
            var n3 = hi;
            hi |= 1;
            try {
              return pt(99, e3.bind(null, t4));
            } finally {
              hi = n3, mt();
            }
          }
          function Vi(e3, t4) {
            e3.finishedWork = null, e3.finishedExpirationTime = 0;
            var n3 = e3.timeoutHandle;
            if (n3 !== q && (e3.timeoutHandle = q, H(n3)), null !== vi)
              for (n3 = vi.return; null !== n3; ) {
                var r3 = n3;
                switch (r3.tag) {
                  case 1:
                    var i3 = r3.type.childContextTypes;
                    null != i3 && Fe();
                    break;
                  case 3:
                    pn(), De();
                    break;
                  case 5:
                    hn(r3);
                    break;
                  case 4:
                    pn();
                    break;
                  case 13:
                  case 19:
                    ze(mn);
                    break;
                  case 10:
                    Pt(r3);
                }
                n3 = n3.return;
              }
            mi = e3, vi = mo(e3.current, null), bi = t4, yi = ui, gi = null, wi = xi = 1073741823, Ei = null, Oi = 0, Ti = false;
          }
          function Gi(e3, t4) {
            for (; ; ) {
              try {
                if (kt(), Rn(), null === vi || null === vi.return)
                  return yi = ci, gi = t4, null;
                e: {
                  var n3 = e3, r3 = vi.return, i3 = vi, o3 = t4;
                  if (t4 = bi, i3.effectTag |= 2048, i3.firstEffect = i3.lastEffect = null, null !== o3 && "object" == typeof o3 && "function" == typeof o3.then) {
                    var a3 = o3, l2 = 0 != (1 & mn.current), u2 = r3;
                    do {
                      var c2;
                      if (c2 = 13 === u2.tag) {
                        var s2 = u2.memoizedState;
                        if (null !== s2)
                          c2 = null !== s2.dehydrated;
                        else {
                          var f2 = u2.memoizedProps;
                          c2 = void 0 !== f2.fallback && (true !== f2.unstable_avoidThisFallback || !l2);
                        }
                      }
                      if (c2) {
                        var p2 = u2.updateQueue;
                        if (null === p2) {
                          var d2 = /* @__PURE__ */ new Set();
                          d2.add(a3), u2.updateQueue = d2;
                        } else
                          p2.add(a3);
                        if (0 == (2 & u2.mode)) {
                          if (u2.effectTag |= 64, i3.effectTag &= -2981, 1 === i3.tag)
                            if (null === i3.alternate)
                              i3.tag = 17;
                            else {
                              var h2 = Rt(1073741823, null);
                              h2.tag = 2, Ut(i3, h2);
                            }
                          i3.expirationTime = 1073741823;
                          break e;
                        }
                        o3 = void 0, i3 = t4;
                        var m2 = n3.pingCache;
                        if (null === m2 ? (m2 = n3.pingCache = new Yr(), o3 = /* @__PURE__ */ new Set(), m2.set(a3, o3)) : void 0 === (o3 = m2.get(a3)) && (o3 = /* @__PURE__ */ new Set(), m2.set(a3, o3)), !o3.has(i3)) {
                          o3.add(i3);
                          var v2 = uo.bind(null, n3, a3, i3);
                          a3.then(v2, v2);
                        }
                        u2.effectTag |= 4096, u2.expirationTime = t4;
                        break e;
                      }
                      u2 = u2.return;
                    } while (null !== u2);
                    o3 = Error((S(i3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + je(i3));
                  }
                  yi !== di && (yi = si), o3 = Rr(o3, i3), u2 = r3;
                  do {
                    switch (u2.tag) {
                      case 3:
                        a3 = o3, u2.effectTag |= 4096, u2.expirationTime = t4, Ft(u2, Jr(u2, a3, t4));
                        break e;
                      case 1:
                        a3 = o3;
                        var b3 = u2.type, y2 = u2.stateNode;
                        if (0 == (64 & u2.effectTag) && ("function" == typeof b3.getDerivedStateFromError || null !== y2 && "function" == typeof y2.componentDidCatch && (null === Ci || !Ci.has(y2)))) {
                          u2.effectTag |= 4096, u2.expirationTime = t4, Ft(u2, Zr(u2, a3, t4));
                          break e;
                        }
                    }
                    u2 = u2.return;
                  } while (null !== u2);
                }
                vi = eo(vi);
              } catch (e4) {
                t4 = e4;
                continue;
              }
              break;
            }
          }
          function $i() {
            var e3 = ni.current;
            return ni.current = Zn, null === e3 ? Zn : e3;
          }
          function Ki(e3, t4) {
            e3 < xi && 2 < e3 && (xi = e3), null !== t4 && e3 < wi && 2 < e3 && (wi = e3, Ei = t4);
          }
          function Xi(e3) {
            e3 > Oi && (Oi = e3);
          }
          function Yi() {
            for (; null !== vi; )
              vi = Zi(vi);
          }
          function Ji() {
            for (; null !== vi && !$e(); )
              vi = Zi(vi);
          }
          function Zi(e3) {
            var t4 = ei(e3.alternate, e3, bi);
            return e3.memoizedProps = e3.pendingProps, null === t4 && (t4 = eo(e3)), ri.current = null, t4;
          }
          function eo(e3) {
            vi = e3;
            do {
              var t4 = vi.alternate;
              if (e3 = vi.return, 0 == (2048 & vi.effectTag)) {
                e: {
                  var n3 = t4, r3 = bi, i3 = (t4 = vi).pendingProps;
                  switch (t4.tag) {
                    case 2:
                    case 16:
                      break;
                    case 15:
                    case 0:
                      break;
                    case 1:
                      Ue(t4.type) && Fe();
                      break;
                    case 3:
                      pn(), De(), (i3 = t4.stateNode).pendingContext && (i3.context = i3.pendingContext, i3.pendingContext = null), (null === n3 || null === n3.child) && cr(t4) && Ir(t4), Or(t4);
                      break;
                    case 5:
                      hn(t4);
                      var o3 = sn(cn.current);
                      if (r3 = t4.type, null !== n3 && null != t4.stateNode)
                        Tr(n3, t4, r3, i3, o3), n3.ref !== t4.ref && (t4.effectTag |= 128);
                      else if (i3) {
                        if (n3 = sn(ln2.current), cr(t4)) {
                          if (i3 = t4, !$)
                            throw Error(l(175));
                          n3 = Ee(i3.stateNode, i3.type, i3.memoizedProps, o3, n3, i3), i3.updateQueue = n3, (n3 = null !== n3) && Ir(t4);
                        } else {
                          var a3 = L(r3, i3, o3, n3, t4);
                          Er(a3, t4, false, false), t4.stateNode = a3, A(a3, r3, i3, o3, n3) && Ir(t4);
                        }
                        null !== t4.ref && (t4.effectTag |= 128);
                      } else if (null === t4.stateNode)
                        throw Error(l(166));
                      break;
                    case 6:
                      if (n3 && null != t4.stateNode)
                        Sr(n3, t4, n3.memoizedProps, i3);
                      else {
                        if ("string" != typeof i3 && null === t4.stateNode)
                          throw Error(l(166));
                        if (n3 = sn(cn.current), o3 = sn(ln2.current), cr(t4)) {
                          if (n3 = t4, !$)
                            throw Error(l(176));
                          (n3 = Oe(n3.stateNode, n3.memoizedProps, n3)) && Ir(t4);
                        } else
                          t4.stateNode = W(i3, n3, o3, t4);
                      }
                      break;
                    case 11:
                      break;
                    case 13:
                      if (ze(mn), i3 = t4.memoizedState, 0 != (64 & t4.effectTag)) {
                        t4.expirationTime = r3;
                        break e;
                      }
                      i3 = null !== i3, o3 = false, null === n3 ? void 0 !== t4.memoizedProps.fallback && cr(t4) : (o3 = null !== (r3 = n3.memoizedState), i3 || null === r3 || null !== (r3 = n3.child.sibling) && (null !== (a3 = t4.firstEffect) ? (t4.firstEffect = r3, r3.nextEffect = a3) : (t4.firstEffect = t4.lastEffect = r3, r3.nextEffect = null), r3.effectTag = 8)), i3 && !o3 && 0 != (2 & t4.mode) && (null === n3 && true !== t4.memoizedProps.unstable_avoidThisFallback || 0 != (1 & mn.current) ? yi === ui && (yi = fi) : (yi !== ui && yi !== fi || (yi = pi), 0 !== Oi && null !== mi && (Eo(mi, bi), Oo(mi, Oi)))), G && i3 && (t4.effectTag |= 4), V && (i3 || o3) && (t4.effectTag |= 4);
                      break;
                    case 7:
                    case 8:
                    case 12:
                      break;
                    case 4:
                      pn(), Or(t4);
                      break;
                    case 10:
                      Pt(t4);
                      break;
                    case 9:
                    case 14:
                      break;
                    case 17:
                      Ue(t4.type) && Fe();
                      break;
                    case 19:
                      if (ze(mn), null === (i3 = t4.memoizedState))
                        break;
                      if (o3 = 0 != (64 & t4.effectTag), null === (a3 = i3.rendering)) {
                        if (o3)
                          Nr(i3, false);
                        else if (yi !== ui || null !== n3 && 0 != (64 & n3.effectTag))
                          for (n3 = t4.child; null !== n3; ) {
                            if (null !== (a3 = vn(n3))) {
                              for (t4.effectTag |= 64, Nr(i3, false), null !== (n3 = a3.updateQueue) && (t4.updateQueue = n3, t4.effectTag |= 4), null === i3.lastEffect && (t4.firstEffect = null), t4.lastEffect = i3.lastEffect, n3 = r3, i3 = t4.child; null !== i3; )
                                r3 = n3, (o3 = i3).effectTag &= 2, o3.nextEffect = null, o3.firstEffect = null, o3.lastEffect = null, null === (a3 = o3.alternate) ? (o3.childExpirationTime = 0, o3.expirationTime = r3, o3.child = null, o3.memoizedProps = null, o3.memoizedState = null, o3.updateQueue = null, o3.dependencies = null) : (o3.childExpirationTime = a3.childExpirationTime, o3.expirationTime = a3.expirationTime, o3.child = a3.child, o3.memoizedProps = a3.memoizedProps, o3.memoizedState = a3.memoizedState, o3.updateQueue = a3.updateQueue, r3 = a3.dependencies, o3.dependencies = null === r3 ? null : { expirationTime: r3.expirationTime, firstContext: r3.firstContext, responders: r3.responders }), i3 = i3.sibling;
                              Ie(mn, 1 & mn.current | 2), t4 = t4.child;
                              break e;
                            }
                            n3 = n3.sibling;
                          }
                      } else {
                        if (!o3)
                          if (null !== (n3 = vn(a3))) {
                            if (t4.effectTag |= 64, o3 = true, null !== (n3 = n3.updateQueue) && (t4.updateQueue = n3, t4.effectTag |= 4), Nr(i3, true), null === i3.tail && "hidden" === i3.tailMode) {
                              null !== (t4 = t4.lastEffect = i3.lastEffect) && (t4.nextEffect = null);
                              break;
                            }
                          } else
                            ct() > i3.tailExpiration && 1 < r3 && (t4.effectTag |= 64, o3 = true, Nr(i3, false), t4.expirationTime = t4.childExpirationTime = r3 - 1);
                        i3.isBackwards ? (a3.sibling = t4.child, t4.child = a3) : (null !== (n3 = i3.last) ? n3.sibling = a3 : t4.child = a3, i3.last = a3);
                      }
                      if (null !== i3.tail) {
                        0 === i3.tailExpiration && (i3.tailExpiration = ct() + 500), n3 = i3.tail, i3.rendering = n3, i3.tail = n3.sibling, i3.lastEffect = t4.lastEffect, n3.sibling = null, i3 = mn.current, Ie(mn, i3 = o3 ? 1 & i3 | 2 : 1 & i3), t4 = n3;
                        break e;
                      }
                      break;
                    case 20:
                    case 21:
                      break;
                    default:
                      throw Error(l(156, t4.tag));
                  }
                  t4 = null;
                }
                if (n3 = vi, 1 === bi || 1 !== n3.childExpirationTime) {
                  for (i3 = 0, o3 = n3.child; null !== o3; )
                    (r3 = o3.expirationTime) > i3 && (i3 = r3), (a3 = o3.childExpirationTime) > i3 && (i3 = a3), o3 = o3.sibling;
                  n3.childExpirationTime = i3;
                }
                if (null !== t4)
                  return t4;
                null !== e3 && 0 == (2048 & e3.effectTag) && (null === e3.firstEffect && (e3.firstEffect = vi.firstEffect), null !== vi.lastEffect && (null !== e3.lastEffect && (e3.lastEffect.nextEffect = vi.firstEffect), e3.lastEffect = vi.lastEffect), 1 < vi.effectTag && (null !== e3.lastEffect ? e3.lastEffect.nextEffect = vi : e3.firstEffect = vi, e3.lastEffect = vi));
              } else {
                if (null !== (t4 = Lr(vi)))
                  return t4.effectTag &= 2047, t4;
                null !== e3 && (e3.firstEffect = e3.lastEffect = null, e3.effectTag |= 2048);
              }
              if (null !== (t4 = vi.sibling))
                return t4;
              vi = e3;
            } while (null !== vi);
            return yi === ui && (yi = di), null;
          }
          function to(e3) {
            var t4 = e3.expirationTime;
            return t4 > (e3 = e3.childExpirationTime) ? t4 : e3;
          }
          function no(e3) {
            var t4 = st();
            return pt(99, function(e4, t5) {
              if (io(), (hi & (ai | li)) !== ii)
                throw Error(l(327));
              var n3 = e4.finishedWork, r3 = e4.finishedExpirationTime;
              if (null === n3)
                return null;
              if (e4.finishedWork = null, e4.finishedExpirationTime = 0, n3 === e4.current)
                throw Error(l(177));
              e4.callbackNode = null, e4.callbackExpirationTime = 0, e4.callbackPriority = 90, e4.nextKnownPendingLevel = 0;
              var i3 = to(n3);
              if (e4.firstPendingTime = i3, r3 <= e4.lastSuspendedTime ? e4.firstSuspendedTime = e4.lastSuspendedTime = e4.nextKnownPendingLevel = 0 : r3 <= e4.firstSuspendedTime && (e4.firstSuspendedTime = r3 - 1), r3 <= e4.lastPingedTime && (e4.lastPingedTime = 0), r3 <= e4.lastExpiredTime && (e4.lastExpiredTime = 0), e4 === mi && (vi = mi = null, bi = 0), 1 < n3.effectTag ? null !== n3.lastEffect ? (n3.lastEffect.nextEffect = n3, i3 = n3.firstEffect) : i3 = n3 : i3 = n3.firstEffect, null !== i3) {
                var o3 = hi;
                hi |= li, ri.current = null, M(e4.containerInfo), ki = i3;
                do {
                  try {
                    ro();
                  } catch (e5) {
                    if (null === ki)
                      throw Error(l(330));
                    lo(ki, e5), ki = ki.nextEffect;
                  }
                } while (null !== ki);
                ki = i3;
                do {
                  try {
                    for (var a3 = e4, u2 = t5; null !== ki; ) {
                      var c2 = ki.effectTag;
                      if (16 & c2 && V && ie(ki.stateNode), 128 & c2) {
                        var s2 = ki.alternate;
                        if (null !== s2) {
                          var f2 = s2.ref;
                          null !== f2 && ("function" == typeof f2 ? f2(null) : f2.current = null);
                        }
                      }
                      switch (1038 & c2) {
                        case 2:
                          Vr(ki), ki.effectTag &= -3;
                          break;
                        case 6:
                          Vr(ki), ki.effectTag &= -3, $r(ki.alternate, ki);
                          break;
                        case 1024:
                          ki.effectTag &= -1025;
                          break;
                        case 1028:
                          ki.effectTag &= -1025, $r(ki.alternate, ki);
                          break;
                        case 4:
                          $r(ki.alternate, ki);
                          break;
                        case 8:
                          var p2 = a3, d2 = ki, h2 = u2;
                          V ? Gr(p2, d2, h2) : Hr(p2, d2, h2), qr(d2);
                      }
                      ki = ki.nextEffect;
                    }
                  } catch (e5) {
                    if (null === ki)
                      throw Error(l(330));
                    lo(ki, e5), ki = ki.nextEffect;
                  }
                } while (null !== ki);
                N(e4.containerInfo), e4.current = n3, ki = i3;
                do {
                  try {
                    for (c2 = r3; null !== ki; ) {
                      var m2 = ki.effectTag;
                      if (36 & m2) {
                        var v2 = ki.alternate;
                        switch (f2 = c2, (s2 = ki).tag) {
                          case 0:
                          case 11:
                          case 15:
                            Wr(16, 32, s2);
                            break;
                          case 1:
                            var b3 = s2.stateNode;
                            if (4 & s2.effectTag)
                              if (null === v2)
                                b3.componentDidMount();
                              else {
                                var y2 = s2.elementType === s2.type ? v2.memoizedProps : Et(s2.type, v2.memoizedProps);
                                b3.componentDidUpdate(y2, v2.memoizedState, b3.__reactInternalSnapshotBeforeUpdate);
                              }
                            var g2 = s2.updateQueue;
                            null !== g2 && Ht(0, g2, b3);
                            break;
                          case 3:
                            var x2 = s2.updateQueue;
                            if (null !== x2) {
                              if (a3 = null, null !== s2.child)
                                switch (s2.child.tag) {
                                  case 5:
                                    a3 = C(s2.child.stateNode);
                                    break;
                                  case 1:
                                    a3 = s2.child.stateNode;
                                }
                              Ht(0, x2, a3);
                            }
                            break;
                          case 5:
                            var w2 = s2.stateNode;
                            null === v2 && 4 & s2.effectTag && J(w2, s2.type, s2.memoizedProps, s2);
                            break;
                          case 6:
                          case 4:
                          case 12:
                            break;
                          case 13:
                            if ($ && null === s2.memoizedState) {
                              var E2 = s2.alternate;
                              if (null !== E2) {
                                var O2 = E2.memoizedState;
                                if (null !== O2) {
                                  var T2 = O2.dehydrated;
                                  null !== T2 && _e(T2);
                                }
                              }
                            }
                            break;
                          case 19:
                          case 17:
                          case 20:
                          case 21:
                            break;
                          default:
                            throw Error(l(163));
                        }
                      }
                      if (128 & m2) {
                        s2 = void 0;
                        var S2 = ki.ref;
                        if (null !== S2) {
                          var _2 = ki.stateNode;
                          switch (ki.tag) {
                            case 5:
                              s2 = C(_2);
                              break;
                            default:
                              s2 = _2;
                          }
                          "function" == typeof S2 ? S2(s2) : S2.current = s2;
                        }
                      }
                      ki = ki.nextEffect;
                    }
                  } catch (e5) {
                    if (null === ki)
                      throw Error(l(330));
                    lo(ki, e5), ki = ki.nextEffect;
                  }
                } while (null !== ki);
                ki = null, it(), hi = o3;
              } else
                e4.current = n3;
              if (zi)
                zi = false, Ii = e4, Mi = t5;
              else
                for (ki = i3; null !== ki; )
                  t5 = ki.nextEffect, ki.nextEffect = null, ki = t5;
              if (0 === (t5 = e4.firstPendingTime) && (Ci = null), 1073741823 === t5 ? e4 === Ri ? Li++ : (Li = 0, Ri = e4) : Li = 0, "function" == typeof co && co(n3.stateNode, r3), Hi(e4), ji)
                throw ji = false, e4 = Pi, Pi = null, e4;
              return (hi & oi) !== ii ? null : (mt(), null);
            }.bind(null, e3, t4)), null;
          }
          function ro() {
            for (; null !== ki; ) {
              var e3 = ki.effectTag;
              0 != (256 & e3) && Dr(ki.alternate, ki), 0 == (512 & e3) || zi || (zi = true, dt(97, function() {
                return io(), null;
              })), ki = ki.nextEffect;
            }
          }
          function io() {
            if (90 !== Mi) {
              var e3 = 97 < Mi ? 97 : Mi;
              return Mi = 90, pt(e3, oo);
            }
          }
          function oo() {
            if (null === Ii)
              return false;
            var e3 = Ii;
            if (Ii = null, (hi & (ai | li)) !== ii)
              throw Error(l(331));
            var t4 = hi;
            for (hi |= li, e3 = e3.current.firstEffect; null !== e3; ) {
              try {
                var n3 = e3;
                if (0 != (512 & n3.effectTag))
                  switch (n3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Wr(128, 0, n3), Wr(0, 64, n3);
                  }
              } catch (t5) {
                if (null === e3)
                  throw Error(l(330));
                lo(e3, t5);
              }
              n3 = e3.nextEffect, e3.nextEffect = null, e3 = n3;
            }
            return hi = t4, mt(), true;
          }
          function ao(e3, t4, n3) {
            Ut(e3, t4 = Jr(e3, t4 = Rr(n3, t4), 1073741823)), null !== (e3 = Wi(e3, 1073741823)) && Hi(e3);
          }
          function lo(e3, t4) {
            if (3 === e3.tag)
              ao(e3, e3, t4);
            else
              for (var n3 = e3.return; null !== n3; ) {
                if (3 === n3.tag) {
                  ao(n3, e3, t4);
                  break;
                }
                if (1 === n3.tag) {
                  var r3 = n3.stateNode;
                  if ("function" == typeof n3.type.getDerivedStateFromError || "function" == typeof r3.componentDidCatch && (null === Ci || !Ci.has(r3))) {
                    Ut(n3, e3 = Zr(n3, e3 = Rr(t4, e3), 1073741823)), null !== (n3 = Wi(n3, 1073741823)) && Hi(n3);
                    break;
                  }
                }
                n3 = n3.return;
              }
          }
          function uo(e3, t4, n3) {
            var r3 = e3.pingCache;
            null !== r3 && r3.delete(t4), mi === e3 && bi === n3 ? yi === pi || yi === fi && 1073741823 === xi && ct() - Si < _i ? Vi(e3, bi) : Ti = true : wo(e3, n3) && (0 !== (t4 = e3.lastPingedTime) && t4 < n3 || (e3.lastPingedTime = n3, e3.finishedExpirationTime === n3 && (e3.finishedExpirationTime = 0, e3.finishedWork = null), Hi(e3)));
          }
          ei = function(e3, t4, n3) {
            var r3 = t4.expirationTime;
            if (null !== e3) {
              var i3 = t4.pendingProps;
              if (e3.memoizedProps !== i3 || Le.current)
                pr = true;
              else {
                if (r3 < n3) {
                  switch (pr = false, t4.tag) {
                    case 3:
                      wr(t4), sr();
                      break;
                    case 5:
                      if (dn(t4), 4 & t4.mode && 1 !== n3 && D(t4.type, i3))
                        return t4.expirationTime = t4.childExpirationTime = 1, null;
                      break;
                    case 1:
                      Ue(t4.type) && He(t4);
                      break;
                    case 4:
                      fn(t4, t4.stateNode.containerInfo);
                      break;
                    case 10:
                      jt(t4, t4.memoizedProps.value);
                      break;
                    case 13:
                      if (null !== t4.memoizedState)
                        return 0 !== (r3 = t4.child.childExpirationTime) && r3 >= n3 ? kr(e3, t4, n3) : (Ie(mn, 1 & mn.current), null !== (t4 = zr(e3, t4, n3)) ? t4.sibling : null);
                      Ie(mn, 1 & mn.current);
                      break;
                    case 19:
                      if (r3 = t4.childExpirationTime >= n3, 0 != (64 & e3.effectTag)) {
                        if (r3)
                          return Cr(e3, t4, n3);
                        t4.effectTag |= 64;
                      }
                      if (null !== (i3 = t4.memoizedState) && (i3.rendering = null, i3.tail = null), Ie(mn, mn.current), !r3)
                        return null;
                  }
                  return zr(e3, t4, n3);
                }
                pr = false;
              }
            } else
              pr = false;
            switch (t4.expirationTime = 0, t4.tag) {
              case 2:
                if (r3 = t4.type, null !== e3 && (e3.alternate = null, t4.alternate = null, t4.effectTag |= 2), e3 = t4.pendingProps, i3 = Ae(t4, Ne.current), zt(t4, n3), i3 = Ln(null, t4, r3, e3, i3, n3), t4.effectTag |= 1, "object" == typeof i3 && null !== i3 && "function" == typeof i3.render && void 0 === i3.$$typeof) {
                  if (t4.tag = 1, Rn(), Ue(r3)) {
                    var o3 = true;
                    He(t4);
                  } else
                    o3 = false;
                  t4.memoizedState = null !== i3.state && void 0 !== i3.state ? i3.state : null;
                  var a3 = r3.getDerivedStateFromProps;
                  "function" == typeof a3 && Gt(t4, r3, a3, e3), i3.updater = $t, t4.stateNode = i3, i3._reactInternalFiber = t4, Jt(t4, r3, e3, n3), t4 = xr(null, t4, r3, true, o3, n3);
                } else
                  t4.tag = 0, dr(null, t4, i3, n3), t4 = t4.child;
                return t4;
              case 16:
                if (i3 = t4.elementType, null !== e3 && (e3.alternate = null, t4.alternate = null, t4.effectTag |= 2), e3 = t4.pendingProps, function(e4) {
                  if (-1 === e4._status) {
                    e4._status = 0;
                    var t5 = e4._ctor;
                    t5 = t5(), e4._result = t5, t5.then(function(t6) {
                      0 === e4._status && (t6 = t6.default, e4._status = 1, e4._result = t6);
                    }, function(t6) {
                      0 === e4._status && (e4._status = 2, e4._result = t6);
                    });
                  }
                }(i3), 1 !== i3._status)
                  throw i3._result;
                switch (i3 = i3._result, t4.type = i3, o3 = t4.tag = function(e4) {
                  if ("function" == typeof e4)
                    return ho(e4) ? 1 : 0;
                  if (null != e4) {
                    if ((e4 = e4.$$typeof) === y)
                      return 11;
                    if (e4 === w)
                      return 14;
                  }
                  return 2;
                }(i3), e3 = Et(i3, e3), o3) {
                  case 0:
                    t4 = yr(null, t4, i3, e3, n3);
                    break;
                  case 1:
                    t4 = gr(null, t4, i3, e3, n3);
                    break;
                  case 11:
                    t4 = hr(null, t4, i3, e3, n3);
                    break;
                  case 14:
                    t4 = mr(null, t4, i3, Et(i3.type, e3), r3, n3);
                    break;
                  default:
                    throw Error(l(306, i3, ""));
                }
                return t4;
              case 0:
                return r3 = t4.type, i3 = t4.pendingProps, yr(e3, t4, r3, i3 = t4.elementType === r3 ? i3 : Et(r3, i3), n3);
              case 1:
                return r3 = t4.type, i3 = t4.pendingProps, gr(e3, t4, r3, i3 = t4.elementType === r3 ? i3 : Et(r3, i3), n3);
              case 3:
                if (wr(t4), null === (r3 = t4.updateQueue))
                  throw Error(l(282));
                if (i3 = null !== (i3 = t4.memoizedState) ? i3.element : null, Bt(t4, r3, t4.pendingProps, null, n3), (r3 = t4.memoizedState.element) === i3)
                  sr(), t4 = zr(e3, t4, n3);
                else {
                  if ((i3 = t4.stateNode.hydrate) && ($ ? (rr = we(t4.stateNode.containerInfo), nr = t4, i3 = ir = true) : i3 = false), i3)
                    for (n3 = on(t4, null, r3, n3), t4.child = n3; n3; )
                      n3.effectTag = -3 & n3.effectTag | 1024, n3 = n3.sibling;
                  else
                    dr(e3, t4, r3, n3), sr();
                  t4 = t4.child;
                }
                return t4;
              case 5:
                return dn(t4), null === e3 && lr(t4), r3 = t4.type, i3 = t4.pendingProps, o3 = null !== e3 ? e3.memoizedProps : null, a3 = i3.children, F(r3, i3) ? a3 = null : null !== o3 && F(r3, o3) && (t4.effectTag |= 16), br(e3, t4), 4 & t4.mode && 1 !== n3 && D(r3, i3) ? (t4.expirationTime = t4.childExpirationTime = 1, t4 = null) : (dr(e3, t4, a3, n3), t4 = t4.child), t4;
              case 6:
                return null === e3 && lr(t4), null;
              case 13:
                return kr(e3, t4, n3);
              case 4:
                return fn(t4, t4.stateNode.containerInfo), r3 = t4.pendingProps, null === e3 ? t4.child = rn(t4, null, r3, n3) : dr(e3, t4, r3, n3), t4.child;
              case 11:
                return r3 = t4.type, i3 = t4.pendingProps, hr(e3, t4, r3, i3 = t4.elementType === r3 ? i3 : Et(r3, i3), n3);
              case 7:
                return dr(e3, t4, t4.pendingProps, n3), t4.child;
              case 8:
              case 12:
                return dr(e3, t4, t4.pendingProps.children, n3), t4.child;
              case 10:
                e: {
                  if (r3 = t4.type._context, i3 = t4.pendingProps, a3 = t4.memoizedProps, jt(t4, o3 = i3.value), null !== a3) {
                    var u2 = a3.value;
                    if (0 === (o3 = gt(u2, o3) ? 0 : 0 | ("function" == typeof r3._calculateChangedBits ? r3._calculateChangedBits(u2, o3) : 1073741823))) {
                      if (a3.children === i3.children && !Le.current) {
                        t4 = zr(e3, t4, n3);
                        break e;
                      }
                    } else
                      for (null !== (u2 = t4.child) && (u2.return = t4); null !== u2; ) {
                        var c2 = u2.dependencies;
                        if (null !== c2) {
                          a3 = u2.child;
                          for (var s2 = c2.firstContext; null !== s2; ) {
                            if (s2.context === r3 && 0 != (s2.observedBits & o3)) {
                              1 === u2.tag && ((s2 = Rt(n3, null)).tag = 2, Ut(u2, s2)), u2.expirationTime < n3 && (u2.expirationTime = n3), null !== (s2 = u2.alternate) && s2.expirationTime < n3 && (s2.expirationTime = n3), Ct(u2.return, n3), c2.expirationTime < n3 && (c2.expirationTime = n3);
                              break;
                            }
                            s2 = s2.next;
                          }
                        } else
                          a3 = 10 === u2.tag && u2.type === t4.type ? null : u2.child;
                        if (null !== a3)
                          a3.return = u2;
                        else
                          for (a3 = u2; null !== a3; ) {
                            if (a3 === t4) {
                              a3 = null;
                              break;
                            }
                            if (null !== (u2 = a3.sibling)) {
                              u2.return = a3.return, a3 = u2;
                              break;
                            }
                            a3 = a3.return;
                          }
                        u2 = a3;
                      }
                  }
                  dr(e3, t4, i3.children, n3), t4 = t4.child;
                }
                return t4;
              case 9:
                return i3 = t4.type, r3 = (o3 = t4.pendingProps).children, zt(t4, n3), r3 = r3(i3 = It(i3, o3.unstable_observedBits)), t4.effectTag |= 1, dr(e3, t4, r3, n3), t4.child;
              case 14:
                return o3 = Et(i3 = t4.type, t4.pendingProps), mr(e3, t4, i3, o3 = Et(i3.type, o3), r3, n3);
              case 15:
                return vr(e3, t4, t4.type, t4.pendingProps, r3, n3);
              case 17:
                return r3 = t4.type, i3 = t4.pendingProps, i3 = t4.elementType === r3 ? i3 : Et(r3, i3), null !== e3 && (e3.alternate = null, t4.alternate = null, t4.effectTag |= 2), t4.tag = 1, Ue(r3) ? (e3 = true, He(t4)) : e3 = false, zt(t4, n3), Xt(t4, r3, i3), Jt(t4, r3, i3, n3), xr(null, t4, r3, true, e3, n3);
              case 19:
                return Cr(e3, t4, n3);
            }
            throw Error(l(156, t4.tag));
          };
          var co = null, so = null;
          function fo(e3, t4, n3, r3) {
            this.tag = e3, this.key = n3, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t4, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r3, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null;
          }
          function po(e3, t4, n3, r3) {
            return new fo(e3, t4, n3, r3);
          }
          function ho(e3) {
            return !(!(e3 = e3.prototype) || !e3.isReactComponent);
          }
          function mo(e3, t4) {
            var n3 = e3.alternate;
            return null === n3 ? ((n3 = po(e3.tag, t4, e3.key, e3.mode)).elementType = e3.elementType, n3.type = e3.type, n3.stateNode = e3.stateNode, n3.alternate = e3, e3.alternate = n3) : (n3.pendingProps = t4, n3.effectTag = 0, n3.nextEffect = null, n3.firstEffect = null, n3.lastEffect = null), n3.childExpirationTime = e3.childExpirationTime, n3.expirationTime = e3.expirationTime, n3.child = e3.child, n3.memoizedProps = e3.memoizedProps, n3.memoizedState = e3.memoizedState, n3.updateQueue = e3.updateQueue, t4 = e3.dependencies, n3.dependencies = null === t4 ? null : { expirationTime: t4.expirationTime, firstContext: t4.firstContext, responders: t4.responders }, n3.sibling = e3.sibling, n3.index = e3.index, n3.ref = e3.ref, n3;
          }
          function vo(e3, t4, n3, r3, i3, o3) {
            var a3 = 2;
            if (r3 = e3, "function" == typeof e3)
              ho(e3) && (a3 = 1);
            else if ("string" == typeof e3)
              a3 = 5;
            else
              e:
                switch (e3) {
                  case p:
                    return bo(n3.children, i3, o3, t4);
                  case b:
                    a3 = 8, i3 |= 7;
                    break;
                  case d:
                    a3 = 8, i3 |= 1;
                    break;
                  case h:
                    return (e3 = po(12, n3, t4, 8 | i3)).elementType = h, e3.type = h, e3.expirationTime = o3, e3;
                  case g:
                    return (e3 = po(13, n3, t4, i3)).type = g, e3.elementType = g, e3.expirationTime = o3, e3;
                  case x:
                    return (e3 = po(19, n3, t4, i3)).elementType = x, e3.expirationTime = o3, e3;
                  default:
                    if ("object" == typeof e3 && null !== e3)
                      switch (e3.$$typeof) {
                        case m:
                          a3 = 10;
                          break e;
                        case v:
                          a3 = 9;
                          break e;
                        case y:
                          a3 = 11;
                          break e;
                        case w:
                          a3 = 14;
                          break e;
                        case E:
                          a3 = 16, r3 = null;
                          break e;
                      }
                    throw Error(l(130, null == e3 ? e3 : typeof e3, ""));
                }
            return (t4 = po(a3, n3, t4, i3)).elementType = e3, t4.type = r3, t4.expirationTime = o3, t4;
          }
          function bo(e3, t4, n3, r3) {
            return (e3 = po(7, e3, r3, t4)).expirationTime = n3, e3;
          }
          function yo(e3, t4, n3) {
            return (e3 = po(6, e3, null, t4)).expirationTime = n3, e3;
          }
          function go(e3, t4, n3) {
            return (t4 = po(4, null !== e3.children ? e3.children : [], e3.key, t4)).expirationTime = n3, t4.stateNode = { containerInfo: e3.containerInfo, pendingChildren: null, implementation: e3.implementation }, t4;
          }
          function xo(e3, t4, n3) {
            this.tag = t4, this.current = null, this.containerInfo = e3, this.pingCache = this.pendingChildren = null, this.finishedExpirationTime = 0, this.finishedWork = null, this.timeoutHandle = q, this.pendingContext = this.context = null, this.hydrate = n3, this.callbackNode = null, this.callbackPriority = 90, this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
          }
          function wo(e3, t4) {
            var n3 = e3.firstSuspendedTime;
            return e3 = e3.lastSuspendedTime, 0 !== n3 && n3 >= t4 && e3 <= t4;
          }
          function Eo(e3, t4) {
            var n3 = e3.firstSuspendedTime, r3 = e3.lastSuspendedTime;
            n3 < t4 && (e3.firstSuspendedTime = t4), (r3 > t4 || 0 === n3) && (e3.lastSuspendedTime = t4), t4 <= e3.lastPingedTime && (e3.lastPingedTime = 0), t4 <= e3.lastExpiredTime && (e3.lastExpiredTime = 0);
          }
          function Oo(e3, t4) {
            t4 > e3.firstPendingTime && (e3.firstPendingTime = t4);
            var n3 = e3.firstSuspendedTime;
            0 !== n3 && (t4 >= n3 ? e3.firstSuspendedTime = e3.lastSuspendedTime = e3.nextKnownPendingLevel = 0 : t4 >= e3.lastSuspendedTime && (e3.lastSuspendedTime = t4 + 1), t4 > e3.nextKnownPendingLevel && (e3.nextKnownPendingLevel = t4));
          }
          function To(e3, t4) {
            var n3 = e3.lastExpiredTime;
            (0 === n3 || n3 > t4) && (e3.lastExpiredTime = t4);
          }
          function So(e3) {
            var t4 = e3._reactInternalFiber;
            if (void 0 === t4) {
              if ("function" == typeof e3.render)
                throw Error(l(188));
              throw Error(l(268, Object.keys(e3)));
            }
            return null === (e3 = P(t4)) ? null : e3.stateNode;
          }
          function _o(e3, t4) {
            null !== (e3 = e3.memoizedState) && null !== e3.dehydrated && e3.retryTime < t4 && (e3.retryTime = t4);
          }
          function ko(e3, t4) {
            _o(e3, t4), (e3 = e3.alternate) && _o(e3, t4);
          }
          var jo = { createContainer: function(e3, t4, n3) {
            return e3 = new xo(e3, t4, n3), t4 = po(3, null, null, 2 === t4 ? 7 : 1 === t4 ? 3 : 0), e3.current = t4, t4.stateNode = e3;
          }, updateContainer: function(e3, t4, n3, r3) {
            var i3 = t4.current, o3 = Ui(), a3 = Qt.suspense;
            o3 = Fi(o3, i3, a3);
            e:
              if (n3) {
                t: {
                  if (_(n3 = n3._reactInternalFiber) !== n3 || 1 !== n3.tag)
                    throw Error(l(170));
                  var u2 = n3;
                  do {
                    switch (u2.tag) {
                      case 3:
                        u2 = u2.stateNode.context;
                        break t;
                      case 1:
                        if (Ue(u2.type)) {
                          u2 = u2.stateNode.__reactInternalMemoizedMergedChildContext;
                          break t;
                        }
                    }
                    u2 = u2.return;
                  } while (null !== u2);
                  throw Error(l(171));
                }
                if (1 === n3.tag) {
                  var c2 = n3.type;
                  if (Ue(c2)) {
                    n3 = Be(n3, c2, u2);
                    break e;
                  }
                }
                n3 = u2;
              } else
                n3 = Me;
            return null === t4.context ? t4.context = n3 : t4.pendingContext = n3, (t4 = Rt(o3, a3)).payload = { element: e3 }, null !== (r3 = void 0 === r3 ? null : r3) && (t4.callback = r3), Ut(i3, t4), Di(i3, o3), o3;
          }, batchedEventUpdates: function(e3, t4) {
            var n3 = hi;
            hi |= 2;
            try {
              return e3(t4);
            } finally {
              (hi = n3) === ii && mt();
            }
          }, batchedUpdates: function(e3, t4) {
            var n3 = hi;
            hi |= 1;
            try {
              return e3(t4);
            } finally {
              (hi = n3) === ii && mt();
            }
          }, unbatchedUpdates: function(e3, t4) {
            var n3 = hi;
            hi &= -2, hi |= oi;
            try {
              return e3(t4);
            } finally {
              (hi = n3) === ii && mt();
            }
          }, deferredUpdates: function(e3) {
            return pt(97, e3);
          }, syncUpdates: function(e3, t4, n3, r3) {
            return pt(99, e3.bind(null, t4, n3, r3));
          }, discreteUpdates: function(e3, t4, n3, r3) {
            var i3 = hi;
            hi |= 4;
            try {
              return pt(98, e3.bind(null, t4, n3, r3));
            } finally {
              (hi = i3) === ii && mt();
            }
          }, flushDiscreteUpdates: function() {
            (hi & (1 | ai | li)) === ii && (function() {
              if (null !== Ni) {
                var e3 = Ni;
                Ni = null, e3.forEach(function(e4, t4) {
                  To(t4, e4), Hi(t4);
                }), mt();
              }
            }(), io());
          }, flushControlled: function(e3) {
            var t4 = hi;
            hi |= 1;
            try {
              pt(99, e3);
            } finally {
              (hi = t4) === ii && mt();
            }
          }, flushSync: Qi, flushPassiveEffects: io, IsThisRendererActing: { current: false }, getPublicRootInstance: function(e3) {
            if (!(e3 = e3.current).child)
              return null;
            switch (e3.child.tag) {
              case 5:
                return C(e3.child.stateNode);
              default:
                return e3.child.stateNode;
            }
          }, attemptSynchronousHydration: function(e3) {
            switch (e3.tag) {
              case 3:
                var t4 = e3.stateNode;
                t4.hydrate && function(e4, t5) {
                  To(e4, t5), Hi(e4), (hi & (ai | li)) === ii && mt();
                }(t4, t4.firstPendingTime);
                break;
              case 13:
                Qi(function() {
                  return Di(e3, 1073741823);
                }), t4 = yt(Ui(), 150, 100), ko(e3, t4);
            }
          }, attemptUserBlockingHydration: function(e3) {
            if (13 === e3.tag) {
              var t4 = yt(Ui(), 150, 100);
              Di(e3, t4), ko(e3, t4);
            }
          }, attemptContinuousHydration: function(e3) {
            if (13 === e3.tag) {
              Ui();
              var t4 = bt++;
              Di(e3, t4), ko(e3, t4);
            }
          }, attemptHydrationAtCurrentPriority: function(e3) {
            if (13 === e3.tag) {
              var t4 = Ui();
              Di(e3, t4 = Fi(t4, e3, null)), ko(e3, t4);
            }
          }, findHostInstance: So, findHostInstanceWithWarning: function(e3) {
            return So(e3);
          }, findHostInstanceWithNoPortals: function(e3) {
            return null === (e3 = function(e4) {
              if (!(e4 = j(e4)))
                return null;
              for (var t4 = e4; ; ) {
                if (5 === t4.tag || 6 === t4.tag)
                  return t4;
                if (t4.child && 4 !== t4.tag)
                  t4.child.return = t4, t4 = t4.child;
                else {
                  if (t4 === e4)
                    break;
                  for (; !t4.sibling; ) {
                    if (!t4.return || t4.return === e4)
                      return null;
                    t4 = t4.return;
                  }
                  t4.sibling.return = t4.return, t4 = t4.sibling;
                }
              }
              return null;
            }(e3)) ? null : 20 === e3.tag ? e3.stateNode.instance : e3.stateNode;
          }, shouldSuspend: function() {
            return false;
          }, injectIntoDevTools: function(e3) {
            var t4 = e3.findFiberByHostInstance;
            return function(e4) {
              if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)
                return false;
              var t5 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (t5.isDisabled || !t5.supportsFiber)
                return true;
              try {
                var n3 = t5.inject(e4);
                co = function(e5) {
                  try {
                    t5.onCommitFiberRoot(n3, e5, void 0, 64 == (64 & e5.current.effectTag));
                  } catch (e6) {
                  }
                }, so = function(e5) {
                  try {
                    t5.onCommitFiberUnmount(n3, e5);
                  } catch (e6) {
                  }
                };
              } catch (e5) {
              }
              return true;
            }(i2({}, e3, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: u.ReactCurrentDispatcher, findHostInstanceByFiber: function(e4) {
              return null === (e4 = P(e4)) ? null : e4.stateNode;
            }, findFiberByHostInstance: function(e4) {
              return t4 ? t4(e4) : null;
            }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
          } };
          e2.exports = jo.default || jo;
          var Po = e2.exports;
          return e2.exports = t3, Po;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = Object.getOwnPropertySymbols, i2 = Object.prototype.hasOwnProperty, o2 = Object.prototype.propertyIsEnumerable;
        function a2(e3) {
          if (null == e3)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(e3);
        }
        e2.exports = function() {
          try {
            if (!Object.assign)
              return false;
            var e3 = new String("abc");
            if (e3[5] = "de", "5" === Object.getOwnPropertyNames(e3)[0])
              return false;
            for (var t3 = {}, n3 = 0; n3 < 10; n3++)
              t3["_" + String.fromCharCode(n3)] = n3;
            if ("0123456789" !== Object.getOwnPropertyNames(t3).map(function(e4) {
              return t3[e4];
            }).join(""))
              return false;
            var r3 = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(e4) {
              r3[e4] = e4;
            }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r3)).join("");
          } catch (e4) {
            return false;
          }
        }() ? Object.assign : function(e3, t3) {
          for (var n3, l, u = a2(e3), c = 1; c < arguments.length; c++) {
            for (var s in n3 = Object(arguments[c]))
              i2.call(n3, s) && (u[s] = n3[s]);
            if (r2) {
              l = r2(n3);
              for (var f = 0; f < l.length; f++)
                o2.call(n3, l[f]) && (u[l[f]] = n3[l[f]]);
            }
          }
          return u;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2, i2, o2, a2, l;
        if (Object.defineProperty(t2, "__esModule", { value: true }), "undefined" == typeof window || "function" != typeof MessageChannel) {
          var u = null, c = null, s = function() {
            if (null !== u)
              try {
                var e3 = t2.unstable_now();
                u(true, e3), u = null;
              } catch (e4) {
                throw setTimeout(s, 0), e4;
              }
          }, f = Date.now();
          t2.unstable_now = function() {
            return Date.now() - f;
          }, r2 = function(e3) {
            null !== u ? setTimeout(r2, 0, e3) : (u = e3, setTimeout(s, 0));
          }, i2 = function(e3, t3) {
            c = setTimeout(e3, t3);
          }, o2 = function() {
            clearTimeout(c);
          }, a2 = function() {
            return false;
          }, l = t2.unstable_forceFrameRate = function() {
          };
        } else {
          var p = window.performance, d = window.Date, h = window.setTimeout, m = window.clearTimeout, v = window.requestAnimationFrame, b = window.cancelAnimationFrame;
          if ("undefined" != typeof console && ("function" != typeof v && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" != typeof b && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")), "object" == typeof p && "function" == typeof p.now)
            t2.unstable_now = function() {
              return p.now();
            };
          else {
            var y = d.now();
            t2.unstable_now = function() {
              return d.now() - y;
            };
          }
          var g = false, x = null, w = -1, E = 5, O = 0;
          a2 = function() {
            return t2.unstable_now() >= O;
          }, l = function() {
          }, t2.unstable_forceFrameRate = function(e3) {
            0 > e3 || 125 < e3 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported") : E = 0 < e3 ? Math.floor(1e3 / e3) : 33.33;
          };
          var T = new MessageChannel(), S = T.port2;
          T.port1.onmessage = function() {
            if (null !== x) {
              var e3 = t2.unstable_now();
              O = e3 + E;
              try {
                x(true, e3) ? S.postMessage(null) : (g = false, x = null);
              } catch (e4) {
                throw S.postMessage(null), e4;
              }
            } else
              g = false;
          }, r2 = function(e3) {
            x = e3, g || (g = true, S.postMessage(null));
          }, i2 = function(e3, n3) {
            w = h(function() {
              e3(t2.unstable_now());
            }, n3);
          }, o2 = function() {
            m(w), w = -1;
          };
        }
        function _(e3, t3) {
          var n3 = e3.length;
          e3.push(t3);
          e:
            for (; ; ) {
              var r3 = Math.floor((n3 - 1) / 2), i3 = e3[r3];
              if (!(void 0 !== i3 && 0 < P(i3, t3)))
                break e;
              e3[r3] = t3, e3[n3] = i3, n3 = r3;
            }
        }
        function k(e3) {
          return void 0 === (e3 = e3[0]) ? null : e3;
        }
        function j(e3) {
          var t3 = e3[0];
          if (void 0 !== t3) {
            var n3 = e3.pop();
            if (n3 !== t3) {
              e3[0] = n3;
              e:
                for (var r3 = 0, i3 = e3.length; r3 < i3; ) {
                  var o3 = 2 * (r3 + 1) - 1, a3 = e3[o3], l2 = o3 + 1, u2 = e3[l2];
                  if (void 0 !== a3 && 0 > P(a3, n3))
                    void 0 !== u2 && 0 > P(u2, a3) ? (e3[r3] = u2, e3[l2] = n3, r3 = l2) : (e3[r3] = a3, e3[o3] = n3, r3 = o3);
                  else {
                    if (!(void 0 !== u2 && 0 > P(u2, n3)))
                      break e;
                    e3[r3] = u2, e3[l2] = n3, r3 = l2;
                  }
                }
            }
            return t3;
          }
          return null;
        }
        function P(e3, t3) {
          var n3 = e3.sortIndex - t3.sortIndex;
          return 0 !== n3 ? n3 : e3.id - t3.id;
        }
        var C = [], z = [], I = 1, M = null, N = 3, L = false, R = false, A = false;
        function U(e3) {
          for (var t3 = k(z); null !== t3; ) {
            if (null === t3.callback)
              j(z);
            else {
              if (!(t3.startTime <= e3))
                break;
              j(z), t3.sortIndex = t3.expirationTime, _(C, t3);
            }
            t3 = k(z);
          }
        }
        function F(e3) {
          if (A = false, U(e3), !R)
            if (null !== k(C))
              R = true, r2(D);
            else {
              var t3 = k(z);
              null !== t3 && i2(F, t3.startTime - e3);
            }
        }
        function D(e3, n3) {
          R = false, A && (A = false, o2()), L = true;
          var r3 = N;
          try {
            for (U(n3), M = k(C); null !== M && (!(M.expirationTime > n3) || e3 && !a2()); ) {
              var l2 = M.callback;
              if (null !== l2) {
                M.callback = null, N = M.priorityLevel;
                var u2 = l2(M.expirationTime <= n3);
                n3 = t2.unstable_now(), "function" == typeof u2 ? M.callback = u2 : M === k(C) && j(C), U(n3);
              } else
                j(C);
              M = k(C);
            }
            if (null !== M)
              var c2 = true;
            else {
              var s2 = k(z);
              null !== s2 && i2(F, s2.startTime - n3), c2 = false;
            }
            return c2;
          } finally {
            M = null, N = r3, L = false;
          }
        }
        function W(e3) {
          switch (e3) {
            case 1:
              return -1;
            case 2:
              return 250;
            case 5:
              return 1073741823;
            case 4:
              return 1e4;
            default:
              return 5e3;
          }
        }
        var B = l;
        t2.unstable_ImmediatePriority = 1, t2.unstable_UserBlockingPriority = 2, t2.unstable_NormalPriority = 3, t2.unstable_IdlePriority = 5, t2.unstable_LowPriority = 4, t2.unstable_runWithPriority = function(e3, t3) {
          switch (e3) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              e3 = 3;
          }
          var n3 = N;
          N = e3;
          try {
            return t3();
          } finally {
            N = n3;
          }
        }, t2.unstable_next = function(e3) {
          switch (N) {
            case 1:
            case 2:
            case 3:
              var t3 = 3;
              break;
            default:
              t3 = N;
          }
          var n3 = N;
          N = t3;
          try {
            return e3();
          } finally {
            N = n3;
          }
        }, t2.unstable_scheduleCallback = function(e3, n3, a3) {
          var l2 = t2.unstable_now();
          if ("object" == typeof a3 && null !== a3) {
            var u2 = a3.delay;
            u2 = "number" == typeof u2 && 0 < u2 ? l2 + u2 : l2, a3 = "number" == typeof a3.timeout ? a3.timeout : W(e3);
          } else
            a3 = W(e3), u2 = l2;
          return e3 = { id: I++, callback: n3, priorityLevel: e3, startTime: u2, expirationTime: a3 = u2 + a3, sortIndex: -1 }, u2 > l2 ? (e3.sortIndex = u2, _(z, e3), null === k(C) && e3 === k(z) && (A ? o2() : A = true, i2(F, u2 - l2))) : (e3.sortIndex = a3, _(C, e3), R || L || (R = true, r2(D))), e3;
        }, t2.unstable_cancelCallback = function(e3) {
          e3.callback = null;
        }, t2.unstable_wrapCallback = function(e3) {
          var t3 = N;
          return function() {
            var n3 = N;
            N = t3;
            try {
              return e3.apply(this, arguments);
            } finally {
              N = n3;
            }
          };
        }, t2.unstable_getCurrentPriorityLevel = function() {
          return N;
        }, t2.unstable_shouldYield = function() {
          var e3 = t2.unstable_now();
          U(e3);
          var n3 = k(C);
          return n3 !== M && null !== M && null !== n3 && null !== n3.callback && n3.startTime <= e3 && n3.expirationTime < M.expirationTime || a2();
        }, t2.unstable_requestPaint = B, t2.unstable_continueExecution = function() {
          R || L || (R = true, r2(D));
        }, t2.unstable_pauseExecution = function() {
        }, t2.unstable_getFirstCallbackNode = function() {
          return k(C);
        }, t2.unstable_Profiling = null;
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = Array.isArray, i2 = Object.keys, o2 = Object.prototype.hasOwnProperty;
        e2.exports = function e3(t3, n3) {
          if (t3 === n3)
            return true;
          if (t3 && n3 && "object" == typeof t3 && "object" == typeof n3) {
            var a2, l, u, c = r2(t3), s = r2(n3);
            if (c && s) {
              if ((l = t3.length) != n3.length)
                return false;
              for (a2 = l; 0 != a2--; )
                if (!e3(t3[a2], n3[a2]))
                  return false;
              return true;
            }
            if (c != s)
              return false;
            var f = t3 instanceof Date, p = n3 instanceof Date;
            if (f != p)
              return false;
            if (f && p)
              return t3.getTime() == n3.getTime();
            var d = t3 instanceof RegExp, h = n3 instanceof RegExp;
            if (d != h)
              return false;
            if (d && h)
              return t3.toString() == n3.toString();
            var m = i2(t3);
            if ((l = m.length) !== i2(n3).length)
              return false;
            for (a2 = l; 0 != a2--; )
              if (!o2.call(n3, m[a2]))
                return false;
            for (a2 = l; 0 != a2--; )
              if (!e3(t3[u = m[a2]], n3[u]))
                return false;
            return true;
          }
          return t3 != t3 && n3 != n3;
        };
      }, function(e2, t2, n2) {
        "use strict";
        var r2 = n2(117);
        function i2() {
        }
        function o2() {
        }
        o2.resetWarningCache = i2, e2.exports = function() {
          function e3(e4, t4, n4, i3, o3, a2) {
            if (a2 !== r2) {
              var l = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
              throw l.name = "Invariant Violation", l;
            }
          }
          function t3() {
            return e3;
          }
          e3.isRequired = e3;
          var n3 = { array: e3, bool: e3, func: e3, number: e3, object: e3, string: e3, symbol: e3, any: e3, arrayOf: t3, element: e3, elementType: e3, instanceOf: t3, node: e3, objectOf: t3, oneOf: t3, oneOfType: t3, shape: t3, exact: t3, checkPropTypes: o2, resetWarningCache: i2 };
          return n3.PropTypes = n3, n3;
        };
      }, function(e2, t2, n2) {
        "use strict";
        e2.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      }, function(e2, t2, n2) {
        "use strict";
        n2.r(t2);
        n2(21), n2(40), n2(41), n2(62), n2(64), n2(67), n2(31), n2(71), n2(44), n2(103), n2(72), n2(73), n2(74), n2(75), n2(45), n2(46), n2(47), n2(76), n2(48);
        var r2 = n2(2), i2 = n2(0), o2 = n2.n(i2);
        function a2(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = {}, o3 = Object.keys(e3);
          for (r3 = 0; r3 < o3.length; r3++)
            n3 = o3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e3[n3]);
          return i3;
        }
        function l() {
          return (l = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        var u = n2(83), c = n2.n(u), s = n2(20), f = n2(84), p = (n2(85), n2(86));
        function d(e3) {
          var t3 = function(e4, t4) {
            if ("object" != typeof e4 || null === e4)
              return e4;
            var n3 = e4[Symbol.toPrimitive];
            if (void 0 !== n3) {
              var r3 = n3.call(e4, t4 || "default");
              if ("object" != typeof r3)
                return r3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == typeof t3 ? t3 : String(t3);
        }
        const h = /* @__PURE__ */ new Map(), m = {}, v = { obj: (e3) => e3 === Object(e3), str: (e3) => "string" == typeof e3, num: (e3) => "number" == typeof e3, und: (e3) => void 0 === e3, arr: (e3) => Array.isArray(e3), equ(e3, t3) {
          if (typeof e3 != typeof t3)
            return false;
          if (v.str(e3) || v.num(e3) || v.obj(e3))
            return e3 === t3;
          if (v.arr(e3) && e3 == t3)
            return true;
          let n3;
          for (n3 in e3)
            if (!(n3 in t3))
              return false;
          for (n3 in t3)
            if (e3[n3] !== t3[n3])
              return false;
          return !v.und(n3) || e3 === t3;
        } };
        let b = [];
        function y(e3, t3, n3 = 0, r3 = false) {
          r3 && b.forEach((e4) => e4(t3) && n3++);
          const i3 = e3.current.clock.getDelta();
          return e3.current.subscribers.forEach((t4) => t4.ref.current(e3.current, i3)), e3.current.frames = Math.max(0, e3.current.frames - 1), n3 += e3.current.invalidateFrameloop ? e3.current.frames : 1, e3.current.manual || e3.current.gl.render(e3.current.scene, e3.current.camera), n3;
        }
        let g = false;
        function x(e3) {
          g = true;
          let t3 = 0;
          if (b.forEach((n3) => n3(e3) && t3++), h.forEach((n3) => {
            const r3 = n3.containerInfo.__state;
            r3.current.active && r3.current.ready && (!r3.current.invalidateFrameloop || r3.current.frames > 0) && (t3 = y(r3, e3, t3));
          }), 0 !== t3)
            return requestAnimationFrame(x);
          g = false;
        }
        function w(e3 = true, t3 = 2) {
          if (true === e3)
            h.forEach((e4) => e4.containerInfo.__state.current.frames = t3);
          else if (e3 && e3.current) {
            if (e3.current.vr)
              return;
            e3.current.frames = t3;
          }
          g || (g = true, requestAnimationFrame(x));
        }
        let E = {};
        function O(e3, t3, n3 = {}, i3 = false) {
          const o3 = e3.__container, u2 = Object.keys(t3).filter((e4) => v.equ(t3[e4], n3[e4])), c2 = Object.keys(t3).filter((e4) => "function" == typeof t3[e4] && e4.startsWith("on")), s2 = i3 ? Object.keys(n3).filter((e4) => void 0 === t3[e4]) : [], f2 = [...u2, "children", "key", "ref"].reduce((e4, t4) => {
            return a2(e4, [t4].map(d));
          }, t3);
          if (s2.forEach((e4) => f2[e4] = void 0), Object.keys(f2).length > 0) {
            if (Object.entries(f2).forEach(([t4, n4]) => {
              if (!c2.includes(t4)) {
                let i4 = e3, o4 = i4[t4];
                if (t4.includes("-")) {
                  const n5 = t4.split("-");
                  if (!(o4 = n5.reduce((e4, t5) => e4[t5], e3)) || !o4.set) {
                    const [r3, ...o5] = n5.reverse();
                    i4 = o5.reverse().reduce((e4, t5) => e4[t5], e3), t4 = r3;
                  }
                }
                o4 && o4.set && (o4.copy || o4 instanceof r2.Layers) ? o4.copy && o4.constructor.name === n4.constructor.name ? o4.copy(n4) : Array.isArray(n4) ? o4.set(...n4) : o4.set(n4) : i4[t4] = n4, T(e3);
              }
            }), i3 && o3 && e3.raycast && e3.__handlers) {
              e3.__handlers = void 0;
              const t4 = o3.__interaction.indexOf(e3);
              t4 > -1 && o3.__interaction.splice(t4, 1);
            }
            c2.length && (o3 && e3.raycast && (1 === c2.length && "onUpdate" === c2[0] || o3.__interaction.push(e3)), e3.__handlers = c2.reduce((e4, n4) => l({}, e4, { [n4.charAt(2).toLowerCase() + n4.substr(3)]: t3[n4] }), {})), e3.parent && S(e3);
          }
        }
        function T(e3) {
          e3.__container && e3.__container.__state && w(e3.__container.__state);
        }
        function S(e3) {
          e3.__handlers && e3.__handlers.update && e3.__handlers.update(e3);
        }
        function _(e3, t3, n3, i3, o3) {
          let l2, { args: u2 = [] } = t3, c2 = a2(t3, ["args"]), s2 = "" + e3[0].toUpperCase() + e3.slice(1);
          if ("primitive" === e3)
            (l2 = c2.object).__instance = true;
          else {
            const e4 = E[s2] || r2[s2];
            l2 = v.arr(u2) ? new e4(...u2) : new e4(u2);
          }
          for (; n3.__container; )
            n3 = n3.__container;
          if (!h.has(n3)) {
            const e4 = (t4) => t4.return ? e4(t4.return) : t4.stateNode && t4.stateNode.containerInfo;
            n3 = e4(o3);
          }
          return l2.__objects = [], l2.__container = n3, O(l2, c2, {}), l2;
        }
        function k(e3, t3) {
          t3 && (t3.isObject3D ? e3.add(t3) : (e3.__objects.push(t3), t3.parent = e3, t3.attach ? e3[t3.attach] = t3 : t3.attachArray ? (v.arr(e3[t3.attachArray]) || (e3[t3.attachArray] = []), e3[t3.attachArray].push(t3)) : t3.attachObject && (v.obj(e3[t3.attachObject[0]]) || (e3[t3.attachObject[0]] = {}), e3[t3.attachObject[0]][t3.attachObject[1]] = t3)), S(t3), T(t3));
        }
        function j(e3, t3, n3) {
          if (t3) {
            if (t3.isObject3D) {
              t3.parent = e3, t3.dispatchEvent({ type: "added" });
              const r3 = e3.children.indexOf(n3);
              e3.children = [...e3.children.slice(0, r3), t3, ...e3.children.slice(r3)], S(t3);
            } else
              k(e3, t3);
            T(t3);
          }
        }
        function P(e3, t3, n3 = false) {
          if (e3) {
            (n3 ? [...e3] : e3).forEach((e4) => C(t3, e4));
          }
        }
        function C(e3, t3) {
          t3 && (t3.isObject3D ? e3.remove(t3) : (t3.parent = null, e3.__objects = e3.__objects.filter((e4) => e4 !== t3), t3.attach ? e3[t3.attach] = null : t3.attachArray ? e3[t3.attachArray] = e3[t3.attachArray].filter((e4) => e4 !== t3) : t3.attachObject && delete e3[t3.attachObject[0]][t3.attachObject[1]]), T(t3), Object(s.unstable_runWithPriority)(s.unstable_IdlePriority, () => {
            t3.__container && (t3.__container.__interaction = t3.__container.__interaction.filter((e4) => e4 !== t3)), P(t3.__objects, t3), P(t3.children, t3, true), t3.dispose && t3.dispose(), delete t3.__container, delete t3.__objects;
          }));
        }
        function z(e3, t3, n3, r3) {
          const i3 = e3.parent, o3 = _(t3, n3, e3.__container, 0, r3);
          C(i3, e3), k(i3, o3), [r3, r3.alternate].forEach((e4) => {
            null !== e4 && (e4.stateNode = o3, e4.ref && ("function" == typeof e4.ref ? e4.ref(o3) : e4.ref.current = o3));
          });
        }
        const I = c()({ now: s.unstable_now, createInstance: _, removeChild: C, appendChild: k, insertBefore: j, supportsMutation: true, isPrimaryRenderer: false, scheduleTimeout: "function" == typeof setTimeout ? setTimeout : void 0, cancelTimeout: "function" == typeof clearTimeout ? clearTimeout : void 0, appendInitialChild: k, appendChildToContainer: k, removeChildFromContainer: C, insertInContainerBefore: j, commitUpdate(e3, t3, n3, r3, i3, o3) {
          if (e3.__instance && i3.object && i3.object !== e3)
            z(e3, n3, i3, o3);
          else {
            const { args: t4 = [] } = i3, l2 = a2(i3, ["args"]), { args: u2 = [] } = r3, c2 = a2(r3, ["args"]);
            t4.some((e4, t5) => v.obj(e4) ? Object.entries(e4).some(([e5, n4]) => n4 !== u2[t5][e5]) : e4 !== u2[t5]) ? z(e3, n3, i3, o3) : O(e3, l2, c2, true);
          }
        }, hideInstance(e3) {
          e3.isObject3D && (e3.visible = false, T(e3));
        }, unhideInstance(e3, t3) {
          (e3.isObject3D && null == t3.visible || t3.visible) && (e3.visible = true, T(e3));
        }, getPublicInstance: (e3) => e3, getRootHostContext: () => m, getChildHostContext: () => m, createTextInstance() {
        }, finalizeInitialChildren: () => false, prepareUpdate: () => m, shouldDeprioritizeSubtree: () => false, prepareForCommit() {
        }, resetAfterCommit() {
        }, shouldSetTextContent: () => false });
        "function" == typeof Symbol && Symbol.for && Symbol.for("react.portal");
        function M(e3) {
          return e3.isOrthographicCamera;
        }
        function N(e3) {
          return e3.object.uuid + "/" + e3.index;
        }
        I.injectIntoDevTools({ bundleType: 0, version: "3.0.6", rendererPackageName: "react-three-fiber", findHostInstanceByFiber: I.findHostInstance });
        const L = Object(i2.createContext)({}), R = (e3) => {
          const { children: t3, gl: n3, camera: o3, orthographic: u2, raycaster: c2, size: s2, rayBounds: p2, pixelRatio: d2, vr: m2 = false, shadowMap: v2 = false, invalidateFrameloop: b3 = false, updateDefaultCamera: g2 = true, noEvents: x2 = false, onCreated: E2, onPointerMissed: T2 } = e3, [S2, _2] = Object(i2.useState)(false), [k2] = Object(i2.useState)(() => new r2.Vector2()), [j2] = Object(i2.useState)(() => {
            const e4 = new r2.Raycaster();
            if (c2) {
              O(e4, a2(c2, ["filter"]), {});
            }
            return e4;
          }), [P2] = Object(i2.useState)(() => {
            const e4 = new r2.Scene();
            return e4.__interaction = [], e4.__objects = [], e4;
          }), [C2, z2] = Object(i2.useState)(() => {
            const e4 = u2 ? new r2.OrthographicCamera(0, 0, 0, 0, 0.1, 1e3) : new r2.PerspectiveCamera(75, 0, 0.1, 1e3);
            return e4.position.z = 5, o3 && O(e4, o3, {}), e4;
          }), [R2] = Object(i2.useState)(() => new r2.Clock()), A2 = Object(i2.useRef)({ ready: false, active: true, manual: 0, vr: m2, noEvents: x2, invalidateFrameloop: false, frames: 0, aspect: 0, subscribers: [], camera: C2, scene: P2, raycaster: j2, mouse: k2, clock: R2, gl: n3, size: s2, viewport: { width: 0, height: 0, factor: 0 }, initialClick: [0, 0], initialHits: [], pointer: new f.TinyEmitter(), captured: void 0, subscribe: (e4, t4 = 0) => (t4 && A2.current.manual++, A2.current.subscribers.push({ ref: e4, priority: t4 }), A2.current.subscribers = A2.current.subscribers.sort((e5, t5) => e5.priority - t5.priority), () => {
            t4 && A2.current.manual--, A2.current.subscribers = A2.current.subscribers.filter((t5) => t5.ref !== e4);
          }), setDefaultCamera: (e4) => z2(e4), invalidate: () => w(A2), intersect: (e4) => V2(e4 || {}) });
          Object(i2.useLayoutEffect)(() => {
            A2.current.ready = S2, A2.current.size = s2, A2.current.camera = C2, A2.current.invalidateFrameloop = b3, A2.current.vr = m2, A2.current.gl = n3, A2.current.noEvents = x2;
          }, [b3, m2, x2, S2, s2, C2, n3]), Object(i2.useLayoutEffect)(() => void (d2 && n3.setPixelRatio(d2)), [d2]), Object(i2.useLayoutEffect)(() => {
            v2 && (n3.shadowMap.enabled = true, "object" == typeof v2 ? Object.assign(n3, v2) : n3.shadowMap.type = r2.PCFSoftShadowMap);
          }, [v2]), Object(i2.useLayoutEffect)(() => {
            if (A2.current.aspect = s2.width / s2.height, M(C2))
              A2.current.viewport = { width: s2.width, height: s2.height, factor: 1 };
            else {
              const e4 = new r2.Vector3(0, 0, 0), t4 = C2.position.distanceTo(e4), n4 = r2.Math.degToRad(C2.fov), i3 = 2 * Math.tan(n4 / 2) * t4, o4 = i3 * A2.current.aspect;
              A2.current.viewport = { width: o4, height: i3, factor: s2.width / o4 };
            }
            g2 && (M(C2) ? (C2.left = s2.width / -2, C2.right = s2.width / 2, C2.top = s2.height / 2, C2.bottom = s2.height / -2) : C2.aspect = A2.current.aspect, C2.updateProjectionMatrix(), C2.updateMatrixWorld()), n3.setSize(s2.width, s2.height), S2 && w(A2);
          }, [C2, s2, g2]);
          const U2 = Object(i2.useCallback)(() => {
            const e4 = () => _2(true);
            return Object(i2.useEffect)(() => {
              const t4 = E2 && E2(A2.current);
              t4 && t4.then ? t4.then(e4) : e4();
            }, []), null;
          }, []), F2 = Object(i2.useRef)();
          Object(i2.useLayoutEffect)(() => {
            const e4 = a2(A2.current, ["ready", "manual", "vr", "noEvents", "invalidateFrameloop", "frames", "subscribers", "captured", "initialClick", "initialHits"]);
            F2.current = e4;
          }, [s2, C2]), Object(i2.useLayoutEffect)(() => {
            !function(e4, t4, n4) {
              let r3 = h.get(t4);
              if (!r3) {
                t4.__state = n4;
                let e5 = r3 = I.createContainer(t4, false, false);
                h.set(t4, e5);
              }
              I.updateContainer(e4, r3, null, () => void 0), I.getPublicRootInstance(r3);
            }(Object(i2.createElement)(L.Provider, { value: F2.current }, "function" == typeof t3 ? t3(A2.current) : t3, Object(i2.createElement)(U2, null)), P2, A2);
          }, [S2, t3, F2.current]), Object(i2.useLayoutEffect)(() => {
            S2 && (A2.current.vr ? n3.vr && n3.setAnimationLoop ? (n3.vr.enabled = true, n3.setAnimationLoop((e4) => y(A2, e4, 0, true))) : console.warn("the gl instance does not support VR!") : w(A2));
          }, [S2]), Object(i2.useEffect)(() => () => {
            A2.current.gl && (A2.current.gl.forceContextLoss(), A2.current.gl.dispose(), A2.current.gl = void 0, function(e4) {
              const t4 = h.get(e4);
              t4 && I.updateContainer(null, t4, null, () => void h.delete(e4));
            }(A2.current.scene), A2.current.active = false);
          }, []);
          const D2 = Object(i2.useCallback)((e4) => {
            if (void 0 !== e4.clientX) {
              const { left: t4, right: n4, top: r3, bottom: i3 } = p2.current;
              k2.set((e4.clientX - t4) / (n4 - t4) * 2 - 1, -(e4.clientY - r3) / (i3 - r3) * 2 + 1), j2.setFromCamera(k2, A2.current.camera);
            }
          }, []), W2 = Object(i2.useCallback)((e4, t4 = true) => {
            if (A2.current.noEvents)
              return [];
            t4 && D2(e4);
            const n4 = /* @__PURE__ */ new Set(), r3 = [];
            let i3 = j2.intersectObjects(A2.current.scene.__interaction, true).filter((e5) => {
              const t5 = N(e5);
              return !n4.has(t5) && (n4.add(t5), true);
            });
            c2 && c2.filter && F2.current && (i3 = c2.filter(i3, F2.current));
            for (let e5 of i3) {
              let t5 = e5.object;
              for (; t5; ) {
                t5.__handlers && r3.push(l({}, e5, { eventObject: t5 })), t5 = t5.parent;
              }
            }
            return r3;
          }, []), B2 = Object(i2.useCallback)((e4) => {
            let t4 = e4.clientX - A2.current.initialClick[0], n4 = e4.clientY - A2.current.initialClick[1];
            return Math.round(Math.sqrt(t4 * t4 + n4 * n4));
          }, []), H2 = Object(i2.useCallback)((e4, t4) => {
            D2(e4);
            const n4 = A2.current.captured && "click" !== e4.type && "wheel" !== e4.type ? A2.current.captured : W2(e4, false);
            if (n4.length) {
              const i3 = new r2.Vector3(k2.x, k2.y, 0).unproject(A2.current.camera), o4 = "click" === e4.type ? B2(e4) : 0;
              for (let r3 of n4) {
                let n5 = { current: false };
                if (t4(l({}, e4, {}, r3, { stopped: n5, delta: o4, unprojectedPoint: i3, ray: j2.ray, stopPropagation: () => n5.current = true, sourceEvent: e4 })), true === n5.current)
                  break;
              }
            }
            return n4;
          }, []), q2 = Object(i2.useCallback)((e4) => (t4) => {
            A2.current.pointer.emit(e4, t4);
            const n4 = H2(t4, (t5) => {
              const n5 = t5.eventObject, r3 = n5.__handlers;
              r3 && r3[e4] && ("click" !== e4 || A2.current.initialHits.includes(n5)) && r3[e4](t5);
            });
            "pointerDown" === e4 && (A2.current.initialClick = [t4.clientX, t4.clientY], A2.current.initialHits = n4.map((e5) => e5.eventObject)), "click" === e4 && !n4.length && T2 && B2(t4) <= 2 && T2();
          }, [T2]), Q2 = /* @__PURE__ */ new Map(), V2 = Object(i2.useCallback)((e4) => {
            A2.current.pointer.emit("pointerMove", e4);
            const t4 = H2(e4, (e5) => {
              const t5 = e5.eventObject.__handlers;
              if (t5 && (t5.pointerMove && t5.pointerMove(e5), t5.pointerOver || t5.pointerEnter || t5.pointerOut || t5.pointerLeave)) {
                const n4 = N(e5), r3 = Q2.get(n4);
                r3 ? r3.stopped.current && e5.stopPropagation() : (Q2.set(n4, e5), t5.pointerOver && t5.pointerOver(l({}, e5, { type: "pointerover" })), t5.pointerEnter && t5.pointerEnter(l({}, e5, { type: "pointerEnter" })));
              }
            });
            return G2(e4, t4), t4;
          }, []), G2 = Object(i2.useCallback)((e4, t4) => {
            A2.current.pointer.emit("pointerCancel", e4), t4 || (t4 = H2(e4, () => null)), Array.from(Q2.values()).forEach((e5) => {
              if (t4 && (!t4.length || !t4.find((t5) => t5.eventObject === e5.eventObject))) {
                const t5 = e5.eventObject.__handlers;
                t5 && (t5.pointerOut && t5.pointerOut(l({}, e5, { type: "pointerout" })), t5.pointerLeave && t5.pointerLeave(l({}, e5, { type: "pointerleave" }))), Q2.delete(N(e5));
              }
            });
          }, []);
          return { onClick: q2("click"), onWheel: q2("wheel"), onPointerDown: q2("pointerDown"), onPointerUp: q2("pointerUp"), onPointerLeave: (e4) => G2(e4, []), onPointerMove: V2, onGotPointerCapture: (e4) => A2.current.captured = W2(e4, false), onLostPointerCapture: (e4) => (A2.current.captured = void 0, G2(e4)) };
        };
        function A(e3, t3) {
          return function(e4, t4 = 0) {
            const { subscribe: n3 } = Object(i2.useContext)(L), r3 = Object(i2.useRef)(e4);
            Object(i2.useLayoutEffect)(() => void (r3.current = e4), [e4]), Object(i2.useEffect)(() => {
              const e5 = n3(r3, t4);
              return () => e5();
            }, [t4]);
          }(e3, t3 ? 1 : 0);
        }
        const U = Object(i2.memo)((e3) => {
          let { setEvents: t3, canvas: n3 } = e3, o3 = a2(e3, ["setEvents", "canvas"]);
          const u2 = Object(i2.useMemo)(() => new r2.WebGLRenderer(l({ canvas: n3, antialias: true, alpha: true }, o3.gl)), []), c2 = R(l({}, o3, { gl: u2 }));
          return Object(i2.useEffect)(() => void t3(c2), [c2]), null;
        }), F = { position: "relative", width: "100%", height: "100%", overflow: "hidden" }, D = Object(i2.memo)((e3) => {
          const { style: t3 } = e3, n3 = a2(e3, ["children", "vr", "shadowMap", "orthographic", "invalidateFrameloop", "updateDefaultCamera", "noEvents", "gl", "camera", "raycaster", "pixelRatio", "style", "onCreated", "onPointerMissed"]), r3 = Object(i2.useRef)(), [o3, u2] = Object(i2.useState)({}), [c2, s2, f2] = function() {
            const e4 = Object(i2.useRef)(null), [t4, n4] = Object(i2.useState)({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), [r4] = Object(i2.useState)(() => new p.a(() => e4.current && n4(e4.current.getBoundingClientRect())));
            Object(i2.useEffect)(() => (e4.current && r4.observe(e4.current), () => r4.disconnect()), []);
            const o4 = Object(i2.useRef)(false), a3 = Object(i2.useMemo)(() => ({ _cache: t4, get current() {
              return o4.current && (o4.current = false, this._cache = e4.current.getBoundingClientRect()), this._cache;
            } }), [t4]);
            return Object(i2.useEffect)(() => {
              const t5 = (t6) => {
                o4.current || (o4.current = t6.target.contains(e4.current));
              };
              return window.addEventListener("scroll", t5, { capture: true, passive: true }), () => window.removeEventListener("scroll", t5, true);
            }, []), [e4, t4, a3];
          }();
          return "undefined" == typeof window ? Object(i2.createElement)("div", { style: l({}, F, {}, t3) }, Object(i2.createElement)("canvas", { style: { display: "block" } })) : Object(i2.createElement)("div", l({ ref: c2, style: l({}, F, {}, t3) }, o3, n3), Object(i2.createElement)("canvas", { ref: r3, style: { display: "block" } }), r3.current && Object(i2.createElement)(U, l({}, e3, { size: s2, rayBounds: f2, canvas: r3.current, setEvents: u2 })));
        });
        var W = n2(78), B = n2(1), H = n2.n(B);
        function q() {
          return (q = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function Q(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var V = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = Q(e3, ["color", "size"]);
          return o2.a.createElement("svg", q({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("circle", { cx: "12", cy: "12", r: "10" }), o2.a.createElement("polygon", { points: "10 8 16 12 10 16 10 8" }));
        };
        V.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, V.defaultProps = { color: "currentColor", size: "24" };
        var G = V;
        function $() {
          return ($ = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function K(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var X = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = K(e3, ["color", "size"]);
          return o2.a.createElement("svg", $({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("circle", { cx: "12", cy: "12", r: "10" }), o2.a.createElement("line", { x1: "10", y1: "15", x2: "10", y2: "9" }), o2.a.createElement("line", { x1: "14", y1: "15", x2: "14", y2: "9" }));
        };
        X.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, X.defaultProps = { color: "currentColor", size: "24" };
        var Y = X;
        function J() {
          return (J = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function Z(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var ee = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = Z(e3, ["color", "size"]);
          return o2.a.createElement("svg", J({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("circle", { cx: "12", cy: "12", r: "10" }), o2.a.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "16" }), o2.a.createElement("line", { x1: "8", y1: "12", x2: "16", y2: "12" }));
        };
        ee.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, ee.defaultProps = { color: "currentColor", size: "24" };
        var te2 = ee;
        function ne() {
          return (ne = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function re(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var ie = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = re(e3, ["color", "size"]);
          return o2.a.createElement("svg", ne({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("circle", { cx: "12", cy: "12", r: "10" }), o2.a.createElement("line", { x1: "8", y1: "12", x2: "16", y2: "12" }));
        };
        ie.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, ie.defaultProps = { color: "currentColor", size: "24" };
        var oe = ie;
        function ae() {
          return (ae = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function le(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var ue = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = le(e3, ["color", "size"]);
          return o2.a.createElement("svg", ae({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("polyline", { points: "18 15 12 9 6 15" }));
        };
        ue.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, ue.defaultProps = { color: "currentColor", size: "24" };
        var ce = ue;
        function se() {
          return (se = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function fe(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var pe = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = fe(e3, ["color", "size"]);
          return o2.a.createElement("svg", se({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("polyline", { points: "6 9 12 15 18 9" }));
        };
        pe.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, pe.defaultProps = { color: "currentColor", size: "24" };
        var de = pe;
        function he() {
          return (he = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function me(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var ve = function(e3) {
          var t3 = e3.color, n3 = e3.size, r3 = me(e3, ["color", "size"]);
          return o2.a.createElement("svg", he({ xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: t3, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, r3), o2.a.createElement("polyline", { points: "17 1 21 5 17 9" }), o2.a.createElement("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }), o2.a.createElement("polyline", { points: "7 23 3 19 7 15" }), o2.a.createElement("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" }));
        };
        ve.propTypes = { color: H.a.string, size: H.a.oneOfType([H.a.string, H.a.number]) }, ve.defaultProps = { color: "currentColor", size: "24" };
        var be = ve, ye = n2(79), ge = n2(80), xe = n2(81), we = n2(82);
        function Ee(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function(e4, t4) {
            if (!(Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4)))
              return;
            var n3 = [], r3 = true, i3 = false, o3 = void 0;
            try {
              for (var a3, l2 = e4[Symbol.iterator](); !(r3 = (a3 = l2.next()).done) && (n3.push(a3.value), !t4 || n3.length !== t4); r3 = true)
                ;
            } catch (e5) {
              i3 = true, o3 = e5;
            } finally {
              try {
                r3 || null == l2.return || l2.return();
              } finally {
                if (i3)
                  throw o3;
              }
            }
            return n3;
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var Oe = new r2.LoadingManager();
        var Te = function(e3, t3) {
          var n3 = Object(i2.useMemo)(function() {
            return function(e4) {
              switch (e4) {
                case "gtlf":
                  return new ye.GLTFLoader(Oe);
                case "obj":
                  return new ge.OBJLoader(Oe);
                case "fbx":
                  return new we.FBXLoader(Oe);
                case "collada":
                  return new xe.ColladaLoader(Oe);
              }
            }(e3);
          }, [e3]), o3 = Ee(Object(i2.useState)(void 0), 2), a3 = o3[0], l2 = o3[1], u2 = Ee(Object(i2.useState)(void 0), 2), c2 = u2[0], s2 = u2[1], f2 = Ee(Object(i2.useState)(void 0), 2), p2 = f2[0], d2 = f2[1], h2 = Ee(Object(i2.useState)(0), 2), m2 = h2[0], v2 = h2[1];
          return Object(i2.useEffect)(function() {
            n3.load(t3, function(e4) {
              return l2(e4);
            }, function(e4) {
              var t4 = e4.loaded, n4 = e4.total;
              return v2(t4 / n4 * 100);
            }, function(e4) {
              return d2(e4);
            });
          }, [n3, t3]), Object(i2.useEffect)(function() {
            if (a3) {
              var e4 = new r2.Box3();
              e4.setFromObject(a3.scene);
              var t4 = new r2.Vector3();
              e4.getCenter(t4), s2(t4);
            }
          }, [a3]), { model: a3, modelCenter: c2, progress: m2, error: p2 };
        };
        n2(110);
        function Se(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function(e4, t4) {
            if (!(Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4)))
              return;
            var n3 = [], r3 = true, i3 = false, o3 = void 0;
            try {
              for (var a3, l2 = e4[Symbol.iterator](); !(r3 = (a3 = l2.next()).done) && (n3.push(a3.value), !t4 || n3.length !== t4); r3 = true)
                ;
            } catch (e5) {
              i3 = true, o3 = e5;
            } finally {
              try {
                r3 || null == l2.return || l2.return();
              } finally {
                if (i3)
                  throw o3;
              }
            }
            return n3;
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var _e = { once: r2.LoopOnce, repeat: r2.LoopRepeat }, ke = void 0;
        function je(e3, t3, n3) {
          var r3 = t3._clip.duration * (n3 / 100);
          t3.paused = false, t3.enabled = true, t3.time = 0, e3.time = 0, e3.update(r3);
        }
        function Pe() {
          cancelAnimationFrame(ke), ke = void 0;
        }
        var Ce = function(e3) {
          var t3 = e3.mixer, n3 = e3.progress, r3 = e3.animation, o3 = e3.timeScale, a3 = e3.loopMode, l2 = e3.playing, u2 = e3.setProgress, c2 = e3.setPlaying;
          Object(i2.useEffect)(function() {
            if (t3 && r3 && l2)
              return Pe(), t3.stopAllAction(), je(t3, r3, n3), r3.setEffectiveTimeScale(o3).setLoop(a3, 1 / 0).fadeIn(0).play(), function(e4, t4, n4, r4) {
                var i3 = 0;
                ke = requestAnimationFrame(function o4(a4) {
                  if (t4.paused)
                    return n4(false), r4(0), void (i3 = 0);
                  var l3 = i3 ? a4 - i3 : 0;
                  e4.update(l3 / 1e3), i3 = a4;
                  var u3 = t4._clip.duration, c3 = e4.time % u3;
                  r4(c3 / u3 * 100), ke = requestAnimationFrame(o4);
                });
              }(t3, r3, c2, u2), function() {
                Pe();
              };
          }, [t3, l2, r3]);
        }, ze = function(e3) {
          var t3 = Se(Object(i2.useState)(true), 2), n3 = t3[0], o3 = t3[1], a3 = Se(Object(i2.useState)(_e.repeat), 2), l2 = a3[0], u2 = a3[1], c2 = Se(Object(i2.useState)(1), 2), s2 = c2[0], f2 = c2[1], p2 = Se(Object(i2.useState)(0), 2), d2 = p2[0], h2 = p2[1], m2 = Se(Object(i2.useState)(0), 2), v2 = m2[0], b3 = m2[1], y2 = function(e4) {
            var t4 = e4 && (e4.animations || (e4.geometry || {}).animations) || [], n4 = Se(Object(i2.useState)(void 0), 2), o4 = n4[0], a4 = n4[1], l3 = Se(Object(i2.useState)([]), 2), u3 = l3[0], c3 = l3[1];
            return Object(i2.useEffect)(function() {
              if (e4) {
                var n5 = new r2.AnimationMixer(e4.scene), i3 = t4.map(function(e5) {
                  var t5 = n5.clipAction(e5);
                  return t5.clampWhenFinished = true, t5.enabled = true, t5;
                });
                a4(n5), c3(i3);
              }
            }, [e4]), [o4, u3];
          }(e3), g2 = Se(y2, 2), x2 = g2[0], w2 = g2[1], E2 = w2[v2];
          return Ce({ mixer: x2, progress: d2, animation: E2, playing: n3, loopMode: l2, timeScale: s2, setProgress: h2, setPlaying: o3 }), Object(i2.useEffect)(function() {
            E2 && E2.setLoop(l2, 1 / 0);
          }, [E2, l2]), Object(i2.useEffect)(function() {
            x2 && (x2.timeScale = s2);
          }, [x2, s2]), { progress: d2, loopMode: l2, setLoopMode: u2, timeScale: s2, setTimeScale: f2, animations: w2, animationIndex: v2, setAnimationIndex: function(e4) {
            Pe(), h2(0), je(x2, E2, 0), b3(e4);
          }, playing: n3, play: function() {
            o3(true);
          }, pause: function() {
            Pe(), o3(false);
          }, seek: function(e4) {
            Pe(), o3(false), h2(e4), je(x2, E2, e4);
          } };
        }, Ie = function(e3) {
          var t3 = e3.src, n3 = e3.type, r3 = e3.children, i3 = Te(n3, t3), o3 = i3.model, a3 = i3.modelCenter, l2 = i3.error, u2 = i3.progress, c2 = ze(o3);
          return r3({ model: o3, modelCenter: a3, modelProgress: u2, modelError: l2, animations: c2.animations, animationIndex: c2.animationIndex, playing: c2.playing, loopMode: c2.loopMode, timeScale: c2.timeScale, animationProgress: c2.progress, play: c2.play, pause: c2.pause, seek: c2.seek, setLoopMode: c2.setLoopMode, setTimeScale: c2.setTimeScale, setAnimationIndex: c2.setAnimationIndex });
        };
        function Me() {
          return (Me = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function Ne(e3, t3) {
          var n3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e3);
            t3 && (r3 = r3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function Le(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Ne(n3, true).forEach(function(t4) {
              Re(e3, t4, n3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : Ne(n3).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
            });
          }
          return e3;
        }
        function Re(e3, t3, n3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
        }
        function Ae(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        var Ue = function(e3) {
          var t3 = e3.children, n3 = e3.style, r3 = Ae(e3, ["children", "style"]);
          return i2.createElement("button", Me({}, r3, { style: Le({ background: "none", border: "none", margin: 0, padding: "0 8px", display: "flex", alignItems: "center", color: "#fff", cursor: "pointer" }, n3) }), t3);
        }, Fe = function(e3) {
          var t3 = e3.progress, n3 = e3.style, r3 = Ae(e3, ["progress", "style"]);
          return i2.createElement("progress", Me({ max: 100, value: t3, style: Le({ display: "block" }, n3) }, r3));
        }, De = function(e3) {
          var t3 = e3.children, n3 = e3.position, r3 = void 0 === n3 ? "static" : n3, o3 = e3.display, a3 = void 0 === o3 ? "flex" : o3, l2 = e3.direction, u2 = void 0 === l2 ? "row" : l2, c2 = e3.align, s2 = e3.justify, f2 = e3.top, p2 = e3.bottom, d2 = e3.left, h2 = e3.right, m2 = e3.width, v2 = e3.height, b3 = e3.style;
          return i2.createElement("div", { style: Le({ display: a3, position: r3, flexDirection: u2, alignItems: c2, justifyContent: s2, top: f2, bottom: p2, left: d2, right: h2, width: m2, height: v2 }, b3) }, t3);
        }, We = { whiteSpace: "nowrap", textOverflow: "ellipsis", overflow: "hidden" };
        function Be(e3, t3) {
          if (null == e3)
            return {};
          var n3, r3, i3 = function(e4, t4) {
            if (null == e4)
              return {};
            var n4, r4, i4 = {}, o4 = Object.keys(e4);
            for (r4 = 0; r4 < o4.length; r4++)
              n4 = o4[r4], t4.indexOf(n4) >= 0 || (i4[n4] = e4[n4]);
            return i4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e3);
            for (r3 = 0; r3 < o3.length; r3++)
              n3 = o3[r3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
          }
          return i3;
        }
        function He(e3, t3) {
          var n3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e3);
            t3 && (r3 = r3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function qe(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? He(n3, true).forEach(function(t4) {
              Qe(e3, t4, n3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : He(n3).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
            });
          }
          return e3;
        }
        function Qe(e3, t3, n3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
        }
        function Ve(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function(e4, t4) {
            if (!(Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4)))
              return;
            var n3 = [], r3 = true, i3 = false, o3 = void 0;
            try {
              for (var a3, l2 = e4[Symbol.iterator](); !(r3 = (a3 = l2.next()).done) && (n3.push(a3.value), !t4 || n3.length !== t4); r3 = true)
                ;
            } catch (e5) {
              i3 = true, o3 = e5;
            } finally {
              try {
                r3 || null == l2.return || l2.return();
              } finally {
                if (i3)
                  throw o3;
              }
            }
            return n3;
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        function Ge() {
          return (Ge = Object.assign || function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var r3 in n3)
                Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
            }
            return e3;
          }).apply(this, arguments);
        }
        function $e(e3) {
          var t3 = Object(i2.useRef)(), n3 = Object(i2.useContext)(L).camera;
          return A(function() {
            return t3.current && t3.current.update();
          }, false), i2.createElement("orbitControls", Ge({ ref: t3, args: [n3] }, e3));
        }
        ((e3) => void (E = l({}, E, {}, e3)))({ OrbitControls: W.OrbitControls });
        var Ke = function(e3) {
          var t3 = e3.progress;
          return i2.createElement("button", { style: { position: "absolute", left: "calc(".concat(t3, "% - 4px)"), padding: 0, height: "100%", width: "8px", border: "none", borderRadius: "3px", cursor: "pointer" } });
        }, Xe = function(e3) {
          var t3 = e3.playing, n3 = e3.play, r3 = e3.pause;
          return i2.createElement(Ue, { onClick: t3 ? r3 : n3 }, t3 ? i2.createElement(Y, { size: 16 }) : i2.createElement(G, { size: 16 }));
        }, Ye = function(e3) {
          var t3 = e3.timeScale, n3 = e3.setTimeScale;
          return i2.createElement(i2.Fragment, null, i2.createElement(Ue, { onClick: function() {
            n3(Math.max(0.25, t3 - 0.25));
          } }, i2.createElement(oe, { size: 16 })), i2.createElement(Ue, { onClick: function() {
            n3(Math.min(5, t3 + 0.25));
          } }, i2.createElement(te2, { size: 16 })));
        }, Je = function(e3) {
          var t3 = e3.loopMode, n3 = e3.setLoopMode;
          return i2.createElement(Ue, { onClick: function() {
            var e4 = t3 === r2.LoopRepeat ? r2.LoopOnce : r2.LoopRepeat;
            n3(e4);
          } }, i2.createElement(be, { size: 16, color: t3 === r2.LoopRepeat ? "currentColor" : "#bebebe" }));
        }, Ze = function(e3) {
          var t3 = e3.animations, n3 = e3.animationIndex, r3 = e3.setAnimationIndex, o3 = t3.length && t3[n3]._clip.name, a3 = Ve(Object(i2.useState)(false), 2), l2 = a3[0], u2 = a3[1];
          return i2.createElement(De, { position: "relative" }, l2 && i2.createElement(De, { position: "absolute", direction: "column", justify: "center", bottom: 0, right: 0, style: { marginBottom: "32px", background: "rgba(0, 0, 0, 0.5)", minHeight: "32px", padding: "4px" } }, t3.map(function(e4, t4) {
            return i2.createElement(Ue, { onClick: function() {
              r3(t4), u2(false);
            } }, e4._clip.name);
          })), i2.createElement(Ue, { onClick: function() {
            return u2(!l2);
          } }, i2.createElement("span", { style: qe({ width: "64px" }, We) }, o3), l2 ? i2.createElement(ce, { size: 16 }) : i2.createElement(de, { size: 16 })));
        }, et2 = function(e3) {
          var t3 = e3.animations, n3 = e3.animationIndex, r3 = e3.progress, o3 = e3.timeScale, a3 = e3.loopMode, l2 = e3.playing, u2 = e3.play, c2 = e3.pause, s2 = e3.seek, f2 = e3.setTimeScale, p2 = e3.setLoopMode, d2 = e3.setAnimationIndex;
          return i2.createElement(De, { width: "100%", style: { padding: "8px", background: "rgba(0, 0, 0, 0.5)" } }, i2.createElement(Xe, { play: u2, pause: c2, playing: l2 }), i2.createElement(Ye, { timeScale: o3, setTimeScale: f2 }), i2.createElement(Je, { loopMode: a3, setLoopMode: p2 }), i2.createElement(Ze, { animations: t3, animationIndex: n3, setAnimationIndex: d2 }), i2.createElement(De, { position: "relative", width: "100%", style: { marginLeft: "8px" } }, i2.createElement(Fe, { progress: r3, style: { width: "100%", cursor: "pointer" }, onClick: function(e4) {
            var t4 = e4.currentTarget.getBoundingClientRect().left, n4 = e4.currentTarget.offsetWidth, r4 = e4.clientX;
            s2((r4 - t4) / n4 * 100);
          } }), i2.createElement(Ke, { progress: r3 })));
        }, tt = function(e3) {
          var t3 = e3.src, n3 = e3.type, r3 = e3.aspect, o3 = Be(e3, ["src", "type", "aspect"]);
          return i2.createElement(Ie, { src: t3, type: n3 }, function(e4) {
            var t4 = e4.model, n4 = e4.modelCenter, a3 = e4.modelProgress, l2 = e4.modelError, u2 = e4.animations, c2 = e4.animationIndex, s2 = e4.playing, f2 = e4.loopMode, p2 = e4.timeScale, d2 = e4.animationProgress, h2 = e4.play, m2 = e4.pause, v2 = e4.seek, b3 = e4.setLoopMode, y2 = e4.setTimeScale, g2 = e4.setAnimationIndex;
            return i2.createElement(De, { position: "relative", align: "center", direction: "column", justify: "center" }, a3 < 100 && !l2 && i2.createElement(Fe, { progress: a3, style: { position: "absolute" } }), i2.createElement(De, { position: "relative", width: "100%", style: { paddingBottom: "".concat(r3[1] / r3[0] * 100, "%") } }, i2.createElement(De, { position: "absolute", top: 0, left: 0, width: "100%", height: "100%" }, i2.createElement(D, o3, i2.createElement($e, { camera: n4, enableDamping: true, enablePan: true, dampingFactor: 0.1, rotateSpeed: 0.1, maxPolarAngle: Math.PI / 2 }), i2.createElement("ambientLight", { intensity: 0.5 }), i2.createElement("spotLight", { intensity: 0.8, position: [250, 250, -250] }), i2.createElement("spotLight", { intensity: 0.8, position: [250, 250, 250] }), i2.createElement("spotLight", { intensity: 0.8, position: [-250, 250, 250] }), t4 && i2.createElement("primitive", { object: t4.scene || t4 })))), i2.createElement(et2, { progress: d2, playing: s2, animations: u2, animationIndex: c2, setAnimationIndex: g2, loopMode: f2, setLoopMode: b3, timeScale: p2, setTimeScale: y2, play: h2, pause: m2, seek: v2 }));
          });
        };
        tt.defaultProps = { aspect: [16, 9] };
        var nt = tt;
        t2.default = nt;
      }]);
    });
  }
});
export default require_dist();
/*! Bundled license information:

three/examples/jsm/libs/fflate.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  *)

react-model-viewer/dist/index.js:
  (** @license React v0.23.0
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (** @license React v0.17.0
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-model-viewer.js.map
